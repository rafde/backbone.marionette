{"version":3,"sources":["backbone.marionette.min.js","/source/src/common/trigger-method.js","/source/src/common/monitor-view-events.js","/source/src/common/bind-events.js","/source/src/common/bind-requests.js","/source/src/mixins/behaviors.js","/source/src/utils/get-unique-event-name.js","/source/src/mixins/triggers.js","/source/src/utils/destroy-backbone-view.js","/source/src/config/behaviors-lookup.js","/source/src/config/features.js","/source/src/utils/proxy.js","/source/src/utils/extend.js","/source/src/utils/deprecate.js","/source/src/common/is-node-attached.js","/source/src/common/merge-options.js","/source/src/common/get-option.js","/source/src/common/normalize-methods.js","/source/src/error.js","/source/src/utils/set-options.js","/source/src/mixins/common.js","/source/node_modules/backbone.radio/build/backbone.radio.js","/source/src/mixins/radio.js","/source/src/object.js","/source/src/template-cache.js","/source/src/utils/invoke.js","/source/src/mixins/delegate-entity-events.js","/source/src/mixins/ui.js","/source/src/mixins/view.js","/source/src/region.js","/source/src/mixins/regions.js","/source/src/config/renderer.js","/source/src/view.js","/source/node_modules/backbone.babysitter/lib/backbone.babysitter.js","/source/src/collection-view.js","/source/src/composite-view.js","/source/src/behavior.js","/source/src/application.js","/source/src/app-router.js","/source/src/backbone.marionette.js"],"names":["global","factory","exports","module","require","define","amd","Marionette","Backbone","_","this","__commonjs","fn","__commonjs_global","getEventName","match","prefix","eventName","toUpperCase","triggerMethod","event","methodName","replace","splitter","method","getOption","call","result","_len","arguments","length","args","Array","_key","isFunction","apply","trigger","concat","triggerMethodOn","context","fnc","_len2","_key2","triggerMethodChildren","view","shouldTrigger","_getImmediateChildren","each","child","shouldTriggerAttach","_isAttached","shouldAttach","shouldTriggerDetach","shouldDetach","monitorViewEvents","handleBeforeAttach","handleAttach","triggerDOMRefresh","handleBeforeDetach","handleDetach","handleRender","_isRendered","_areViewEventsMonitored","on","before:attach","attach","before:detach","detach","render","bindFromStrings","target","entity","evt","methods","actionName","methodNames","split","MarionetteError","iterateEvents","bindings","isObject","message","url","isString","bindEvents","unbindEvents","iterateReplies","channel","normalizedRadioRequests","normalizeMethods","bindRequests","unbindRequests","getBehaviorClass","options","key","behaviorClass","Behaviors","behaviorsLookup","parseBehaviors","behaviors","chain","map","BehaviorClass","_options","behavior","nestedBehaviors","flatten","value","uniqueName","selector","uniqueId","join","buildViewTrigger","triggerDef","shouldPreventDefault","preventDefault","shouldStopPropagation","stopPropagation","e","destroyBackboneView","supportsDestroyLifecycle","remove","_isDestroyed","isEnabled","name","FEATURES","setEnabled","state","window","babelHelpers","toConsumableArray","arr","isArray","i","arr2","from","version","proxy","extend","Model","deprecate","test","prev","next","DEV_MODE","undefined","_cache","_warn","_console","console","warn","log","noop","isNodeAttached","el","$","contains","document","documentElement","mergeOptions","keys","pick","optionName","hash","_this","reduce","normalizedHash","errorProps","Error","urlRoot","constructor","error","captureStackTrace","toString","setOptions","CommonMixin","_setOptions","backbone_radio","require$$1","require$$0","Radio","removeHandler","store","callback","_callback","removeHandlers","names","matched","_partial","channelName","_logs","bind","makeCallback","Symbol","iterator","obj","previousRadio","VERSION","noConflict","DEBUG","_debugText","warning","debugLog","eventSplitter","_eventsApi","action","rest","results","l","_callHandler","a1","a2","a3","toArray","slice","tuneIn","_tunedIn","tuneOut","off","Requests","request","requests","_requests","handler","reply","replyOnce","self","once","stopReplying","_channels","Channel","prototype","Events","reset","stopListening","systems","system","channels","RadioMixin","_initRadio","_channel","radioEvents","radioRequests","_destroyRadio","getChannel","ClassOptions","MarionetteObject","cid","cidPrefix","initialize","isDestroyed","destroy","TemplateCache","templateId","templateCaches","get","cachedTemplate","load","clear","compiledTemplate","template","loadTemplate","compileTemplate","$template","html","rawTemplate","_invoke","invokeMap","invoke","BehaviorsMixin","_initBehaviors","_behaviors","_getBehaviorTriggers","triggers","_getBehaviorEvents","events","_proxyBehaviorViewProperties","_delegateBehaviorEntityEvents","_undelegateBehaviorEntityEvents","_destroyBehaviors","_bindBehaviorUIElements","_unbindBehaviorUIElements","_triggerEventOnBehaviors","DelegateEntityEventsMixin","_delegateEntityEvents","model","collection","_undelegateEntityEvents","modelEvents","collectionEvents","delegateEventSplitter","getUniqueEventName","TriggersMixin","_getViewTriggers","_normalizeUIKeys","ui","memo","val","normalizedKey","normalizeUIString","uiString","r","_normalizeUIValues","properties","property","propertyVal","UIMixin","normalizeUIKeys","uiBindings","_getUIBindings","normalizeUIValues","_bindUIElements","_uiBindings","_ui","_unbindUIElements","_this2","$el","_getUI","ViewMixin","supportsRenderLifecycle","isRendered","isAttached","setElement","hasEl","View","delegateEvents","eventsArg","_buildEventProxies","viewEvents","_getEvents","combinedEvents","getTriggers","delegateEntityEvents","undelegateEntityEvents","_ensureViewIsIntact","unbindUIElements","_removeElement","_removeChildren","bindUIElements","getUI","childViewEventPrefix","ret","_triggerMethod","_triggerEventOnParentLayout","_childViewEvents","_childViewTriggers","layoutView","_parentView","eventPrefix","prefixedEventName","_len3","_key3","childViewEvents","childViewTriggers","parent","_parent","Region","replaceElement","_isReplaced","_initEl","getEl","show","_ensureElement","_ensureView","currentView","empty","_renderView","_attachView","shouldReplaceEl","attachHtml","allowMissingEl","_replaceEl","_restoreEl","parentNode","replaceChild","isReplaced","shouldReplace","appendChild","_removeView","detachHtml","_ref","preventDestroy","shouldPreventDestroy","_detachView","contents","hasView","RegionsMixin","regionClass","_initRegions","regions","_regions","addRegions","_reInitRegions","addRegion","definition","isEmpty","_addRegions","regionDefinitions","_buildRegion","_addRegion","_buildRegionFromDefinition","_buildRegionFromObject","_buildRegionFromRegionClass","RegionClass","omit","defaults","parentEl","partial","region","removeRegion","_removeRegion","removeRegions","getRegions","emptyRegions","hasRegion","getRegion","clone","showChildView","getChildView","Renderer","data","templateFunc","serializeData","serializeModel","items","serializeCollection","attributes","_renderTemplate","getTemplate","mixinTemplateContext","attachElContent","templateContext","compact","backbone_babysitter","root","previousChildViewContainer","ChildViewContainer","Container","views","_views","_indexByModel","_indexByCustom","_updateLength","add","customIndex","_add","findByModel","findByModelCid","modelCid","viewCid","findByCid","findByCustom","index","findByIndex","values","_remove","size","some","CollectionView","sort","_initialEvents","_initChildViewStorage","_bufferedChildren","_startBuffering","_isBuffering","_endBuffering","triggerOnChildren","attachBuffer","_createBuffer","children","listenTo","_onCollectionAdd","_onCollectionUpdate","_sortViews","opts","at","indexOf","filter","_filteredSortedModels","_shouldAddChild","_destroyEmptyView","ChildView","_getChildView","_addChild","removed","changes","isRemoving","_removeChildViews","modelsOrViews","checkEmpty","shouldCheckEmpty","removedViews","removingViews","modelOrView","_index","unshift","_updateIndices","_checkEmpty","_renderChildren","setFilter","_ref2","preventRender","canBeRendered","filterChanged","shouldRender","previousModels","models","_applyModelDeltas","removeFilter","currentIds","addedChildNotExists","removeModel","prevModel","reorder","_this3","_showingEmptyView","anyModelsAdded","elsToReorder","filteredOutViews","_appendReorderedChildren","resortView","reorderOnSort","_this4","orderChanged","find","item","_emptyViewIndex","append","_destroyChildren","processedModels","_showEmptyView","_showCollection","_this5","addedAt","viewComparator","getViewComparator","Math","min","max","addedModel","_sortModelsBy","splice","_filterModels","_this6","comparator","sortBy","EmptyView","_getEmptyView","emptyViewOptions","childViewOptions","buildChildView","_addChildView","emptyView","_getView","childView","_getChildViewOptions","addChildView","increment","laterView","_proxyChildEvents","ChildViewClass","collectionView","buffer","elBuffer","createDocumentFragment","b","_insertBefore","_insertAfter","findPosition","before","childViews","identity","_this7","childEventName","CompositeView","renderChildren","_isRendering","resetChildViewContainer","compositeView","$container","getChildViewContainer","containerView","$childViewContainer","container","childViewContainer","charAt","substr","MixinFromView","Behavior","proxyViewProperties","getEvents","behaviorEvents","behaviorHandler","behaviorTriggers","Application","_initRegion","_region","showView","getView","start","AppRouter","Router","appRoutes","controller","_getController","processAppRoutes","_processOnRoute","appRoute","route","_addAppRoute","routeName","routeArgs","onRoute","routePath","invert","routeNames","reverse","previousMarionette","Object"],"mappings":";;;;;;;;;;;;;;;CAoBC,SAAUA,EAAQC,GACC,gBAAZC,UAA0C,mBAAXC,QAAyBA,OAAOD,QAAUD,EAAQG,QAAQ,YAAaA,QAAQ,eACnG,kBAAXC,SAAyBA,OAAOC,IAAMD,QAAQ,WAAY,cAAeJ,GAC/ED,EAAOO,WAAaP,EAAW,GAAIC,EAAQD,EAAOQ,SAASR,EAAOS,IAClEC,KAAM,SAAUF,EAASC,GAAK,YAM/B,SAASE,GAAWC,EAAIT,GAAU,MAAOA,IAAWD,YAAeU,EAAGT,EAAQA,EAAOD,QAASW,GAAoBV,EAAOD,QCnB1H,QAASY,GAAaC,EAAOC,EAAQC,GACnC,MAAOA,GAAUC,cAUZ,QAASC,GAAcC,GAAgB,IAAA,GAEtCC,GAAa,KAAOD,EAAME,QAAQC,EAAUT,GAC5CU,EAASC,EAAUC,KAAKhB,KAAMW,GAChCM,EAAA,OAJwCC,EAAAC,UAAAC,OAANC,EAAMC,MAAAJ,EAAA,EAAAA,EAAA,EAAA,GAAAK,EAAA,EAAAA,EAAAL,EAAAK,IAANF,EAAME,EAAA,GAAAJ,UAAAI,EAe5C,OARIxB,GAAEyB,WAAWV,KAEfG,EAASH,EAAOW,MAAMzB,KAAMqB,IAI9BrB,KAAK0B,QAALD,MAAAzB,MAAaU,GAAbiB,OAAuBN,IAEhBJ,EAOF,QAASW,GAAgBC,GAAkB,IAAA,GAC1CC,GAAM/B,EAAEyB,WAAWK,EAAQpB,eAAiBoB,EAAQpB,cAAgBA,EAD1BsB,EAAAZ,UAAAC,OAANC,EAAMC,MAAAS,EAAA,EAAAA,EAAA,EAAA,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAANX,EAAMW,EAAA,GAAAb,UAAAa,EAEhD,OAAOF,GAAIL,MAAMI,EAASR,GCvC5B,QAASY,GAAsBC,EAAMxB,EAAOyB,GACrCD,EAAKE,uBACVrC,EAAEsC,KAAKH,EAAKE,wBAAyB,SAAAE,GAC9BH,EAAcG,IACnBV,EAAgBU,EAAO5B,EAAO4B,KAIlC,QAASC,GAAoBL,GAC3B,OAAQA,EAAKM,YAGf,QAASC,GAAaP,GACpB,QAAKK,EAAoBL,KACzBA,EAAKM,aAAc,GACZ,GAGT,QAASE,GAAoBR,GAC3B,MAAOA,GAAKM,YAGd,QAASG,GAAaT,GACpB,QAAKQ,EAAoBR,KACzBA,EAAKM,aAAc,GACZ,GAKT,QAASI,GAAkBV,GAKzB,QAASW,KACPZ,EAAsBC,EAAM,gBAAiBK,GAG/C,QAASO,KACPb,EAAsBC,EAAM,SAAUO,GACtCM,IAGF,QAASC,KACPf,EAAsBC,EAAM,gBAAiBQ,GAG/C,QAASO,KACPhB,EAAsBC,EAAM,SAAUS,GAGxC,QAASO,KACPH,IAGF,QAASA,KACHb,EAAKM,aAAeN,EAAKiB,aAC3BvB,EAAgBM,EAAM,cAAeA,GA3BrCA,EAAKkB,0BAETlB,EAAKkB,yBAA0B,EA6B/BlB,EAAKmB,IACHC,gBAAiBT,EACjBU,OAAUT,EACVU,gBAAiBR,EACjBS,OAAUR,EACVS,OAAUR,KCtDd,QAASS,GAAgBC,EAAQC,EAAQC,EAAKC,EAASC,GACrD,GAAMC,GAAcF,EAAQG,MAAM,MAElCnE,GAAEsC,KAAK4B,EAAa,SAAStD,GAC3B,GAAMG,GAAS8C,EAAOjD,EACtB,KAAKG,EACH,KAAM,IAAIqD,GAAJ,WAA+BxD,EAA/B,4DAGRiD,GAAOI,GAAYH,EAAQC,EAAKhD,KAKpC,QAASsD,GAAcR,EAAQC,EAAQQ,EAAUL,GAC/C,GAAKH,GAAWQ,EAAhB,CAGA,IAAKtE,EAAEuE,SAASD,GACd,KAAM,IAAIF,IACRI,QAAS,8BACTC,IAAK,kDAKTzE,GAAEsC,KAAKgC,EAAU,SAASvD,EAAQgD,GAGhC,MAAI/D,GAAE0E,SAAS3D,OACb6C,GAAgBC,EAAQC,EAAQC,EAAKhD,EAAQkD,OAI/CJ,GAAOI,GAAYH,EAAQC,EAAKhD,MAIpC,QAAS4D,GAAWb,EAAQQ,GAE1B,MADAD,GAAcpE,KAAM6D,EAAQQ,EAAU,YAC/BrE,KAGT,QAAS2E,GAAad,EAAQQ,GAE5B,MADAD,GAAcpE,KAAM6D,EAAQQ,EAAU,iBAC/BrE,KChDT,QAAS4E,GAAehB,EAAQiB,EAASR,EAAUL,GACjD,GAAKa,GAAYR,EAAjB,CAGA,IAAKtE,EAAEuE,SAASD,GACd,KAAM,IAAIF,IACRI,QAAS,8BACTC,IAAK,oDAIT,IAAMM,GAA0BC,EAAiB/D,KAAK4C,EAAQS,EAE9DQ,GAAQb,GAAYc,EAAyBlB,IAG/C,QAASoB,GAAaH,EAASR,GAE7B,MADAO,GAAe5E,KAAM6E,EAASR,EAAU,SACjCrE,KAGT,QAASiF,GAAeJ,EAASR,GAE/B,MADAO,GAAe5E,KAAM6E,EAASR,EAAU,gBACjCrE,KC1BT,QAASkF,GAAiBC,EAASC,GACjC,MAAID,GAAQE,cACHF,EAAQE,cAENtF,EAAEyB,WAAW2D,GACfA,EAILpF,EAAEyB,WAAW3B,GAAWyF,UAAUC,iBAC7B1F,GAAWyF,UAAUC,gBAAgBJ,EAASC,GAAKA,GAGrDvF,GAAWyF,UAAUC,gBAAgBH,GAM9C,QAASI,GAAetD,EAAMuD,GAC5B,MAAO1F,GAAE2F,MAAMD,GAAWE,IAAI,SAASR,EAASC,GAC9C,GAAMQ,GAAgBV,EAAiBC,EAASC,GAE1CS,EAAWV,IAAYS,KAAqBT,EAC5CW,EAAW,GAAIF,GAAcC,EAAU3D,GACvC6D,EAAkBP,EAAetD,EAAMnC,EAAEkB,OAAO6E,EAAU,aAEhE,QAAQA,GAAUnE,OAAOoE,KACxBC,UAAUC,QCrCf,QAASC,GAAW3F,EAAW4F,GAC7B,OAAQ5F,EAAYR,EAAEqG,SAAS,QAASD,GAAUE,KAAK,KCDzD,QAASC,GAAiBpE,EAAMqE,GAC1BxG,EAAE0E,SAAS8B,KACbA,GAAc7F,MAAO6F,GAGvB,IAAMhG,GAAYgG,EAAW7F,MACvB8F,EAAuBD,EAAWE,kBAAmB,EACrDC,EAAwBH,EAAWI,mBAAoB,CAE7D,OAAO,UAASC,GACVJ,GACFI,EAAEH,iBAGAC,GACFE,EAAED,kBAGJzE,EAAKzB,cAAcF,EAAW2B,ICrBnB,QAAS2E,GAAoB3E,GACrCA,EAAK4E,0BACRlF,EAAgBM,EAAM,iBAAkBA,EAG1C,IAAMQ,KAAwBR,EAAKM,WAE/BE,IACFd,EAAgBM,EAAM,gBAAiBA,GAGzCA,EAAK6E,SAEDrE,IACFR,EAAKM,aAAc,EACnBZ,EAAgBM,EAAM,SAAUA,IAGlCA,EAAK8E,cAAe,EAEf9E,EAAK4E,0BACRlF,EAAgBM,EAAM,UAAWA,GCZtB,QAASqD,KACtB,KAAM,IAAIpB,IACRI,QAAS,mDACTC,IAAK,4CCTT,QAASyC,GAAUC,GACjB,QAASC,GAASD,GAGpB,QAASE,GAAWF,EAAMG,GACxB,MAAOF,IAASD,GAAQG,EVgBzBvH,EAAW,WAAaA,GAAWA,EAAS,WAAaA,EACzDC,EAAI,WAAaA,GAAIA,EAAE,WAAaA,CAEpC,IAAII,GAAsC,mBAAXmH,QAAyBA,OAA2B,mBAAXhI,QAAyBA,OAASU,KAItGuH,IAEJA,GAAaC,kBAAoB,SAAUC,GACzC,GAAInG,MAAMoG,QAAQD,GAAM,CACtB,IAAK,GAAIE,GAAI,EAAGC,EAAOtG,MAAMmG,EAAIrG,QAASuG,EAAIF,EAAIrG,OAAQuG,IAAKC,EAAKD,GAAKF,EAAIE,EAE7E,OAAOC,GAEP,MAAOtG,OAAMuG,KAAKJ,GAMtB,IAAIK,GAAU,cW9CTC,EAAQ,SAASjH,GACrB,MAAO,UAASe,GAAkB,IAAA,GAAAX,GAAAC,UAAAC,OAANC,EAAMC,MAAAJ,EAAA,EAAAA,EAAA,EAAA,GAAAK,EAAA,EAAAA,EAAAL,EAAAK,IAANF,EAAME,EAAA,GAAAJ,UAAAI,EAChC,OAAOT,GAAOW,MAAMI,EAASR,KCG3B2G,EAASlI,EAASmI,MAAMD,OCAxBE,EAAY,QAAZA,IAAqB3D,EAAS4D,GAC9BpI,EAAEuE,SAASC,KACbA,EACEA,EAAQ6D,KAAO,qDACC7D,EAAQ8D,KAAO,aAC9B9D,EAAQC,IAAM,SAAWD,EAAQC,IAAM,KAIvC3E,GAAWyI,WAIFC,SAATJ,GAAuBA,GAAUD,GAAUM,OAAOjE,KACrD2D,GAAUO,MAAM,wBAA0BlE,GAC1C2D,GAAUM,OAAOjE,IAAW,IAIhC2D,GAAUQ,SAA8B,mBAAZC,SAA0BA,WACtDT,EAAUO,MAAQ,WAChB,GAAMG,GAAOV,EAAUQ,SAASE,MAAQV,EAAUQ,SAASG,KAAO9I,EAAE+I,IACpE,OAAOF,GAAKnH,MAAMyG,EAAUQ,SAAUvH,YAExC+G,EAAUM,SCxBV,IAAMO,GAAiB,SAASC,GAC9B,MAAOlJ,GAASmJ,EAAEC,SAASC,SAASC,gBAAiBJ,ICJjDK,EAAe,SAASlE,EAASmE,GAChCnE,GACLpF,EAAEiI,OAAOhI,KAAMD,EAAEwJ,KAAKpE,EAASmE,KCA3BvI,EAAY,SAASyI,GACzB,GAAKA,EACL,MAAIxJ,MAAKmF,SAAyCoD,SAA7BvI,KAAKmF,QAAQqE,GACzBxJ,KAAKmF,QAAQqE,GAEbxJ,KAAKwJ,ICHVzE,EAAmB,SAAS0E,GAAM,GAAAC,GAAA1J,IACtC,OAAOD,GAAE4J,OAAOF,EAAM,SAACG,EAAgB9I,EAAQoG,GAO7C,MANKnH,GAAEyB,WAAWV,KAChBA,EAAS4I,EAAK5I,IAEZA,IACF8I,EAAe1C,GAAQpG,GAElB8I,QhBRL/I,EAAW,ciBAXgJ,GAAc,cAAe,WAAY,aAAc,OAAQ,UAAW,UAE1E1F,EAAkB6D,EAAOhH,KAAK8I,OAClCC,QAAA,iCAA0CjC,EAA1C,IAEAkC,YAHyC,SAG7BzF,EAASY,GACfpF,EAAEuE,SAASC,IACbY,EAAUZ,EACVA,EAAUY,EAAQZ,SACRY,IACVA,KAGF,IAAM8E,GAAQH,MAAM9I,KAAKhB,KAAMuE,EAC/BxE,GAAEiI,OAAOhI,KAAMD,EAAEwJ,KAAKU,EAAOJ,GAAa9J,EAAEwJ,KAAKpE,EAAS0E,IAE1D7J,KAAKkK,oBAED/E,EAAQX,MACVxE,KAAKwE,IAAMxE,KAAK+J,QAAU5E,EAAQX,MAItC0F,kBArByC,WAsBnCJ,MAAMI,mBACRJ,MAAMI,kBAAkBlK,KAAMmE,IAIlCgG,SA3ByC,WA4BvC,MAAOnK,MAAKkH,KAAO,KAAOlH,KAAKuE,SAAWvE,KAAKwE,IAAM,SAAWxE,KAAKwE,IAAM,MAI/EL,GAAgB6D,OAASA,CCtCzB,IAAMoC,GAAa,WAAkB,IAAA,GAAAlJ,GAAAC,UAAAC,OAANC,EAAMC,MAAAJ,GAAAK,EAAA,EAAAA,EAAAL,EAAAK,IAANF,EAAME,GAAAJ,UAAAI,EACnCvB,MAAKmF,QAAUpF,EAAEiI,OAAFvG,MAAA1B,MAAaA,EAAEkB,OAAOjB,KAAM,YAA5B2B,OAA2CN,KnBmYvDgJ,GoB1XHtF,iBAAkBA,EAElBuF,YAAaA,EAGbjB,aAAcA,EAGdtI,UAAWA,EAGX2D,WAAYA,EAGZC,aAAcA,GpBiYX4F,EAAiBtK,EAAW,SAAUR,EAAQD,EAASF,IqB1Z3D,SAAUA,EAAQC,GACE,gBAAZC,IAA0C,mBAAXC,GAAyBA,EAAOD,QAAUD,EAAQiL,EAAuBC,GAC7F,kBAAX9K,SAAyBA,OAAOC,IAAMD,QAAQ,aAAc,YAAaJ,IAC/ED,EAAOQ,SAAWR,EAAOQ,aAAgBR,EAAOQ,SAAS4K,MAAQnL,EAAQD,EAAOS,EAAET,EAAOQ,YAC1FE,EAAM,SAAUD,EAAED,GAqGlB,QAAS6K,GAAcC,EAAO1D,EAAM2D,EAAUhJ,GAC5C,GAAInB,GAAQkK,EAAM1D,EAClB,MAAM2D,GAAYA,IAAanK,EAAMmK,UAAYA,IAAanK,EAAMmK,SAASC,WAAgBjJ,GAAWA,IAAYnB,EAAMmB,SAExH,aADO+I,GAAM1D,IACN,EAIX,QAAS6D,GAAeH,EAAO1D,EAAM2D,EAAUhJ,GAC7C+I,IAAUA,KAIV,KAAK,GAHDI,GAAQ9D,GAAQA,GAAQnH,EAAEuJ,KAAKsB,GAC/BK,GAAU,EAELtD,EAAI,EAAGvG,EAAS4J,EAAM5J,OAAQuG,EAAIvG,EAAQuG,IACjDT,EAAO8D,EAAMrD,GAIRiD,EAAM1D,IAIPyD,EAAcC,EAAO1D,EAAM2D,EAAUhJ,KACvCoJ,GAAU,EAId,OAAOA,GAcT,QAASC,GAASC,GAChB,MAAOC,GAAMD,KAAiBC,EAAMD,GAAepL,EAAEsL,KAAKX,EAAM7B,IAAK6B,EAAOS,IAyC9E,QAASG,GAAaT,GACpB,MAAO9K,GAAEyB,WAAWqJ,GAAYA,EAAW,WACzC,MAAOA,IAxLX9K,EAAI,WAAaA,GAAIA,EAAE,WAAaA,EACpCD,EAAW,WAAaA,GAAWA,EAAS,WAAaA,CAEzD,IAAIyH,KACJA,GAAAA,UAAwC,kBAAXgE,SAAoD,gBAApBA,QAAOC,SAAwB,SAAUC,GACpG,aAAcA,IACZ,SAAUA,GACZ,MAAOA,IAAyB,kBAAXF,SAAyBE,EAAIzB,cAAgBuB,OAAS,eAAkBE,GAI/F,IAAIC,GAAgB5L,EAAS4K,MAEzBA,EAAQ5K,EAAS4K,QAErBA,GAAMiB,QAAU,cAMhBjB,EAAMkB,WAAa,WAEjB,MADA9L,GAAS4K,MAAQgB,EACV1L,MAKT0K,EAAMmB,OAAQ,EAGdnB,EAAMoB,WAAa,SAAUC,EAASxL,EAAW4K,GAC/C,MAAOY,IAAWZ,EAAc,WAAaA,EAAc,WAAa,IAAM,MAAQ5K,EAAY,KAOpGmK,EAAMsB,SAAW,SAAUD,EAASxL,EAAW4K,GACzCT,EAAMmB,OAASlD,SAAWA,QAAQC,MACpCD,QAAQC,KAAK8B,EAAMoB,WAAWC,EAASxL,EAAW4K,IAItD,IAAIc,GAAgB,KAMpBvB,GAAMwB,WAAa,SAAUT,EAAKU,EAAQjF,EAAMkF,GAC9C,IAAKlF,EACH,OAAO,CAGT,IAAImF,KAGJ,IAAgF,YAA3D,mBAATnF,GAAuB,YAAcK,EAAAA,UAAoBL,IAAqB,CACxF,IAAK,GAAI9B,KAAO8B,GAAM,CACpB,GAAIjG,GAASwK,EAAIU,GAAQ1K,MAAMgK,GAAMrG,EAAK8B,EAAK9B,IAAMzD,OAAOyK,GAC5DH,GAAc9D,KAAK/C,GAAOrF,EAAEiI,OAAOqE,EAASpL,GAAUoL,EAAQjH,GAAOnE,EAEvE,MAAOoL,GAIT,GAAIJ,EAAc9D,KAAKjB,GAAO,CAE5B,IAAK,GADD8D,GAAQ9D,EAAKhD,MAAM+H,GACdtE,EAAI,EAAG2E,EAAItB,EAAM5J,OAAQuG,EAAI2E,EAAG3E,IACvC0E,EAAQrB,EAAMrD,IAAM8D,EAAIU,GAAQ1K,MAAMgK,GAAMT,EAAMrD,IAAIhG,OAAOyK,GAE/D,OAAOC,GAGT,OAAO,GAIT3B,EAAM6B,aAAe,SAAU1B,EAAUhJ,EAASR,GAChD,GAAImL,GAAKnL,EAAK,GACVoL,EAAKpL,EAAK,GACVqL,EAAKrL,EAAK,EACd,QAAQA,EAAKD,QACX,IAAK,GACH,MAAOyJ,GAAS7J,KAAKa,EACvB,KAAK,GACH,MAAOgJ,GAAS7J,KAAKa,EAAS2K,EAChC,KAAK,GACH,MAAO3B,GAAS7J,KAAKa,EAAS2K,EAAIC,EACpC,KAAK,GACH,MAAO5B,GAAS7J,KAAKa,EAAS2K,EAAIC,EAAIC,EACxC,SACE,MAAO7B,GAASpJ,MAAMI,EAASR,IA0CrC,IAAI+J,KAQJrL,GAAEiI,OAAO0C,GAGP7B,IAAK,SAAasC,EAAa5K,GAC7B,GAAuB,mBAAZoI,SAAX,CAGA,GAAItH,GAAOtB,EAAE4M,QAAQxL,WAAWyL,MAAM,EACtCjE,SAAQE,IAAI,IAAMsC,EAAc,MAAQ5K,EAAY,IAAKc,KAM3DwL,OAAQ,SAAgB1B,GACtB,GAAItG,GAAU6F,EAAM7F,QAAQsG,EAG5B,OAFAtG,GAAQiI,UAAW,EACnBjI,EAAQxB,GAAG,MAAO6H,EAASC,IACpBnL,MAIT+M,QAAS,SAAiB5B,GACxB,GAAItG,GAAU6F,EAAM7F,QAAQsG,EAI5B,OAHAtG,GAAQiI,UAAW,EACnBjI,EAAQmI,IAAI,MAAO9B,EAASC,UACrBC,GAAMD,GACNnL,QAiBX0K,EAAMuC,UAGJC,QAAS,SAAiBhG,GACxB,GAAI7F,GAAOtB,EAAE4M,QAAQxL,WAAWyL,MAAM,GAClCP,EAAU3B,EAAMwB,WAAWlM,KAAM,UAAWkH,EAAM7F,EACtD,IAAIgL,EACF,MAAOA,EAET,IAAIlB,GAAcnL,KAAKmL,YACnBgC,EAAWnN,KAAKoN,SAQpB,IALIjC,GAAenL,KAAK8M,UACtBpC,EAAM7B,IAAIpH,MAAMzB,MAAOmL,EAAajE,GAAMvF,OAAON,IAI/C8L,IAAaA,EAASjG,IAASiG,EAAS,YAAa,CACvD,GAAIE,GAAUF,EAASjG,IAASiG,EAAS,UAEzC,OADA9L,GAAO8L,EAASjG,GAAQ7F,EAAOF,UACxBuJ,EAAM6B,aAAac,EAAQxC,SAAUwC,EAAQxL,QAASR,GAE7DqJ,EAAMsB,SAAS,iCAAkC9E,EAAMiE,IAK3DmC,MAAO,SAAepG,EAAM2D,EAAUhJ,GACpC,MAAI6I,GAAMwB,WAAWlM,KAAM,QAASkH,GAAO2D,EAAUhJ,IAC5C7B,MAGTA,KAAKoN,YAAcpN,KAAKoN,cAEpBpN,KAAKoN,UAAUlG,IACjBwD,EAAMsB,SAAS,4BAA6B9E,EAAMlH,KAAKmL,aAGzDnL,KAAKoN,UAAUlG,IACb2D,SAAUS,EAAaT,GACvBhJ,QAASA,GAAW7B,MAGfA,OAITuN,UAAW,SAAmBrG,EAAM2D,EAAUhJ,GAC5C,GAAI6I,EAAMwB,WAAWlM,KAAM,YAAakH,GAAO2D,EAAUhJ,IACvD,MAAO7B,KAGT,IAAIwN,GAAOxN,KAEPyN,EAAO1N,EAAE0N,KAAK,WAEhB,MADAD,GAAKE,aAAaxG,GACXoE,EAAaT,GAAUpJ,MAAMzB,KAAMmB,YAG5C,OAAOnB,MAAKsN,MAAMpG,EAAMuG,EAAM5L,IAIhC6L,aAAc,SAAsBxG,EAAM2D,EAAUhJ,GAClD,MAAI6I,GAAMwB,WAAWlM,KAAM,eAAgBkH,GAClClH,MAIJkH,GAAS2D,GAAahJ,EAEfkJ,EAAe/K,KAAKoN,UAAWlG,EAAM2D,EAAUhJ,IACzD6I,EAAMsB,SAAS,+CAAgD9E,EAAMlH,KAAKmL,mBAFnEnL,MAAKoN,UAKPpN,QAWX0K,EAAMiD,aAENjD,EAAM7F,QAAU,SAAUsG,GACxB,IAAKA,EACH,KAAM,IAAIrB,OAAM,2CAGlB,OAAIY,GAAMiD,UAAUxC,GACXT,EAAMiD,UAAUxC,GAEhBT,EAAMiD,UAAUxC,GAAe,GAAIT,GAAMkD,QAAQzC,IAY5DT,EAAMkD,QAAU,SAAUzC,GACxBnL,KAAKmL,YAAcA,GAGrBpL,EAAEiI,OAAO0C,EAAMkD,QAAQC,UAAW/N,EAASgO,OAAQpD,EAAMuC,UAGvDc,MAAO,WAIL,MAHA/N,MAAKgN,MACLhN,KAAKgO,gBACLhO,KAAK0N,eACE1N,OAYX,IAAI6E,GACAxD,EACA4M,GAAWnO,EAASgO,OAAQpD,EAAMuC,SAkBtC,OAjBAlN,GAAEsC,KAAK4L,EAAS,SAAUC,GACxBnO,EAAEsC,KAAK6L,EAAQ,SAAUpN,EAAQH,GAC/B+J,EAAM/J,GAAc,SAAUwK,GAG5B,MAFA9J,GAAOtB,EAAE4M,QAAQxL,WAAWyL,MAAM,GAClC/H,EAAU7E,KAAK6E,QAAQsG,GAChBtG,EAAQlE,GAAYc,MAAMoD,EAASxD,QAKhDqJ,EAAMqD,MAAQ,SAAU5C,GACtB,GAAIgD,GAAYhD,GAAgCnL,KAAK2N,UAAUxC,IAAjCnL,KAAK2N,SACnC5N,GAAEsC,KAAK8L,EAAU,SAAUtJ,GACzBA,EAAQkJ,WAILrD,MrBkaJA,EAASH,GAA4C,gBAAnBA,IAA+B,WAAaA,GAAiBA,EAAe,WAAaA,EsB5uBhI6D,GAEEC,WAFa,WAGX,GAAMlD,GAAcpL,EAAEkB,OAAOjB,KAAM,cAEnC,IAAKmL,EAAL,CAIA,GAAMtG,GAAU7E,KAAKsO,SAAW5D,EAAM7F,QAAQsG,GAExCoD,EAAcxO,EAAEkB,OAAOjB,KAAM,cACnCA,MAAK0E,WAAWG,EAAS0J,EAEzB,IAAMC,GAAgBzO,EAAEkB,OAAOjB,KAAM,gBACrCA,MAAKgF,aAAaH,EAAS2J,GAE3BxO,KAAKqD,GAAG,UAAWrD,KAAKyO,iBAG1BA,cApBa,WAqBXzO,KAAKsO,SAASZ,aAAa,KAAM,KAAM1N,OAGzC0O,WAxBa,WAyBX,MAAO1O,MAAKsO,UAId5J,WAAYA,EAGZC,aAAcA,EAGdK,aAAcA,EAGdC,eAAgBA,GC9CZ0J,GACJ,cACA,cACA,iBAKIC,EAAmB,SAASzJ,GAChCnF,KAAKsK,YAAYnF,GACjBnF,KAAKqJ,aAAalE,EAASwJ,GAC3B3O,KAAK6O,IAAM9O,EAAEqG,SAASpG,KAAK8O,WAC3B9O,KAAKqO,aACLrO,KAAK+O,WAAWtN,MAAMzB,KAAMmB,WAG9ByN,GAAiB5G,OAASA,EAM1BjI,EAAEiI,OAAO4G,EAAiBf,UAAW/N,EAASgO,OAAQzD,EAAa+D,GACjEU,UAAW,MAGX9H,cAAc,EAEdgI,YAN6E,WAO3E,MAAOhP,MAAKgH,cAId+H,WAX6E,aAa7EE,QAb6E,WAc3E,GAAIjP,KAAKgH,aAAgB,MAAOhH,KADjB,KAAA,GAAAkB,GAAAC,UAAAC,OAANC,EAAMC,MAAAJ,GAAAK,EAAA,EAAAA,EAAAL,EAAAK,IAANF,EAAME,GAAAJ,UAAAI,EASf,OANAvB,MAAKS,cAALgB,MAAAzB,MAAmB,iBAAkBA,MAArC2B,OAA8CN,IAE9CrB,KAAKgH,cAAe,EACpBhH,KAAKS,cAALgB,MAAAzB,MAAmB,UAAWA,MAA9B2B,OAAuCN,IACvCrB,KAAKgO,gBAEEhO,MAGTS,cAAeA,GChDjB,IAAMyO,GAAgB,SAASC,GAC7BnP,KAAKmP,WAAaA,EAMpBpP,GAAEiI,OAAOkH,GACPE,kBAKAC,IANsB,SAMlBF,EAAYhK,GACd,GAAImK,GAAiBtP,KAAKoP,eAAeD,EAOzC,OALKG,KACHA,EAAiB,GAAIJ,GAAcC,GACnCnP,KAAKoP,eAAeD,GAAcG,GAG7BA,EAAeC,KAAKpK,IAU7BqK,MAxBsB,WAwBP,IAAA,GACT7H,GAAA,OADSzG,EAAAC,UAAAC,OAANC,EAAMC,MAAAJ,GAAAK,EAAA,EAAAA,EAAAL,EAAAK,IAANF,EAAME,GAAAJ,UAAAI,EAEb,IAAMH,GAASC,EAAKD,MAEpB,IAAIA,EAAS,EACX,IAAKuG,EAAI,EAAGA,EAAIvG,EAAQuG,UACf3H,MAAKoP,eAAe/N,EAAKsG,QAGlC3H,MAAKoP,qBAQXrP,EAAEiI,OAAOkH,EAAcrB,WAGrB0B,KAHgC,SAG3BpK,GAEH,GAAInF,KAAKyP,iBACP,MAAOzP,MAAKyP,gBAId,IAAMC,GAAW1P,KAAK2P,aAAa3P,KAAKmP,WAAYhK,EAGpD,OAFAnF,MAAKyP,iBAAmBzP,KAAK4P,gBAAgBF,EAAUvK,GAEhDnF,KAAKyP,kBAQdE,aArBgC,SAqBnBR,EAAYhK,GACvB,GAAM0K,GAAY/P,EAASmJ,EAAEkG,EAE7B,KAAKU,EAAUzO,OACb,KAAM,IAAI+C,IACR+C,KAAM,kBACN3C,QAAA,6BAAsC4K,EAAtC,KAGJ,OAAOU,GAAUC,QAOnBF,gBArCgC,SAqChBG,EAAa5K,GAC3B,MAAOpF,GAAE2P,SAASK,EAAa5K,KxBw2BlC,IAAI6K,GyBn8BUjQ,EAAEkQ,WAAalQ,EAAEmQ,OpByChCC,GACEC,eADa,WAEX,GAAM3K,GAAY1F,EAAEkB,OAAOjB,KAAM,YAIjCA,MAAKqQ,WAAatQ,EAAEuE,SAASmB,GAAaD,EAAexF,KAAMyF,OAGjE6K,qBATa,WAUX,GAAMC,GAAWP,EAAQhQ,KAAKqQ,WAAY,cAC1C,OAAOtQ,GAAEiI,OAAFvG,MAAA1B,OAAA4B,OAAA4F,EAAAC,kBAAgB+I,MAGzBC,mBAda,WAeX,GAAMC,GAAST,EAAQhQ,KAAKqQ,WAAY,YACxC,OAAOtQ,GAAEiI,OAAFvG,MAAA1B,OAAA4B,OAAA4F,EAAAC,kBAAgBiJ,MAIzBC,6BApBa,WAqBXV,EAAQhQ,KAAKqQ,WAAY,wBAI3BM,8BAzBa,WA0BXX,EAAQhQ,KAAKqQ,WAAY,yBAI3BO,gCA9Ba,WA+BXZ,EAAQhQ,KAAKqQ,WAAY,2BAG3BQ,kBAlCa,SAkCKxP,GAKhB2O,EAAAvO,MAAA8G,QAAQvI,KAAKqQ,WAAY,WAAzB1O,OAAA4F,EAAAC,kBAAuCnG,MAGzCyP,wBA1Ca,WA2CXd,EAAQhQ,KAAKqQ,WAAY,mBAG3BU,0BA9Ca,WA+CXf,EAAQhQ,KAAKqQ,WAAY,qBAG3BW,yBAlDa,WAkDqB,IAAA,GAC1BvL,GAAYzF,KAAKqQ,WADSnP,EAAAC,UAAAC,OAANC,EAAMC,MAAAJ,GAAAK,EAAA,EAAAA,EAAAL,EAAAK,IAANF,EAAME,GAAAJ,UAAAI,EAGhC,KAAK,GAAIoG,GAAI,EAAGvG,EAASqE,GAAaA,EAAUrE,OAAQuG,EAAIvG,EAAQuG,IAClElH,EAAcgB,MAAMgE,EAAUkC,GAAItG,KqBxFxC4P,GAEEC,sBAFa,SAESC,EAAOC,GAC3BpR,KAAKqR,wBAAwBF,EAAOC,EAEpC,IAAME,GAAcvR,EAAEkB,OAAOjB,KAAM,cACnC0E,GAAW1D,KAAKhB,KAAMmR,EAAOG,EAE7B,IAAMC,GAAmBxR,EAAEkB,OAAOjB,KAAM,mBACxC0E,GAAW1D,KAAKhB,KAAMoR,EAAYG,IAGpCF,wBAZa,SAYWF,EAAOC,GAC7B,GAAME,GAAcvR,EAAEkB,OAAOjB,KAAM,cACnC2E,GAAa3D,KAAKhB,KAAMmR,EAAOG,EAE/B,IAAMC,GAAmBxR,EAAEkB,OAAOjB,KAAM,mBACxC2E,GAAa3D,KAAKhB,KAAMoR,EAAYG,KpBzBlCC,EAAwB,iBASxBC,EAAqB,SAASlR,GAClC,GAAMF,GAAQE,EAAUF,MAAMmR,EAC9B,OAAOtL,GAAW7F,EAAM,GAAIA,EAAM,KCapCqR,GAIEC,iBAJa,SAIIzP,EAAMqO,GAGrB,MAAOxQ,GAAE4J,OAAO4G,EAAU,SAACE,EAAQxK,EAAOb,GAGxC,MAFAA,GAAMqM,EAAmBrM,GACzBqL,EAAOrL,GAAOkB,EAAiBpE,EAAM+D,GAC9BwK,SoBhCPmB,GAAkB,SAASnI,EAAMoI,GACrC,MAAO9R,GAAE4J,OAAOF,EAAM,SAACqI,EAAMC,EAAK3M,GAChC,GAAM4M,GAAgBC,GAAkB7M,EAAKyM,EAE7C,OADAC,GAAKE,GAAiBD,EACfD,QAMLG,GAAoB,SAASC,EAAUL,GAC3C,MAAOK,GAAStR,QAAQ,uBAAwB,SAACuR,GAC/C,MAAON,GAAGM,EAAEvF,MAAM,OAOhBwF,GAAoB,QAApBA,IAA6B3I,EAAMoI,EAAIQ,GAe3C,MAdAtS,GAAEsC,KAAKoH,EAAM,SAACsI,EAAK3M,GACbrF,EAAE0E,SAASsN,GACbtI,EAAKrE,GAAO6M,GAAkBF,EAAKF,GAC1B9R,EAAEuE,SAASyN,IAAQhS,EAAE2H,QAAQ2K,KACtCtS,EAAEiI,OAAO+J,EAAKK,GAAkBrS,EAAEwJ,KAAKwI,EAAKM,GAAaR,IAEzD9R,EAAEsC,KAAKgQ,EAAY,SAACC,GAClB,GAAMC,GAAcR,EAAIO,EACpBvS,GAAE0E,SAAS8N,KACbR,EAAIO,GAAYL,GAAkBM,EAAaV,SAKhDpI,GAGT+I,IAIEC,gBAJa,SAIGhJ,GACd,GAAMiJ,GAAa1S,KAAK2S,gBACxB,OAAOf,IAAgBnI,EAAMiJ,IAK/BE,kBAXa,SAWKnJ,EAAM4I,GACtB,GAAMK,GAAa1S,KAAK2S,gBACxB,OAAOP,IAAkB3I,EAAMiJ,EAAYL,IAG7CM,eAhBa,WAiBX,GAAMD,GAAa3S,EAAEkB,OAAOjB,KAAM,eAC5B6R,EAAK9R,EAAEkB,OAAOjB,KAAM,KAC1B,OAAO0S,IAAcb,GAKvBgB,gBAxBa,WAwBK,GAAAnJ,GAAA1J,IAChB,IAAKA,KAAK6R,GAAV,CAIK7R,KAAK8S,cACR9S,KAAK8S,YAAc9S,KAAK6R,GAI1B,IAAMxN,GAAWtE,EAAEkB,OAAOjB,KAAM,cAGhCA,MAAK+S,OAGLhT,EAAEsC,KAAKgC,EAAU,SAAC8B,EAAUf,GAC1BsE,EAAKqJ,IAAI3N,GAAOsE,EAAKT,EAAE9C,KAGzBnG,KAAK6R,GAAK7R,KAAK+S,MAGjBC,kBA/Ca,WA+CO,GAAAC,GAAAjT,IACbA,MAAK6R,IAAO7R,KAAK8S,cAGtB/S,EAAEsC,KAAKrC,KAAK6R,GAAI,SAACqB,EAAKhM,SACb+L,GAAKpB,GAAG3K,KAIjBlH,KAAK6R,GAAK7R,KAAK8S,kBACR9S,MAAK8S,kBACL9S,MAAK+S,MAGdI,OA7Da,SA6DNjM,GACL,MAAOlH,MAAK+S,IAAI7L,KC9EdkM,IACJC,yBAAyB,EACzBvM,0BAA0B,EAE1BE,cAAc,EAEdgI,YANgB,WAOd,QAAShP,KAAKgH,cAGhB7D,aAAa,EAEbmQ,WAZgB,WAad,QAAStT,KAAKmD,aAGhBX,aAAa,EAEb+Q,WAlBgB,WAmBd,QAASvT,KAAKwC,aAMhBgR,WAzBgB,WA0Bd,GAAMC,KAAUzT,KAAKgJ,EASrB,OAPAlJ,GAAS4T,KAAK7F,UAAU2F,WAAW/R,MAAMzB,KAAMmB,WAE3CsS,IACFzT,KAAKmD,cAAgBnD,KAAKkT,IAAI9R,OAC9BpB,KAAKwC,YAAcuG,EAAe/I,KAAKgJ,KAGlChJ,MAKT2T,eAxCgB,SAwCDC,GAEb5T,KAAK0Q,+BACL1Q,KAAK6T,oBAEL,IAAMC,GAAa9T,KAAK+T,WAAWH,EAEV,oBAAdA,KACT5T,KAAKyQ,OAASqD,EAGhB,IAAME,GAAiBjU,EAAEiI,UACvBhI,KAAKwQ,qBACLsD,EACA9T,KAAKsQ,uBACLtQ,KAAKiU,cAKP,OAFAnU,GAAS4T,KAAK7F,UAAU8F,eAAe3S,KAAKhB,KAAMgU,GAE3ChU,MAGT+T,WA/DgB,SA+DLH,GACT,GAAMnD,GAASmD,GAAa5T,KAAKyQ,MAEjC,OAAI1Q,GAAEyB,WAAWiP,GACRzQ,KAAKyS,gBAAgBhC,KAGvBzQ,KAAKyS,gBAAgBhC,IAK9BwD,YA3EgB,WA4Ed,GAAKjU,KAAKuQ,SAAV,CAGA,GAAMA,GAAWvQ,KAAKyS,gBAAgB1S,EAAEkB,OAAOjB,KAAM,YAIrD,OAAOA,MAAK2R,iBAAiB3R,KAAMuQ,KAIrC2D,qBAvFgB,WA6Fd,MALAlU,MAAKkR,sBAAsBlR,KAAKmR,MAAOnR,KAAKoR,YAG5CpR,KAAK2Q,gCAEE3Q,MAITmU,uBAjGgB,WAuGd,MALAnU,MAAKqR,wBAAwBrR,KAAKmR,MAAOnR,KAAKoR,YAG9CpR,KAAK4Q,kCAEE5Q,MAIToU,oBA3GgB,WA4Gd,GAAIpU,KAAKgH,aACP,KAAM,IAAI7C,IACR+C,KAAM,qBACN3C,QAAA,eAAwBvE,KAAK6O,IAA7B,uDAMNI,QArHgB,WAsHd,GAAIjP,KAAKgH,aAAgB,MAAOhH,KADjB,KAAA,GAET0C,KAAwB1C,KAAKwC,YAFpBtB,EAAAC,UAAAC,OAANC,EAAMC,MAAAJ,GAAAK,EAAA,EAAAA,EAAAL,EAAAK,IAANF,EAAME,GAAAJ,UAAAI,EAgCf,OA5BAvB,MAAKS,cAALgB,MAAAzB,MAAmB,iBAAkBA,MAArC2B,OAA8CN,IAC1CqB,GACF1C,KAAKS,cAAc,gBAAiBT,MAItCA,KAAKqU,mBAILrU,KAAKsU,iBAED5R,IACF1C,KAAKwC,aAAc,EACnBxC,KAAKS,cAAc,SAAUT,OAI/BA,KAAKuU,kBAELvU,KAAK6Q,kBAAkBxP,GAEvBrB,KAAKgH,cAAe,EACpBhH,KAAKmD,aAAc,EACnBnD,KAAKS,cAALgB,MAAAzB,MAAmB,UAAWA,MAA9B2B,OAAuCN,IAEvCrB,KAAKgO,gBAEEhO,MAGTwU,eAxJgB,WA4Jd,MAHAxU,MAAK6S,kBACL7S,KAAK8Q,0BAEE9Q,MAITqU,iBAhKgB,WAoKd,MAHArU,MAAKgT,oBACLhT,KAAK+Q,4BAEE/Q,MAGTyU,MAvKgB,SAuKVvN,GAEJ,MADAlH,MAAKoU,sBACEpU,KAAKmT,OAAOjM,IAKrBwN,qBAAsB,YAItBjU,cAlLgB,WAkLO,IAAA,GAAAsB,GAAAZ,UAAAC,OAANC,EAAMC,MAAAS,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAANX,EAAMW,GAAAb,UAAAa,EACrB,IAAM2S,GAAMC,EAAcnT,MAAMzB,KAAMqB,EAKtC,OAHArB,MAAKgR,yBAALvP,MAAAzB,KAAiCqB,GACjCrB,KAAK6U,4BAALpT,MAAAzB,KAAoCqB,GAE7BsT,GAITd,mBA5LgB,WA6Ld7T,KAAK8U,iBAAmB/U,EAAEkB,OAAOjB,KAAM,mBACvCA,KAAK+U,mBAAqBhV,EAAEkB,OAAOjB,KAAM,sBAG3C6U,4BAjMgB,SAiMYtU,GAC1B,GAAMyU,GAAahV,KAAKiV,aACxB,IAAKD,EAAL,CAF8C,IAAA,GAOxCE,GAAcnV,EAAEkB,OAAO+T,EAAY,wBACnCG,EAAoBD,EAAc,IAAM3U,EARA6U,EAAAjU,UAAAC,OAANC,EAAMC,MAAA8T,EAAA,EAAAA,EAAA,EAAA,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAANhU,EAAMgU,EAAA,GAAAlU,UAAAkU,EAU9CL,GAAWvU,cAAXgB,MAAAuT,GAAyBG,GAAzBxT,OAA+CN,GAG/C,IAAMiU,GAAkBN,EAAWjQ,iBAAiBiQ,EAAWF,iBAEzDQ,IAAmBvV,EAAEyB,WAAW8T,EAAgB/U,KACpD+U,EAAgB/U,GAAWkB,MAAMuT,EAAY3T,EAI/C,IAAMkU,GAAoBP,EAAWD,kBAGjCQ,IAAqBxV,EAAE0E,SAAS8Q,EAAkBhV,KACpDyU,EAAWvU,cAAXgB,MAAAuT,GAAyBO,EAAkBhV,IAA3CoB,OAA0DN,MAM9D4T,YA/NgB,WAkOd,IAFA,GAAIO,GAASxV,KAAKyV,QAEXD,GAAQ,CACb,GAAIA,YAAkB9B,IACpB,MAAO8B,EAETA,GAASA,EAAOC,UAKtB1V,GAAEiI,OAAOoL,GAAWjD,EAAgB9F,EAAa4G,EAA2BS,EAAgBc,GCzP5F,IAAM7D,KACJ,iBACA,WACA,kBAGI+G,GAAS9G,EAAiB5G,QAC9B8G,UAAW,MACX6G,gBAAgB,EAChBC,aAAa,EAEb5L,YALqC,SAKzB7E,GAWV,GAVAnF,KAAKsK,YAAYnF,GAEjBnF,KAAKqJ,aAAalE,EAASwJ,IAG3B3O,KAAK6V,QAAU7V,KAAKgJ,GAAKhJ,KAAKe,UAAU,MAGxCf,KAAKgJ,GAAKhJ,KAAKgJ,aAAclJ,GAASmJ,EAAIjJ,KAAKgJ,GAAG,GAAKhJ,KAAKgJ,IAEvDhJ,KAAKgJ,GACR,KAAM,IAAI7E,IACR+C,KAAM,YACN3C,QAAS,2CAIbvE,MAAKkT,IAAMlT,KAAK8V,MAAM9V,KAAKgJ,IAC3B4F,EAAiB5N,KAAKhB,KAAMmF,IAM9B4Q,KA9BqC,SA8BhC7T,EAAMiD,GACT,GAAKnF,KAAKgW,eAAe7Q,GAIzB,MADAnF,MAAKiW,YAAY/T,GACbA,IAASlC,KAAKkW,YAAsBlW,MAExCA,KAAKS,cAAc,cAAeT,KAAMkC,EAAMiD,GAE9CvC,EAAkBV,GAElBlC,KAAKmW,MAAMhR,GAKXjD,EAAKmB,GAAG,UAAWrD,KAAKmW,MAAOnW,MAK/BkC,EAAKuT,QAAUzV,KAEfA,KAAKoW,YAAYlU,GAEjBlC,KAAKqW,YAAYnU,EAAMiD,GAEvBnF,KAAKS,cAAc,OAAQT,KAAMkC,EAAMiD,GAChCnF,OAGToW,YA7DqC,SA6DzBlU,GACNA,EAAKiB,cAIJjB,EAAKmR,yBACRzR,EAAgBM,EAAM,gBAAiBA,GAGzCA,EAAKwB,SAEAxB,EAAKmR,0BACRnR,EAAKiB,aAAc,EACnBvB,EAAgBM,EAAM,SAAUA,MAIpCmU,YA9EqC,SA8EzBnU,GAAoB,GAAdiD,GAAchE,UAAAC,QAAA,GAAAmH,SAAApH,UAAA,MAAAA,UAAA,GACxBoB,GAAuBL,EAAKM,aAAeuG,EAAe/I,KAAKgJ,IAC/DsN,EAAoD,mBAA3BnR,GAAQwQ,iBAAmC5V,EAAEkB,OAAOjB,KAAM,oBAAsBmF,EAAQwQ,cAEnHpT,IACFX,EAAgBM,EAAM,gBAAiBA,GAGzClC,KAAKuW,WAAWrU,EAAMoU,GAElB/T,IACFL,EAAKM,aAAc,EACnBZ,EAAgBM,EAAM,SAAUA,IAGlClC,KAAKkW,YAAchU,GAGrB8T,eAhGqC,WAgGR,GAAd7Q,GAAchE,UAAAC,QAAA,GAAAmH,SAAApH,UAAA,MAAAA,UAAA,EAM3B,IALKpB,EAAEuE,SAAStE,KAAKgJ,MACnBhJ,KAAKkT,IAAMlT,KAAK8V,MAAM9V,KAAKgJ,IAC3BhJ,KAAKgJ,GAAKhJ,KAAKkT,IAAI,KAGhBlT,KAAKkT,KAA2B,IAApBlT,KAAKkT,IAAI9R,OAAc,CACtC,GAAMoV,GAAmD,mBAA3BrR,GAAQqR,iBAAmCzW,EAAEkB,OAAOjB,KAAM,oBAAsBmF,EAAQqR,cAEtH,IAAIA,EACF,OAAO,CAEP,MAAM,IAAIrS,GAAJ,6CAAiEnE,KAAK6O,KAGhF,OAAO,GAGToH,YAlHqC,SAkHzB/T,GACV,IAAKA,EACH,KAAM,IAAIiC,IACR+C,KAAM,eACN3C,QAAS,8FAIb,IAAIrC,EAAK8E,aACP,KAAM,IAAI7C,IACR+C,KAAM,qBACN3C,QAAA,eAAwBrC,EAAK2M,IAA7B,uDAONiH,MApIqC,SAoI/B9M,GACJ,MAAOlJ,GAASmJ,EAAED,EAAIjJ,EAAEkB,OAAOjB,KAAM,cAGvCyW,WAxIqC,SAwI1BvU,GAETlC,KAAK0W,YAEL,IAAMlB,GAASxV,KAAKgJ,GAAG2N,UAEvBnB,GAAOoB,aAAa1U,EAAK8G,GAAIhJ,KAAKgJ,IAClChJ,KAAK4V,aAAc,GAIrBc,WAnJqC,WAoJnC,GAAK1W,KAAKkW,YAAV,CAIA,GAAMhU,GAAOlC,KAAKkW,YACZV,EAAStT,EAAK8G,GAAG2N,UAElBnB,KAILA,EAAOoB,aAAa5W,KAAKgJ,GAAI9G,EAAK8G,IAClChJ,KAAK4V,aAAc,KAGrBiB,WAnKqC,WAoKnC,QAAS7W,KAAK4V,aAKhBW,WAzKqC,SAyK1BrU,EAAM4U,GACXA,EAEF9W,KAAKyW,WAAWvU,GAEhBlC,KAAKgJ,GAAG+N,YAAY7U,EAAK8G,KAM7BmN,MApLqC,WAoLK,GAApChR,GAAoChE,UAAAC,QAAA,GAAAmH,SAAApH,UAAA,IAAxBqV,gBAAgB,GAAQrV,UAAA,GAClCe,EAAOlC,KAAKkW,WAGlB,OAAKhU,IAOLA,EAAK8K,IAAI,UAAWhN,KAAKmW,MAAOnW,MAChCA,KAAKS,cAAc,eAAgBT,KAAMkC,GAErClC,KAAK4V,aACP5V,KAAK0W,mBAGA1W,MAAKkW,YAEPhU,EAAK8E,eACRhH,KAAKgX,YAAY9U,EAAMiD,SAChBjD,GAAKuT,SAGdzV,KAAKS,cAAc,QAAST,KAAMkC,GAC3BlC,OArBDA,KAAKgW,eAAe7Q,IACtBnF,KAAKiX,aAEAjX,OAqBXgX,YAjNqC,SAiNzB9U,GAA6B,GAAAgV,GAAA/V,UAAAC,QAAA,GAAAmH,SAAApH,UAAA,MAAAA,UAAA,GAAtBgW,EAAsBD,EAAtBC,eACXC,IAAyBD,CAE/B,OAAIC,OACFpX,MAAKqX,YAAYnV,QAIfA,EAAK+M,QACP/M,EAAK+M,UAELpI,EAAoB3E,KAIxBmV,YAhOqC,SAgOzBnV,GACV,GAAMQ,KAAwBR,EAAKM,WAC/BE,IACFd,EAAgBM,EAAM,gBAAiBA,GAGzClC,KAAKiX,aAEDvU,IACFR,EAAKM,aAAc,EACnBZ,EAAgBM,EAAM,SAAUA,KAKpC+U,WA/OqC,WAgPnCjX,KAAKkT,IAAIoE,WAAW7T,UAKtB8T,QArPqC,WAsPnC,QAASvX,KAAKkW,aAMhBnI,MA5PqC,SA4P/B5I,GAQJ,MAPAnF,MAAKmW,MAAMhR,GAEPnF,KAAKkT,MACPlT,KAAKgJ,GAAKhJ,KAAK6V,eAGV7V,MAAKkT,IACLlT,MAGTiP,QAvQqC,SAuQ7B9J,GAEN,MADAnF,MAAK+N,MAAM5I,GACJyJ,EAAiBf,UAAUoB,QAAQxN,MAAMzB,KAAMmB,cClR1DqW,IACEC,YAAa/B,GAIbgC,aALa,WAQX1X,KAAK2X,QAAW3X,KAAK2X,YACrB3X,KAAK4X,YAEL5X,KAAK6X,WAAW9X,EAAEkB,OAAOjB,KAAM,aAKjC8X,eAhBa,WAiBX9H,EAAQhQ,KAAK4X,SAAU,UAIzBG,UArBa,SAqBH7Q,EAAM8Q,GACd,GAAML,KAEN,OADAA,GAAQzQ,GAAQ8Q,EACThY,KAAK6X,WAAWF,GAASzQ,IAIlC2Q,WA5Ba,SA4BFF,GAET,IAAI5X,EAAEkY,QAAQN,GAWd,MALAA,GAAU3X,KAAK4S,kBAAkB+E,GAAU,WAAY,OAGvD3X,KAAK2X,QAAU5X,EAAEiI,UAAWhI,KAAK2X,QAASA,GAEnC3X,KAAKkY,YAAYP,IAI1BO,YA7Ca,SA6CDC,GAAmB,GAAAzO,GAAA1J,IAC7B,OAAOD,GAAE4J,OAAOwO,EAAmB,SAACR,EAASK,EAAY9Q,GAGvD,MAFAyQ,GAAQzQ,GAAQwC,EAAK0O,aAAaJ,GAClCtO,EAAK2O,WAAWV,EAAQzQ,GAAOA,GACxByQ,QAKXS,aAtDa,SAsDAJ,GACX,MAAIA,aAAsBtC,IACjBsC,EAGFhY,KAAKsY,2BAA2BN,IAGzCM,2BA9Da,SA8DcN,GACzB,GAAIjY,EAAE0E,SAASuT,GACb,MAAOhY,MAAKuY,wBAAwBvP,GAAIgP,GAG1C,IAAIjY,EAAEyB,WAAWwW,GACf,MAAOhY,MAAKwY,4BAA4BR,EAG1C,IAAIjY,EAAEuE,SAAS0T,GACb,MAAOhY,MAAKuY,uBAAuBP,EAGrC,MAAM,IAAI7T,IACRI,QAAS,sCACTC,IAAK,uDAIT+T,uBAjFa,SAiFUP,GACrB,GAAMS,GAAcT,EAAWP,aAAezX,KAAKyX,YAE7CtS,EAAUpF,EAAE2Y,KAAKV,EAAY,cAOnC,OALAjY,GAAE4Y,SAASxT,GACT6D,GAAIgP,EAAW7R,SACfyS,SAAU7Y,EAAE8Y,QAAQ9Y,EAAEkB,OAAQjB,KAAM,QAG/B,GAAIyY,GAAYtT,IAIzBqT,4BA/Fa,SA+FeC,GAC1B,MAAO,IAAIA,IACTG,SAAU7Y,EAAE8Y,QAAQ9Y,EAAEkB,OAAQjB,KAAM,SAIxCqY,WArGa,SAqGFS,EAAQ5R,GACjBlH,KAAKS,cAAc,oBAAqBT,KAAMkH,EAAM4R,GAEpDA,EAAOrD,QAAUzV,KAEjBA,KAAK4X,SAAS1Q,GAAQ4R,EAEtB9Y,KAAKS,cAAc,aAAcT,KAAMkH,EAAM4R,IAI/CC,aAhHa,SAgHA7R,GACX,GAAM4R,GAAS9Y,KAAK4X,SAAS1Q,EAI7B,OAFAlH,MAAKgZ,cAAcF,EAAQ5R,GAEpB4R,GAITG,cAzHa,WA0HX,GAAMtB,GAAU3X,KAAKkZ,YAIrB,OAFAnZ,GAAEsC,KAAKrC,KAAK4X,SAAU7X,EAAEsL,KAAKrL,KAAKgZ,cAAehZ,OAE1C2X,GAGTqB,cAjIa,SAiICF,EAAQ5R,GACpBlH,KAAKS,cAAc,uBAAwBT,KAAMkH,EAAM4R,GAEvDA,EAAO3C,QACP2C,EAAO9K,sBAEAhO,MAAK2X,QAAQzQ,SACblH,MAAK4X,SAAS1Q,GAErBlH,KAAKS,cAAc,gBAAiBT,KAAMkH,EAAM4R,IAKlDK,aA/Ia,WAgJX,GAAMxB,GAAU3X,KAAKkZ,YAErB,OADAlJ,GAAQ2H,EAAS,SACVA,GAMTyB,UAxJa,SAwJHlS,GACR,QAASlH,KAAKqZ,UAAUnS,IAM1BmS,UA/Ja,SA+JHnS,GACR,MAAOlH,MAAK4X,SAAS1Q,IAIvBgS,WApKa,WAqKX,MAAOnZ,GAAEuZ,MAAMtZ,KAAK4X,WAGtB2B,cAxKa,SAwKCrS,EAAMhF,GAAe,IAAA,GAC3B4W,GAAS9Y,KAAKqZ,UAAUnS,GADGhG,EAAAC,UAAAC,OAANC,EAAMC,MAAAJ,EAAA,EAAAA,EAAA,EAAA,GAAAK,EAAA,EAAAA,EAAAL,EAAAK,IAANF,EAAME,EAAA,GAAAJ,UAAAI,EAEjC,OAAOuX,GAAO/C,KAAPtU,MAAAqX,GAAY5W,GAAZP,OAAqBN,KAG9BmY,aA7Ka,SA6KAtS,GACX,MAAOlH,MAAKqZ,UAAUnS,GAAMgP,cC9K1BuD,IAMJ/V,OANe,SAMRgM,EAAUgK,GACf,IAAKhK,EACH,KAAM,IAAIvL,IACR+C,KAAM,wBACN3C,QAAS,kEAIb,IAAMoV,GAAe5Z,EAAEyB,WAAWkO,GAAYA,EAAWR,EAAcG,IAAIK,EAE3E,OAAOiK,GAAaD,KCflB/K,IACJ,YACA,uBACA,kBACA,oBACA,mBACA,SACA,cACA,cACA,UACA,WACA,kBACA,WACA,MAKI+E,GAAO5T,EAAS4T,KAAK1L,QAEzBgC,YAFgC,SAEpB7E,GACVnF,KAAK0D,OAAS3D,EAAEsL,KAAKrL,KAAK0D,OAAQ1D,MAElCA,KAAKsK,YAAYnF,GAEjBnF,KAAKqJ,aAAalE,EAASwJ,IAE3B/L,EAAkB5C,MAElBA,KAAKoQ,iBACLpQ,KAAK0X,cAEL,IAAMrW,GAAOC,MAAMuM,UAAUjB,MAAM5L,KAAKG,UACxCE,GAAK,GAAKrB,KAAKmF,QACfrF,EAAS4T,KAAK7F,UAAU7D,YAAYvI,MAAMzB,KAAMqB,GAEhDrB,KAAKkU,wBAKP0F,cAvBgC,WAwB9B,MAAK5Z,MAAKmR,OAAUnR,KAAKoR,WAKrBpR,KAAKmR,MACAnR,KAAK6Z,kBAMZC,MAAO9Z,KAAK+Z,2BAQhBF,eA5CgC,WA6C9B,MAAK7Z,MAAKmR,MACHpR,EAAEuZ,MAAMtZ,KAAKmR,MAAM6I,gBAK5BD,oBAnDgC,WAoD9B,MAAK/Z,MAAKoR,WACHpR,KAAKoR,WAAWzL,IAAI,SAASwL,GAAS,MAAOpR,GAAEuZ,MAAMnI,EAAM6I,kBAUpEtW,OA/DgC,WAgF9B,MAhBA1D,MAAKoU,sBAELpU,KAAKS,cAAc,gBAAiBT,MAIhCA,KAAKmD,aACPnD,KAAK8X,iBAGP9X,KAAKia,kBACLja,KAAKwU,iBAELxU,KAAKmD,aAAc,EACnBnD,KAAKS,cAAc,SAAUT,MAEtBA,MAKTia,gBArFgC,WAsF9B,GAAMvK,GAAW1P,KAAKka,aAGtB,IAAIxK,KAAa,EAAjB,CAKA,GAAMgK,GAAO1Z,KAAKma,qBAAqBna,KAAK4Z,iBAGtC9J,EAAO2J,GAAS/V,OAAOgM,EAAUgK,EAAM1Z,KAC7CA,MAAKoa,gBAAgBtK,KAOvBoK,YAzGgC,WA0G9B,MAAOla,MAAK0P,UAQdyK,qBAlHgC,WAkHE,GAAbvW,GAAazC,UAAAC,QAAA,GAAAmH,SAAApH,UAAA,MAAAA,UAAA,GAC1BkZ,EAAkBta,EAAEkB,OAAOjB,KAAM,kBACvC,OAAOD,GAAEiI,OAAOpE,EAAQyW,IAe1BD,gBAnIgC,SAmIhBtK,GAGd,MAFA9P,MAAKkT,IAAIpD,KAAKA,GAEP9P,MAITuU,gBA1IgC,WA2I9BvU,KAAKiZ,iBAGP7W,sBA9IgC,WA+I9B,MAAOrC,GAAE2F,MAAM1F,KAAKkZ,cACjBvT,IAAI,eACJ2U,UACArU,UAIPlG,GAAEiI,OAAO0L,GAAK7F,UAAWuF,GAAWoE,GhC+/DnC,IAAI+C,IAAsBta,EAAW,SAAUR,EAAQD,EAASF;;;;;CiCxqEhE,SAASkb,EAAMjb,GAEd,GAAsB,kBAAXI,SAAyBA,OAAOC,IACzCD,QAAQ,WAAY,cAAe,SAASG,EAAUC,GACpD,MAAOR,GAAQO,EAAUC,SAEtB,IAAuB,mBAAZP,GAAyB,CACzC,GAAIM,GAAW0K,EACXzK,EAAI0K,CACRhL,GAAOD,QAAUD,EAAQO,EAAUC,OAEnCR,GAAQib,EAAK1a,SAAU0a,EAAKza,IAG9BC,EAAM,SAASF,EAAUC,GAGzB,GAAI0a,GAA6B3a,EAAS4a,kBA8K1C,OAtKA5a,GAAS4a,mBAAqB,SAAW5a,EAAUC,GAKjD,GAAI4a,GAAY,SAASC,GACvB5a,KAAK6a,UACL7a,KAAK8a,iBACL9a,KAAK+a,kBACL/a,KAAKgb,gBAELjb,EAAEsC,KAAKuY,EAAO7a,EAAEsL,KAAKrL,KAAKib,IAAKjb,OAMjCD,GAAEiI,OAAO2S,EAAU9M,WAMjBoN,IAAK,SAAS/Y,EAAMgZ,GAClB,MAAOlb,MAAKmb,KAAKjZ,EAAMgZ,GACXF,iBAKdI,YAAa,SAASjK,GACpB,MAAOnR,MAAKqb,eAAelK,EAAMtC,MAMnCwM,eAAgB,SAASC,GACvB,GAAIC,GAAUvb,KAAK8a,cAAcQ,EACjC,OAAOtb,MAAKwb,UAAUD,IAIxBE,aAAc,SAASC,GACrB,GAAIH,GAAUvb,KAAK+a,eAAeW,EAClC,OAAO1b,MAAKwb,UAAUD,IAKxBI,YAAa,SAASD,GACpB,MAAO3b,GAAE6b,OAAO5b,KAAK6a,QAAQa,IAI/BF,UAAW,SAAS3M,GAClB,MAAO7O,MAAK6a,OAAOhM,IAIrB9H,OAAQ,SAAS7E,GACf,MAAOlC,MAAK6b,QAAQ3Z,GACR8Y,iBAMdha,KAAM,SAASF,GACbd,KAAKyB,MAAMX,EAAQf,EAAE4M,QAAQxL,WAAWyL,MAAM,KAMhDnL,MAAO,SAASX,EAAQO,GACtBtB,EAAEsC,KAAKrC,KAAK6a,OAAQ,SAAS3Y,GACvBnC,EAAEyB,WAAWU,EAAKpB,KACpBoB,EAAKpB,GAAQW,MAAMS,EAAMb,UAM/B2Z,cAAe,WAGb,MAFAhb,MAAKoB,OAASrB,EAAE+b,KAAK9b,KAAK6a,QAEnB7a,MAKTmb,KAAM,SAASjZ,EAAMgZ,GACnB,GAAIK,GAAUrZ,EAAK2M,GAenB,OAZA7O,MAAK6a,OAAOU,GAAWrZ,EAGnBA,EAAKiP,QACPnR,KAAK8a,cAAc5Y,EAAKiP,MAAMtC,KAAO0M,GAInCL,IACFlb,KAAK+a,eAAeG,GAAeK,GAG9Bvb,MAKT6b,QAAS,SAAU3Z,GACjB,GAAIqZ,GAAUrZ,EAAK2M,GAkBnB,OAfI3M,GAAKiP,aACAnR,MAAK8a,cAAc5Y,EAAKiP,MAAMtC,KAIvC9O,EAAEgc,KAAK/b,KAAK+a,eAAgBhb,EAAEsL,KAAK,SAASwD,EAAKzJ,GAC/C,GAAIyJ,IAAQ0M,EAEV,aADOvb,MAAK+a,eAAe3V,IACpB,GAERpF,aAGIA,MAAK6a,OAAOU,GAEZvb,OASX,IAAI+D,IAAW,UAAW,OAAQ,MAAO,OAAQ,SAAU,SACzD,SAAU,SAAU,QAAS,MAAO,OAAQ,MAAO,UACnD,WAAY,SAAU,UAAW,QAAS,UAAW,OACrD,OAAQ,UAAW,UAAW,QAAS,SAWzC,OATAhE,GAAEsC,KAAK0B,EAAS,SAASjD,GACvB6Z,EAAU9M,UAAU/M,GAAU,WAC5B,GAAI8Z,GAAQ7a,EAAE6b,OAAO5b,KAAK6a,QACtBxZ,GAAQuZ,GAAOjZ,OAAO5B,EAAE4M,QAAQxL,WACpC,OAAOpB,GAAEe,GAAQW,MAAM1B,EAAGsB,MAKvBsZ,GACN7a,EAAUC,GAGbD,EAAS4a,mBAAmB/O,QAAU,cAEtC7L,EAAS4a,mBAAmB9O,WAAa,WAEvC,MADA9L,GAAS4a,mBAAqBD,EACvBza,MAGFF,EAAS4a,uBjCurEbA,GAAsBH,IAAsD,gBAAxBA,KAAoC,WAAaA,IAAsBA,GAAoB,WAAaA,GkCn3E3J5L,IACJ,YACA,YACA,uBACA,kBACA,mBACA,oBACA,mBACA,SACA,SACA,YACA,mBACA,cACA,gBACA,OACA,WACA,KACA,kBAKIqN,GAAiBlc,EAAS4T,KAAK1L,QAGnCiU,MAAM,EASNjS,YAZ0C,SAY9B7E,GACVnF,KAAK0D,OAAS3D,EAAEsL,KAAKrL,KAAK0D,OAAQ1D,MAElCA,KAAKsK,YAAYnF,GAEjBnF,KAAKqJ,aAAalE,EAASwJ,IAE3B/L,EAAkB5C,MAElBA,KAAKoQ,iBACLpQ,KAAKyN,KAAK,SAAUzN,KAAKkc,gBACzBlc,KAAKmc,wBACLnc,KAAKoc,oBAEL,IAAM/a,GAAOC,MAAMuM,UAAUjB,MAAM5L,KAAKG,UACxCE,GAAK,GAAKrB,KAAKmF,QACfrF,EAAS4T,KAAK7F,UAAU7D,YAAYvI,MAAMzB,KAAMqB,GAEhDrB,KAAKkU,wBAKPmI,gBAnC0C,WAoCxCrc,KAAKsc,cAAe,GAGtBC,cAvC0C,WAwCxC,GAAMha,KAAwBvC,KAAKwC,YAC7Bga,EAAoBja,EAAsBvC,KAAKoC,0BAErDpC,MAAKsc,cAAe,EAEpBvc,EAAEsC,KAAKma,EAAmB,SAAAla,GACxBV,EAAgBU,EAAO,gBAAiBA,KAG1CtC,KAAKyc,aAAazc,KAAMA,KAAK0c,iBAE7B3c,EAAEsC,KAAKma,EAAmB,SAAAla,GACxBA,EAAME,aAAc,EACpBZ,EAAgBU,EAAO,SAAUA,KAGnCtC,KAAKoc,sBAGPha,sBA3D0C,WA4DxC,MAAOrC,GAAE6b,OAAO5b,KAAK2c,SAAS9B,SAIhCqB,eAhE0C,WAiEpClc,KAAKoR,aACPpR,KAAK4c,SAAS5c,KAAKoR,WAAY,MAAOpR,KAAK6c,kBAC3C7c,KAAK4c,SAAS5c,KAAKoR,WAAY,SAAUpR,KAAK8c,qBAC9C9c,KAAK4c,SAAS5c,KAAKoR,WAAY,QAASpR,KAAK0D,QAEzC1D,KAAKic,MACPjc,KAAK4c,SAAS5c,KAAKoR,WAAY,OAAQpR,KAAK+c,cAMlDF,iBA7E0C,SA6EzBva,EAAO8O,EAAY4L,GAElC,GAAItB,GAAoBnT,SAAZyU,EAAKC,KAAqBD,EAAKtB,OAAStK,EAAW8L,QAAQ5a,GAOvE,KAJItC,KAAKmd,QAAUzB,KAAU,KAC3BA,EAAQ3b,EAAEmd,QAAQld,KAAKod,sBAAsB1B,GAAQpZ,IAGnDtC,KAAKqd,gBAAgB/a,EAAOoZ,GAAQ,CACtC1b,KAAKsd,mBACL,IAAMC,GAAYvd,KAAKwd,cAAclb,EACrCtC,MAAKyd,UAAUnb,EAAOib,EAAW7B,KAKrCoB,oBA9F0C,SA8FtB1L,EAAYjM,GAC9B,GAAMuY,GAAUvY,EAAQwY,QAAQD,QAC1BE,EAAa7d,EAAE2H,QAAQgW,IAAYA,EAAQtc,MAE7Cwc,IACF5d,KAAK6d,kBAAkBH,IAU3BG,kBA7G0C,SA6GxBC,GAAkC,GAAApU,GAAA1J,KAAAkX,EAAA/V,UAAAC,QAAA,GAAAmH,SAAApH,UAAA,MAAAA,UAAA,GAAlB4c,EAAkB7G,EAAlB6G,UAChC,KAAKD,EAAc1c,OACjB,MAAO0c,EAGT,IAAME,GAAmBD,KAAe,EAIlCE,EAAele,EAAE4J,OAAOmU,EAAe,SAACI,EAAeC,GAC3D,GAAIjc,GAAOic,CAMX,OAJIA,aAAuBre,GAASmI,QAClC/F,EAAOwH,EAAKiT,SAASvB,YAAY+C,KAG9Bjc,GAAQA,EAAK8E,aACTkX,KAGJA,EAAc9c,QAAU8c,EAAc,GAAGE,OAASlc,EAAKkc,SAC1DF,EAAcG,QAAQnc,GAGxBwH,EAAKjJ,cAAc,sBAAnBiJ,EAAgDxH,GAGhDwH,EAAKiT,SAASd,QAAQ3Z,GAClBA,EAAK+M,QACP/M,EAAK+M,UAELpI,EAAoB3E,GAGtBA,EAAKuT,QAAU,OACf/L,EAAKsE,cAAc9L,GACnBwH,EAAKjJ,cAAc,eAAnBiJ,EAAyCxH,GAElCgc,OAGT,OAAKD,GAAa7c,QAIlBpB,KAAK2c,SAAS3B,gBAEdhb,KAAKse,eAAeL,EAAa,IAAI,GAEjCD,GACFhe,KAAKue,cAGAN,GAXEA,GAgBXva,OAvK0C,WA6KxC,MALA1D,MAAKoU,sBACLpU,KAAKS,cAAc,gBAAiBT,MACpCA,KAAKwe,kBACLxe,KAAKmD,aAAc,EACnBnD,KAAKS,cAAc,SAAUT,MACtBA,MAKTye,UAlL0C,SAkLhCtB,GAA8B,GAAAuB,GAAAvd,UAAAC,QAAA,GAAAmH,SAAApH,UAAA,MAAAA,UAAA,GAArBwd,EAAqBD,EAArBC,cACXC,EAAgB5e,KAAKmD,cAAgBnD,KAAKgH,aAC1C6X,EAAgB7e,KAAKmd,SAAWA,EAChC2B,EAAeF,GAAiBC,IAAkBF,CAExD,IAAIG,EAAc,CAChB,GAAMC,GAAiB/e,KAAKod,uBAC5Bpd,MAAKmd,OAASA,CACd,IAAM6B,GAAShf,KAAKod,uBACpBpd,MAAKif,kBAAkBD,EAAQD,OAE/B/e,MAAKmd,OAASA,CAEhB,OAAOnd,OAITkf,aAnM0C,SAmM7B/Z,GAEX,MADAnF,MAAKye,UAAU,KAAMtZ,GACdnF,MAITif,kBAzM0C,SAyMxBD,EAAQD,GAAgB,GAAA9L,GAAAjT,KAClCmf,IACNpf,GAAEsC,KAAK2c,EAAQ,SAAC7N,EAAOuK,GACrB,GAAM0D,IAAuBnM,EAAK0J,SAASvB,YAAYjK,EACnDiO,IACFnM,EAAK4J,iBAAiB1L,EAAO8B,EAAK7B,YAAa6L,GAAIvB,IAErDyD,EAAWhO,EAAMtC,MAAO,GAG1B,IAAMwQ,GAActf,EAAEod,OAAO4B,EAAgB,SAACO,GAC5C,OAAQH,EAAWG,EAAUzQ,MAAQoE,EAAK0J,SAASvB,YAAYkE,IAGjEtf,MAAK6d,kBAAkBwB,IAMzBE,QA7N0C,WA6NhC,GAAAC,GAAAxf,KACF2c,EAAW3c,KAAK2c,SAChBqC,EAAShf,KAAKod,uBAEpB,KAAK4B,EAAO5d,QAAUpB,KAAKyf,kBAAqB,MAAOzf,KAEvD,IAAM0f,GAAiB3f,EAAEgc,KAAKiD,EAAQ,SAAS7N,GAC7C,OAAQwL,EAASvB,YAAYjK,IA+B/B,OA1BIuO,GACF1f,KAAK0D,UACA,WAEL,GAAMic,GAAe5f,EAAE4F,IAAIqZ,EAAQ,SAAS7N,EAAOuK,GACjD,GAAMxZ,GAAOya,EAASvB,YAAYjK,EAElC,OADAjP,GAAKkc,OAAS1C,EACPxZ,EAAK8G,KAIR4W,EAAmBjD,EAASQ,OAAO,SAASjb,GAChD,OAAQnC,EAAEmJ,SAASyW,EAAczd,EAAK8G,KAGxCwW,GAAK/e,cAAc,iBAAnB+e,GAIAA,EAAKK,yBAAyBF,GAG9BH,EAAK3B,kBAAkB+B,GAEvBJ,EAAK/e,cAAc,UAAnB+e,MAEKxf,MAKT8f,WAxQ0C,WA8QxC,MALI9f,MAAK+f,cACP/f,KAAKuf,UAELvf,KAAKwe,kBAEAxe,MAKT+c,WAnR0C,WAmR7B,GAAAiD,GAAAhgB,KACLgf,EAAShf,KAAKod,wBAGd6C,EAAelgB,EAAEmgB,KAAKlB,EAAQ,SAACmB,EAAMzE,GACzC,GAAMxZ,GAAO8d,EAAKrD,SAASvB,YAAY+E,EACvC,QAAQje,GAAQA,EAAKkc,SAAW1C,GAG9BuE,IACFjgB,KAAK8f,cAKTM,mBAIAP,yBAtS0C,SAsSjBlD,GACvB3c,KAAKkT,IAAImN,OAAO1D,IAKlB6B,gBA5S0C,WA6SpCxe,KAAKmD,cACPnD,KAAKsd,oBACLtd,KAAKsgB,kBAAkBvC,YAAY,IAGrC,IAAMiB,GAAShf,KAAKod,uBAChBpd,MAAKiY,SAASsI,gBAAiBvB,IACjChf,KAAKwgB,kBAELxgB,KAAKS,cAAc,yBAA0BT,MAC7CA,KAAKqc,kBACLrc,KAAKygB,gBAAgBzB,GACrBhf,KAAKuc,gBACLvc,KAAKS,cAAc,kBAAmBT,QAK1CygB,gBA/T0C,SA+T1BzB,GAAQ,GAAA0B,GAAA1gB,IACtBD,GAAEsC,KAAK2c,EAAQ,SAAC1c,EAAOoZ,GACrB,GAAM6B,GAAYmD,EAAKlD,cAAclb,EACrCoe,GAAKjD,UAAUnb,EAAOib,EAAW7B,MAKrC0B,sBAvU0C,SAuUpBuD,GACpB,IAAK3gB,KAAKoR,WAAc,QAExB,IAAMwP,GAAiB5gB,KAAK6gB,oBACxB7B,EAAShf,KAAKoR,WAAW4N,MAG7B,IAFA2B,EAAUG,KAAKC,IAAID,KAAKE,IAAIL,EAAS,GAAI3B,EAAO5d,OAAS,GAErDwf,EAAgB,CAClB,GAAIK,GAAA,MAEAN,KACFM,EAAajC,EAAO2B,GACpB3B,EAASA,EAAOpS,MAAM,EAAG+T,GAAShf,OAAOqd,EAAOpS,MAAM+T,EAAU,KAElE3B,EAAShf,KAAKkhB,cAAclC,EAAQ4B,GAChCK,GACFjC,EAAOmC,OAAOR,EAAS,EAAGM,GAO9B,MAFAjC,GAAShf,KAAKohB,cAAcpC,IAK9B6B,kBAjW0C,WAkWxC,MAAO7gB,MAAK4gB,gBAIdQ,cAtW0C,SAsW5BpC,GAAQ,GAAAqC,GAAArhB,IAMpB,OALIA,MAAKmd,SACP6B,EAASjf,EAAEod,OAAO6B,EAAQ,SAAC7N,EAAOuK,GAChC,MAAO2F,GAAKhE,gBAAgBlM,EAAOuK,MAGhCsD,GAGTkC,cA/W0C,SA+W5BlC,EAAQsC,GACpB,MAA0B,gBAAfA,GACFvhB,EAAEwhB,OAAOvC,EAAQ,SAAC7N,GACvB,MAAOA,GAAM9B,IAAIiS,KAEY,IAAtBA,EAAWlgB,OACbrB,EAAEwhB,OAAOvC,EAAQjf,EAAEsL,KAAKiW,EAAYthB,OAEpCgf,EAAO/C,KAAKlc,EAAEsL,KAAKiW,EAAYthB,QAM1CwgB,eA7X0C,WA8XxC,GAAMgB,GAAYxhB,KAAKyhB,eAEvB,IAAID,IAAcxhB,KAAKyf,kBAAmB,CACxCzf,KAAKyf,mBAAoB,CAEzB,IAAMtO,GAAQ,GAAIrR,GAASmI,MACvByZ,EACF1hB,KAAK0hB,kBAAoB1hB,KAAK2hB,gBAC5B5hB,GAAEyB,WAAWkgB,KACfA,EAAmBA,EAAiB1gB,KAAKhB,KAAMmR,EAAOnR,KAAKogB,iBAG7D,IAAMle,GAAOlC,KAAK4hB,eAAezQ,EAAOqQ,EAAWE,EAEnD1hB,MAAKS,cAAc,sBAAuBT,KAAMkC,GAChDlC,KAAK6hB,cAAc3f,EAAM,GACzBlC,KAAKS,cAAc,eAAgBT,KAAMkC,GAEzCA,EAAKuT,QAAUzV,OAMnBsd,kBAtZ0C,WAuZpCtd,KAAKyf,oBACPzf,KAAKS,cAAc,sBAAuBT,MAE1CA,KAAKsgB,yBACEtgB,MAAKyf,kBAEZzf,KAAKS,cAAc,eAAgBT,QAKvCyhB,cAla0C,WAmaxC,GAAMK,GAAY9hB,KAAK8hB,SAEvB,IAAKA,EAEL,MAAO9hB,MAAK+hB,SAASD,IAOvBtE,cA9a0C,SA8a5Blb,GACZ,GAAI0f,GAAYhiB,KAAKgiB,SAErB,KAAKA,EACH,KAAM,IAAI7d,IACR+C,KAAM,mBACN3C,QAAS,mCAMb,IAFAyd,EAAYhiB,KAAK+hB,SAASC,EAAW1f,IAEhC0f,EACH,KAAM,IAAI7d,IACR+C,KAAM,wBACN3C,QAAS,4EAIb,OAAOyd,IAKTD,SAtc0C,SAscjC7f,EAAMI,GACb,MAAIJ,GAAK2L,oBAAqB/N,GAAS4T,MAAQxR,IAASpC,EAAS4T,KACxDxR,EACEnC,EAAEyB,WAAWU,GACfA,EAAKlB,KAAKhB,KAAMsC,GADlB,QAMTmb,UA/c0C,SA+chCnb,EAAOib,EAAW7B,GAC1B,GAAMiG,GAAmB3hB,KAAKiiB,qBAAqB3f,EAAOoZ,GAEpDxZ,EAAOlC,KAAK4hB,eAAetf,EAAOib,EAAWoE,EAInD,OAFA3hB,MAAKkiB,aAAahgB,EAAMwZ,GAEjBxZ,GAGT+f,qBAzd0C,SAydrB3f,EAAOoZ,GAC1B,MAAI3b,GAAEyB,WAAWxB,KAAK2hB,kBACb3hB,KAAK2hB,iBAAiBrf,EAAOoZ,GAG/B1b,KAAK2hB,kBAMdO,aApe0C,SAoe7BhgB,EAAMwZ,GAYjB,MAXA1b,MAAKS,cAAc,mBAAoBT,KAAMkC,GAG7ClC,KAAKse,eAAepc,GAAM,EAAMwZ,GAEhCxZ,EAAKuT,QAAUzV,KAEfA,KAAK6hB,cAAc3f,EAAMwZ,GAEzB1b,KAAKS,cAAc,YAAaT,KAAMkC,GAE/BA,GAKToc,eArf0C,SAqf3Bpc,EAAMigB,EAAWzG,GAC9B,MAAK1b,MAAKic,MAINkG,IAEFjgB,EAAKkc,OAAS1C,GAIhB1b,KAAK2c,SAASta,KAAK,SAAC+f,GACdA,EAAUhE,QAAUlc,EAAKkc,SAC3BgE,EAAUhE,QAAU+D,EAAY,QAI7BniB,MAfEA,MAmBX6hB,cA1gB0C,SA0gB5B3f,EAAMwZ,GAGlB,GAAMnZ,IAAuBvC,KAAKsc,cAAgBtc,KAAKwC,WAEvDI,GAAkBV,GAGlBlC,KAAKqiB,kBAAkBngB,GAGvBlC,KAAK2c,SAAS1B,IAAI/Y,GAEbA,EAAKmR,yBACRzR,EAAgBM,EAAM,gBAAiBA,GAIzCA,EAAKwB,SAEAxB,EAAKmR,0BACRnR,EAAKiB,aAAc,EACnBvB,EAAgBM,EAAM,SAAUA,IAG9BK,GACFX,EAAgBM,EAAM,gBAAiBA,GAIzClC,KAAKuW,WAAWvW,KAAMkC,EAAMwZ,GAExBnZ,IACFL,EAAKM,aAAc,EACnBZ,EAAgBM,EAAM,SAAUA,KAKpC0f,eAjjB0C,SAijB3Btf,EAAOggB,EAAgBX,GACpC,GAAMxc,GAAUpF,EAAEiI,QAAQmJ,MAAO7O,GAAQqf,EACzC,OAAO,IAAIW,GAAend,IAI5B8S,QAvjB0C,SAujBlC9S,GACN,GAAI6Z,GAAA,MAOJ,OANIjf,GAAEkB,OAAOkE,EAAS,mBACpB6Z,EAAS7Z,EAAQob,iBAEjBvB,EAAShf,KAAKoR,WAAapR,KAAKoR,WAAW4N,UAC3CA,EAAShf,KAAKohB,cAAcpC,IAEL,IAAlBA,EAAO5d,QAIhBmd,YAnkB0C,WAwkBxC,MAJIve,MAAKiY,WACPjY,KAAKwgB,iBAGAxgB,MAITyc,aA5kB0C,SA4kB7B8F,EAAgBC,GAC3BD,EAAerP,IAAImN,OAAOmC,IAI5B9F,cAjlB0C,WAklBxC,GAAM+F,GAAWtZ,SAASuZ,wBAI1B,OAHA3iB,GAAEsC,KAAKrC,KAAKoc,kBAAmB,SAACuG,GAC9BF,EAAS1L,YAAY4L,EAAE3Z,MAElByZ,GAKTlM,WA3lB0C,SA2lB/BgM,EAAgBP,EAAWtG,GAChC6G,EAAejG,aAIjBiG,EAAenG,kBAAkB+E,OAAOzF,EAAO,EAAGsG,GAK7CO,EAAeK,cAAcZ,EAAWtG,IAC3C6G,EAAeM,aAAab,IAMlCY,cA5mB0C,SA4mB5BZ,EAAWtG,GACvB,GAAIxF,GAAA,OACE4M,EAAe9iB,KAAKic,MAASP,EAAQ1b,KAAK2c,SAASvb,OAAS,CAQlE,OAPI0hB,KAEF5M,EAAclW,KAAK2c,SAASuD,KAAK,SAAChe,GAChC,MAAOA,GAAKkc,SAAW1C,EAAQ,OAI/BxF,IACFA,EAAYhD,IAAI6P,OAAOf,EAAUhZ,KAC1B,IAOX6Z,aA/nB0C,SA+nB7Bb,GACXhiB,KAAKkT,IAAImN,OAAO2B,EAAUhZ,KAI5BmT,sBApoB0C,WAqoBxCnc,KAAK2c,SAAW,GAAIjC,KAItBnG,gBAzoB0C,WA0oBxCvU,KAAKsgB,kBAAkBvC,YAAY,KAIrCuC,iBA9oB0C,SA8oBzBnb,GACf,GAAM6d,GAAahjB,KAAK2c,SAAShX,IAAI5F,EAAEkjB,SAQvC,OANID,GAAW5hB,SACbpB,KAAKS,cAAc,0BAA2BT,MAC9CA,KAAK6d,kBAAkBmF,EAAY7d,GACnCnF,KAAKS,cAAc,mBAAoBT,OAGlCgjB,GAQT3F,gBA/pB0C,SA+pB1B/a,EAAOoZ,GACrB,GAAMyB,GAASnd,KAAKmd,MACpB,QAAQpd,EAAEyB,WAAW2b,IAAWA,EAAOnc,KAAKhB,KAAMsC,EAAOoZ,EAAO1b,KAAKoR,aAIvEiR,kBArqB0C,SAqqBxBngB,GAAM,GAAAghB,GAAAljB,KAChBM,EAASP,EAAEkB,OAAOjB,KAAM,uBAI9BA,MAAK4c,SAAS1a,EAAM,MAAO,SAAC3B,GAAuB,IAAA,GAAAW,GAAAC,UAAAC,OAATC,EAASC,MAAAJ,EAAA,EAAAA,EAAA,EAAA,GAAAK,EAAA,EAAAA,EAAAL,EAAAK,IAATF,EAASE,EAAA,GAAAJ,UAAAI,EAEjD,IAAM4hB,GAAiB7iB,EAAS,IAAMC,EAEhC+U,EAAkB4N,EAAKne,iBAAiBme,EAAKpO,iBAGpB,oBAApBQ,IAAmCvV,EAAEyB,WAAW8T,EAAgB/U,KACzE+U,EAAgB/U,GAAWkB,MAA3ByhB,EAAuC7hB,EAIzC,IAAMkU,GAAoB2N,EAAKnO,kBAG3BQ,IAAqBxV,EAAE0E,SAAS8Q,EAAkBhV,KACpD2iB,EAAKziB,cAALgB,MAAAyhB,GAAmB3N,EAAkBhV,IAArCoB,OAAoDN,IAGtD6hB,EAAKziB,cAALgB,MAAAyhB,GAAmBC,GAAnBxhB,OAAsCN,QAK5CtB,GAAEiI,OAAOgU,GAAenO,UAAWuF,GC3tBnC,IAAMzE,KACJ,qBACA,WACA,mBAMIyU,GAAgBpH,GAAehU,QAOnCgC,YAP0C,SAO9B7E,GACV+C,EAAU,6EAEVlI,KAAKqJ,aAAalE,EAASwJ,IAE3BqN,GAAenO,UAAU7D,YAAYvI,MAAMzB,KAAMmB,YAMnD+a,eAlB0C,WAuBpClc,KAAKoR,aACPpR,KAAK4c,SAAS5c,KAAKoR,WAAY,MAAOpR,KAAK6c,kBAC3C7c,KAAK4c,SAAS5c,KAAKoR,WAAY,SAAUpR,KAAK8c,qBAC9C9c,KAAK4c,SAAS5c,KAAKoR,WAAY,QAASpR,KAAKqjB,gBAEzCrjB,KAAKic,MACPjc,KAAK4c,SAAS5c,KAAKoR,WAAY,OAAQpR,KAAK+c,cAUlDS,cAvC0C,SAuC5Blb,GACZ,GAAI0f,GAAYhiB,KAAKgiB,SAMrB,KAAKA,EACH,MAAOhiB,MAAKgK,WAKd,IAFAgY,EAAYhiB,KAAK+hB,SAASC,EAAW1f,IAEhC0f,EACH,KAAM,IAAI7d,IACR+C,KAAM,wBACN3C,QAAS,4EAIb,OAAOyd,IAITpI,cA/D0C,WAgExC,MAAO5Z,MAAK6Z,kBAIdnW,OApE0C,WAkFxC,MAbA1D,MAAKoU,sBACLpU,KAAKsjB,cAAe,EACpBtjB,KAAKujB,0BAELvjB,KAAKS,cAAc,gBAAiBT,MAEpCA,KAAKia,kBACLja,KAAKwU,iBACLxU,KAAKqjB,iBAELrjB,KAAKsjB,cAAe,EACpBtjB,KAAKmD,aAAc,EACnBnD,KAAKS,cAAc,SAAUT,MACtBA,MAGTqjB,eArF0C,YAsFpCrjB,KAAKmD,aAAenD,KAAKsjB,eAC3BtH,GAAenO,UAAU2Q,gBAAgBxd,KAAKhB,OAKlDyc,aA5F0C,SA4F7B+G,EAAehB,GAC1B,GAAMiB,GAAazjB,KAAK0jB,sBAAsBF,EAC9CC,GAAWpD,OAAOmC,IAMpBK,aApG0C,SAoG7Bb,GACX,GAAMyB,GAAazjB,KAAK0jB,sBAAsB1jB,KAAMgiB,EACpDyB,GAAWpD,OAAO2B,EAAUhZ,KAM9B6W,yBA5G0C,SA4GjBlD,GACvB,GAAM8G,GAAazjB,KAAK0jB,sBAAsB1jB,KAC9CyjB,GAAWpD,OAAO1D,IAKpB+G,sBAnH0C,SAmHpBC,EAAe3B,GACnC,GAAM2B,EAAcC,oBAClB,MAAOD,GAAcC,mBAGvB,IAAIC,GAAA,OACEC,EAAqBH,EAAcG,kBACzC,IAAIA,EAAoB,CAEtB,GAAM3d,GAAWpG,EAAEkB,OAAO0iB,EAAe,qBAQzC,IALEE,EADyB,MAAvB1d,EAAS4d,OAAO,IAAcJ,EAAc9R,GAClC8R,EAAc9R,GAAG1L,EAAS6d,OAAO,IAEjCL,EAAc1a,EAAE9C,GAG1B0d,EAAUziB,QAAU,EACtB,KAAM,IAAI+C,IACR+C,KAAM,iCACN3C,QAAA,qDAA8Dof,EAAcG,yBAKhFD,GAAYF,EAAczQ,GAI5B,OADAyQ,GAAcC,oBAAsBC,EAC7BA,GAITN,wBApJ0C,WAqJpCvjB,KAAK4jB,sBACP5jB,KAAK4jB,oBAAsBrb,WAO3B0b,GAAgBlkB,EAAEwJ,KAAKmK,GAAK7F,UAAW,iBAAkB,cAAe,kBAAmB,uBAAwB,kBACzH9N,GAAEiI,OAAOob,GAAcvV,UAAWoW,GCjKlC,IAAMtV,KACJ,mBACA,SACA,cACA,WACA,MAGIuV,GAAWtV,EAAiB5G,QAChC8G,UAAW,MAEX9E,YAHuC,SAG3B7E,EAASjD,GAKnBlC,KAAKkC,KAAOA,EACZlC,KAAK2Y,SAAW5Y,EAAEuZ,MAAMvZ,EAAEkB,OAAOjB,KAAM,gBACvCA,KAAKsK,YAAYtK,KAAK2Y,SAAUxT,GAChCnF,KAAKqJ,aAAarJ,KAAKmF,QAASwJ,IAUhC3O,KAAK6R,GAAK9R,EAAEiI,UAAWjI,EAAEkB,OAAOjB,KAAM,MAAOD,EAAEkB,OAAOiB,EAAM,OAE5D0M,EAAiBnN,MAAMzB,KAAMmB,YAM/B8H,EA7BuC,WA8BrC,MAAOjJ,MAAKkC,KAAK+G,EAAExH,MAAMzB,KAAKkC,KAAMf,YAKtC8N,QAnCuC,WAsCrC,MAFAjP,MAAKgO,gBAEEhO,MAGTmkB,oBAzCuC,WA6CrC,MAHAnkB,MAAKkT,IAAMlT,KAAKkC,KAAKgR,IACrBlT,KAAKgJ,GAAKhJ,KAAKkC,KAAK8G,GAEbhJ,MAGTwU,eAhDuC,WAmDrC,MAFAxU,MAAK6S,kBAEE7S,MAGTqU,iBAtDuC,WAyDrC,MAFArU,MAAKgT,oBAEEhT,MAGTyU,MA5DuC,SA4DjCvN,GAEJ,MADAlH,MAAKkC,KAAKkS,sBACHpU,KAAKmT,OAAOjM,IAIrBgN,qBAlEuC,WAqErC,MAFAlU,MAAKkR,sBAAsBlR,KAAKkC,KAAKiP,MAAOnR,KAAKkC,KAAKkP,YAE/CpR,MAGTmU,uBAxEuC,WA2ErC,MAFAnU,MAAKqR,wBAAwBrR,KAAKkC,KAAKiP,MAAOnR,KAAKkC,KAAKkP,YAEjDpR,MAGTokB,UA9EuC,WAiFrC,GAAMC,GAAiBrkB,KAAKyS,gBAAgB1S,EAAEkB,OAAOjB,KAAM,UAG3D,OAAOD,GAAE4J,OAAO0a,EAAgB,SAAS5T,EAAQ6T,EAAiBlf,GAIhE,GAHKrF,EAAEyB,WAAW8iB,KAChBA,EAAkBtkB,KAAKskB,IAEpBA,EAGL,MAFAlf,GAAMqM,EAAmBrM,GACzBqL,EAAOrL,GAAOrF,EAAEsL,KAAKiZ,EAAiBtkB,MAC/ByQ,MACDzQ,OAIViU,YAhGuC,WAiGrC,GAAKjU,KAAKuQ,SAAV,CAIA,GAAMgU,GAAmBvkB,KAAKyS,gBAAgB1S,EAAEkB,OAAOjB,KAAM,YAE7D,OAAOA,MAAK2R,iBAAiB3R,KAAKkC,KAAMqiB,MAK5CxkB,GAAEiI,OAAOkc,GAASrW,UAAWoD,EAA2BS,EAAec,GC7HvE,IAAM7D,KACJ,SACA,eAII6V,GAAc5V,EAAiB5G,QACnC8G,UAAW,MAEX9E,YAH0C,SAG9B7E,GACVnF,KAAKsK,YAAYnF,GAEjBnF,KAAKqJ,aAAalE,EAASwJ,IAE3B3O,KAAKykB,cAEL7V,EAAiBf,UAAU7D,YAAYvI,MAAMzB,KAAMmB,YAGrDsW,YAAa/B,GAEb+O,YAf0C,SAe9Btf,GACV,GAAM2T,GAAS9Y,KAAK8Y,OACdL,EAAczY,KAAKyX,WAIzB,OAAI1X,GAAE0E,SAASqU,QACb9Y,KAAK0kB,QAAU,GAAIjM,IACjBzP,GAAI8P,UAKR9Y,KAAK0kB,QAAU5L,IAGjBO,UA/B0C,WAgCxC,MAAOrZ,MAAK0kB,SAGdC,SAnC0C,SAmCjCziB,GAAe,IAAA,GAChB4W,GAAS9Y,KAAKqZ,YADEnY,EAAAC,UAAAC,OAANC,EAAMC,MAAAJ,EAAA,EAAAA,EAAA,EAAA,GAAAK,EAAA,EAAAA,EAAAL,EAAAK,IAANF,EAAME,EAAA,GAAAJ,UAAAI,EAEtB,OAAOuX,GAAO/C,KAAPtU,MAAAqX,GAAY5W,GAAZP,OAAqBN,KAG9BujB,QAxC0C,WAyCxC,MAAO5kB,MAAKqZ,YAAYnD,aAI1B2O,MA7C0C,SA6CpC1f,GAGJ,MAFAnF,MAAKS,cAAc,eAAgBT,KAAMmF,GACzCnF,KAAKS,cAAc,QAAST,KAAMmF,GAC3BnF,QCnCL2O,IACJ,YACA,cAGImW,GAAYhlB,EAASilB,OAAO/c,QAEhCgC,YAFuC,SAE3B7E,GACVnF,KAAKsK,YAAYnF,GAEjBnF,KAAKqJ,aAAalE,EAASwJ,IAE3B7O,EAASilB,OAAOtjB,MAAMzB,KAAMmB,UAE5B,IAAM6jB,GAAYhlB,KAAKglB,UACjBC,EAAajlB,KAAKklB,gBACxBllB,MAAKmlB,iBAAiBF,EAAYD,GAClChlB,KAAKqD,GAAG,QAASrD,KAAKolB,gBAAiBplB,OAKzCqlB,SAjBuC,SAiB9BC,EAAO3kB,GACd,GAAMskB,GAAajlB,KAAKklB,gBAExB,OADAllB,MAAKulB,aAAaN,EAAYK,EAAO3kB,GAC9BX,MAKTolB,gBAzBuC,SAyBvBI,EAAWC,GAEzB,GAAI1lB,EAAEyB,WAAWxB,KAAK0lB,SAAU,CAE9B,GAAMC,GAAY5lB,EAAE6lB,OAAO5lB,KAAKglB,WAAWQ,EAC3CxlB,MAAK0lB,QAAQF,EAAWG,EAAWF,KAOvCN,iBArCuC,SAqCtBF,EAAYD,GAAW,GAAAtb,GAAA1J,IACtC,KAAKglB,EAAa,MAAOhlB,KAEzB,IAAM6lB,GAAa9lB,EAAEuJ,KAAK0b,GAAWc,SAMrC,OAJA/lB,GAAEsC,KAAKwjB,EAAY,SAAAP,GACjB5b,EAAK6b,aAAaN,EAAYK,EAAON,EAAUM,MAG1CtlB,MAGTklB,eAjDuC,WAkDrC,MAAOllB,MAAKilB,YAGdM,aArDuC,SAqD1BN,EAAYK,EAAO3kB,GAC9B,GAAMG,GAASmkB,EAAWtkB,EAE1B,KAAKG,EACH,KAAM,IAAIqD,GAAJ,WAA+BxD,EAA/B,oCAGRX,MAAKslB,MAAMA,EAAO3kB,EAAYZ,EAAEsL,KAAKvK,EAAQmkB,KAG/CxkB,cAAeA,GAGjBV,GAAEiI,OAAO8c,GAAUjX,UAAWxD,E5B9F9B,IAAMlD,O6B+CA4e,GAAqBjmB,EAASD,WAC9BA,GAAaC,EAASD,avC2kH3B,OuCrkHDA,IAAW+L,WAAa,WAEtB,MADA9L,GAASD,WAAakmB,GACf/lB,MAITH,GAAW6E,WAAaqD,EAAMrD,GAC9B7E,GAAW8E,aAAeoD,EAAMpD,GAChC9E,GAAWmF,aAAe+C,EAAM/C,GAChCnF,GAAWoF,eAAiB8C,EAAM9C,GAClCpF,GAAWwJ,aAAetB,EAAMsB,GAChCxJ,GAAWkB,UAAYgH,EAAMhH,GAC7BlB,GAAWkF,iBAAmBgD,EAAMhD,GACpClF,GAAWmI,OAASA,EACpBnI,GAAWkJ,eAAiBA,EAC5BlJ,GAAWqI,UAAYA,EACvBrI,GAAWY,cAAgBsH,EAAMtH,GACjCZ,GAAW+B,gBAAkBA,EAC7B/B,GAAWoH,UAAYA,EACvBpH,GAAWuH,WAAaA,EACxBvH,GAAW+C,kBAAoBA,EAE/B/C,GAAWyF,aACXzF,GAAWyF,UAAUC,gBAAkBA,EAGvC1F,GAAW2kB,YAAcA,GACzB3kB,GAAWilB,UAAYA,GACvBjlB,GAAW4Z,SAAWA,GACtB5Z,GAAWqP,cAAgBA,EAC3BrP,GAAW6T,KAAOA,GAClB7T,GAAWmc,eAAiBA,GAC5Bnc,GAAWujB,cAAgBA,GAC3BvjB,GAAWqkB,SAAWA,GACtBrkB,GAAW6V,OAASA,GACpB7V,GAAWiK,MAAQ3F,EACnBtE,GAAWmmB,OAASpX,EAGpB/O,GAAWyI,UAAW,EACtBzI,GAAWsH,SAAWA,GACtBtH,GAAW8L,QAAU7D,EvC4hHbjI","file":"backbone.marionette.min.js","sourcesContent":["// MarionetteJS (Backbone.Marionette)\n// ----------------------------------\n// v3.0.0-pre.4\n//\n// Copyright (c)2016 Derick Bailey, Muted Solutions, LLC.\n// Distributed under MIT license\n//\n// http://marionettejs.com\n\n\n/*!\n* Includes BabySitter\n* https://github.com/marionettejs/backbone.babysitter/\n*\n* Includes Radio\n* https://github.com/marionettejs/backbone.radio/\n*/\n\n\n\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('backbone'), require('underscore')) :\n\ttypeof define === 'function' && define.amd ? define(['backbone', 'underscore'], factory) :\n\t(global.Marionette = global['Mn'] = factory(global.Backbone,global._));\n}(this, function (Backbone,_) { 'use strict';\n\n\tBackbone = 'default' in Backbone ? Backbone['default'] : Backbone;\n\t_ = 'default' in _ ? _['default'] : _;\n\n\tvar __commonjs_global = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : this;\n\tfunction __commonjs(fn, module) { return module = { exports: {} }, fn(module, module.exports, __commonjs_global), module.exports; }\n\n\n\tvar babelHelpers = {};\n\n\tbabelHelpers.toConsumableArray = function (arr) {\n\t  if (Array.isArray(arr)) {\n\t    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n\t    return arr2;\n\t  } else {\n\t    return Array.from(arr);\n\t  }\n\t};\n\n\tbabelHelpers;\n\n\tvar version = \"3.0.0-pre.4\";\n\n\t//Internal utility for creating context style global utils\n\tvar proxy = function proxy(method) {\n\t  return function (context) {\n\t    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t      args[_key - 1] = arguments[_key];\n\t    }\n\n\t    return method.apply(context, args);\n\t  };\n\t};\n\n\t// Borrow the Backbone `extend` method so we can use it as needed\n\tvar extend = Backbone.Model.extend;\n\n\tvar deprecate = function deprecate(message, test) {\n\t  if (_.isObject(message)) {\n\t    message = message.prev + ' is going to be removed in the future. ' + 'Please use ' + message.next + ' instead.' + (message.url ? ' See: ' + message.url : '');\n\t  }\n\n\t  if (!Marionette.DEV_MODE) {\n\t    return;\n\t  }\n\n\t  if ((test === undefined || !test) && !deprecate._cache[message]) {\n\t    deprecate._warn('Deprecation warning: ' + message);\n\t    deprecate._cache[message] = true;\n\t  }\n\t};\n\n\tdeprecate._console = typeof console !== 'undefined' ? console : {};\n\tdeprecate._warn = function () {\n\t  var warn = deprecate._console.warn || deprecate._console.log || _.noop;\n\t  return warn.apply(deprecate._console, arguments);\n\t};\n\tdeprecate._cache = {};\n\n\t// Determine if `el` is a child of the document\n\tvar isNodeAttached = function isNodeAttached(el) {\n\t  return Backbone.$.contains(document.documentElement, el);\n\t};\n\n\t// Merge `keys` from `options` onto `this`\n\tvar mergeOptions = function mergeOptions(options, keys) {\n\t  if (!options) {\n\t    return;\n\t  }\n\t  _.extend(this, _.pick(options, keys));\n\t};\n\n\t// Marionette.getOption\n\t// --------------------\n\n\t// Retrieve an object, function or other value from the\n\t// object or its `options`, with `options` taking precedence.\n\tvar getOption = function getOption(optionName) {\n\t  if (!optionName) {\n\t    return;\n\t  }\n\t  if (this.options && this.options[optionName] !== undefined) {\n\t    return this.options[optionName];\n\t  } else {\n\t    return this[optionName];\n\t  }\n\t};\n\n\t// Marionette.normalizeMethods\n\t// ----------------------\n\n\t// Pass in a mapping of events => functions or function names\n\t// and return a mapping of events => functions\n\tvar normalizeMethods = function normalizeMethods(hash) {\n\t  var _this = this;\n\n\t  return _.reduce(hash, function (normalizedHash, method, name) {\n\t    if (!_.isFunction(method)) {\n\t      method = _this[method];\n\t    }\n\t    if (method) {\n\t      normalizedHash[name] = method;\n\t    }\n\t    return normalizedHash;\n\t  }, {});\n\t};\n\n\t// split the event name on the \":\"\n\tvar splitter = /(^|:)(\\w)/gi;\n\n\t// take the event section (\"section1:section2:section3\")\n\t// and turn it in to uppercase name onSection1Section2Section3\n\tfunction getEventName(match, prefix, eventName) {\n\t  return eventName.toUpperCase();\n\t}\n\n\t// Trigger an event and/or a corresponding method name. Examples:\n\t//\n\t// `this.triggerMethod(\"foo\")` will trigger the \"foo\" event and\n\t// call the \"onFoo\" method.\n\t//\n\t// `this.triggerMethod(\"foo:bar\")` will trigger the \"foo:bar\" event and\n\t// call the \"onFooBar\" method.\n\tfunction triggerMethod(event) {\n\t  // get the method name from the event name\n\t  var methodName = 'on' + event.replace(splitter, getEventName);\n\t  var method = getOption.call(this, methodName);\n\t  var result = void 0;\n\n\t  // call the onMethodName if it exists\n\n\t  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t    args[_key - 1] = arguments[_key];\n\t  }\n\n\t  if (_.isFunction(method)) {\n\t    // pass all args, except the event name\n\t    result = method.apply(this, args);\n\t  }\n\n\t  // trigger the event\n\t  this.trigger.apply(this, [event].concat(args));\n\n\t  return result;\n\t}\n\n\t// triggerMethodOn invokes triggerMethod on a specific context\n\t//\n\t// e.g. `Marionette.triggerMethodOn(view, 'show')`\n\t// will trigger a \"show\" event or invoke onShow the view.\n\tfunction triggerMethodOn(context) {\n\t  var fnc = _.isFunction(context.triggerMethod) ? context.triggerMethod : triggerMethod;\n\n\t  for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n\t    args[_key2 - 1] = arguments[_key2];\n\t  }\n\n\t  return fnc.apply(context, args);\n\t}\n\n\t// Trigger method on children unless a pure Backbone.View\n\tfunction triggerMethodChildren(view, event, shouldTrigger) {\n\t  if (!view._getImmediateChildren) {\n\t    return;\n\t  }\n\t  _.each(view._getImmediateChildren(), function (child) {\n\t    if (!shouldTrigger(child)) {\n\t      return;\n\t    }\n\t    triggerMethodOn(child, event, child);\n\t  });\n\t}\n\n\tfunction shouldTriggerAttach(view) {\n\t  return !view._isAttached;\n\t}\n\n\tfunction shouldAttach(view) {\n\t  if (!shouldTriggerAttach(view)) {\n\t    return false;\n\t  }\n\t  view._isAttached = true;\n\t  return true;\n\t}\n\n\tfunction shouldTriggerDetach(view) {\n\t  return view._isAttached;\n\t}\n\n\tfunction shouldDetach(view) {\n\t  if (!shouldTriggerDetach(view)) {\n\t    return false;\n\t  }\n\t  view._isAttached = false;\n\t  return true;\n\t}\n\n\t// Monitor a view's state, propagating attach/detach events to children and firing dom:refresh\n\t// whenever a rendered view is attached or an attached view is rendered.\n\tfunction monitorViewEvents(view) {\n\t  if (view._areViewEventsMonitored) {\n\t    return;\n\t  }\n\n\t  view._areViewEventsMonitored = true;\n\n\t  function handleBeforeAttach() {\n\t    triggerMethodChildren(view, 'before:attach', shouldTriggerAttach);\n\t  }\n\n\t  function handleAttach() {\n\t    triggerMethodChildren(view, 'attach', shouldAttach);\n\t    triggerDOMRefresh();\n\t  }\n\n\t  function handleBeforeDetach() {\n\t    triggerMethodChildren(view, 'before:detach', shouldTriggerDetach);\n\t  }\n\n\t  function handleDetach() {\n\t    triggerMethodChildren(view, 'detach', shouldDetach);\n\t  }\n\n\t  function handleRender() {\n\t    triggerDOMRefresh();\n\t  }\n\n\t  function triggerDOMRefresh() {\n\t    if (view._isAttached && view._isRendered) {\n\t      triggerMethodOn(view, 'dom:refresh', view);\n\t    }\n\t  }\n\n\t  view.on({\n\t    'before:attach': handleBeforeAttach,\n\t    'attach': handleAttach,\n\t    'before:detach': handleBeforeDetach,\n\t    'detach': handleDetach,\n\t    'render': handleRender\n\t  });\n\t}\n\n\tvar errorProps = ['description', 'fileName', 'lineNumber', 'name', 'message', 'number'];\n\n\tvar MarionetteError = extend.call(Error, {\n\t  urlRoot: 'http://marionettejs.com/docs/v' + version + '/',\n\n\t  constructor: function constructor(message, options) {\n\t    if (_.isObject(message)) {\n\t      options = message;\n\t      message = options.message;\n\t    } else if (!options) {\n\t      options = {};\n\t    }\n\n\t    var error = Error.call(this, message);\n\t    _.extend(this, _.pick(error, errorProps), _.pick(options, errorProps));\n\n\t    this.captureStackTrace();\n\n\t    if (options.url) {\n\t      this.url = this.urlRoot + options.url;\n\t    }\n\t  },\n\t  captureStackTrace: function captureStackTrace() {\n\t    if (Error.captureStackTrace) {\n\t      Error.captureStackTrace(this, MarionetteError);\n\t    }\n\t  },\n\t  toString: function toString() {\n\t    return this.name + ': ' + this.message + (this.url ? ' See: ' + this.url : '');\n\t  }\n\t});\n\n\tMarionetteError.extend = extend;\n\n\t// Bind/unbind the event to handlers specified as a string of\n\t// handler names on the target object\n\tfunction bindFromStrings(target, entity, evt, methods, actionName) {\n\t  var methodNames = methods.split(/\\s+/);\n\n\t  _.each(methodNames, function (methodName) {\n\t    var method = target[methodName];\n\t    if (!method) {\n\t      throw new MarionetteError('Method \"' + methodName + '\" was configured as an event handler, but does not exist.');\n\t    }\n\n\t    target[actionName](entity, evt, method);\n\t  });\n\t}\n\n\t// generic looping function\n\tfunction iterateEvents(target, entity, bindings, actionName) {\n\t  if (!entity || !bindings) {\n\t    return;\n\t  }\n\n\t  // type-check bindings\n\t  if (!_.isObject(bindings)) {\n\t    throw new MarionetteError({\n\t      message: 'Bindings must be an object.',\n\t      url: 'marionette.functions.html#marionettebindevents'\n\t    });\n\t  }\n\n\t  // iterate the bindings and bind/unbind them\n\t  _.each(bindings, function (method, evt) {\n\n\t    // allow for a list of method names as a string\n\t    if (_.isString(method)) {\n\t      bindFromStrings(target, entity, evt, method, actionName);\n\t      return;\n\t    }\n\n\t    target[actionName](entity, evt, method);\n\t  });\n\t}\n\n\tfunction bindEvents(entity, bindings) {\n\t  iterateEvents(this, entity, bindings, 'listenTo');\n\t  return this;\n\t}\n\n\tfunction unbindEvents(entity, bindings) {\n\t  iterateEvents(this, entity, bindings, 'stopListening');\n\t  return this;\n\t}\n\n\tfunction iterateReplies(target, channel, bindings, actionName) {\n\t  if (!channel || !bindings) {\n\t    return;\n\t  }\n\n\t  // type-check bindings\n\t  if (!_.isObject(bindings)) {\n\t    throw new MarionetteError({\n\t      message: 'Bindings must be an object.',\n\t      url: 'marionette.functions.html#marionettebindrequests'\n\t    });\n\t  }\n\n\t  var normalizedRadioRequests = normalizeMethods.call(target, bindings);\n\n\t  channel[actionName](normalizedRadioRequests, target);\n\t}\n\n\tfunction bindRequests(channel, bindings) {\n\t  iterateReplies(this, channel, bindings, 'reply');\n\t  return this;\n\t}\n\n\tfunction unbindRequests(channel, bindings) {\n\t  iterateReplies(this, channel, bindings, 'stopReplying');\n\t  return this;\n\t}\n\n\t// Internal utility for setting options consistently across Mn\n\tvar setOptions = function setOptions() {\n\t  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t    args[_key] = arguments[_key];\n\t  }\n\n\t  this.options = _.extend.apply(_, [{}, _.result(this, 'options')].concat(args));\n\t};\n\n\tvar CommonMixin = {\n\n\t  // Imports the \"normalizeMethods\" to transform hashes of\n\t  // events=>function references/names to a hash of events=>function references\n\t  normalizeMethods: normalizeMethods,\n\n\t  _setOptions: setOptions,\n\n\t  // A handy way to merge passed-in options onto the instance\n\t  mergeOptions: mergeOptions,\n\n\t  // Enable getting options from this or this.options by name.\n\t  getOption: getOption,\n\n\t  // Enable binding view's events from another entity.\n\t  bindEvents: bindEvents,\n\n\t  // Enable unbinding view's events from another entity.\n\t  unbindEvents: unbindEvents\n\t};\n\n\tvar backbone_radio = __commonjs(function (module, exports, global) {\n\t// Backbone.Radio v2.0.0-pre.1\n\n\t(function (global, factory) {\n\t  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(_, Backbone) :\n\t  typeof define === 'function' && define.amd ? define(['underscore', 'backbone'], factory) :\n\t  (global.Backbone = global.Backbone || {}, global.Backbone.Radio = factory(global._,global.Backbone));\n\t}(__commonjs_global, function (_,Backbone) { 'use strict';\n\n\t  _ = 'default' in _ ? _['default'] : _;\n\t  Backbone = 'default' in Backbone ? Backbone['default'] : Backbone;\n\n\t  var babelHelpers = {};\n\t  babelHelpers.typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n\t    return typeof obj;\n\t  } : function (obj) {\n\t    return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n\t  };\n\t  babelHelpers;\n\n\t  var previousRadio = Backbone.Radio;\n\n\t  var Radio = Backbone.Radio = {};\n\n\t  Radio.VERSION = '2.0.0-pre.1';\n\n\t  // This allows you to run multiple instances of Radio on the same\n\t  // webapp. After loading the new version, call `noConflict()` to\n\t  // get a reference to it. At the same time the old version will be\n\t  // returned to Backbone.Radio.\n\t  Radio.noConflict = function () {\n\t    Backbone.Radio = previousRadio;\n\t    return this;\n\t  };\n\n\t  // Whether or not we're in DEBUG mode or not. DEBUG mode helps you\n\t  // get around the issues of lack of warnings when events are mis-typed.\n\t  Radio.DEBUG = false;\n\n\t  // Format debug text.\n\t  Radio._debugText = function (warning, eventName, channelName) {\n\t    return warning + (channelName ? ' on the ' + channelName + ' channel' : '') + ': \"' + eventName + '\"';\n\t  };\n\n\t  // This is the method that's called when an unregistered event was called.\n\t  // By default, it logs warning to the console. By overriding this you could\n\t  // make it throw an Error, for instance. This would make firing a nonexistent event\n\t  // have the same consequence as firing a nonexistent method on an Object.\n\t  Radio.debugLog = function (warning, eventName, channelName) {\n\t    if (Radio.DEBUG && console && console.warn) {\n\t      console.warn(Radio._debugText(warning, eventName, channelName));\n\t    }\n\t  };\n\n\t  var eventSplitter = /\\s+/;\n\n\t  // An internal method used to handle Radio's method overloading for Requests.\n\t  // It's borrowed from Backbone.Events. It differs from Backbone's overload\n\t  // API (which is used in Backbone.Events) in that it doesn't support space-separated\n\t  // event names.\n\t  Radio._eventsApi = function (obj, action, name, rest) {\n\t    if (!name) {\n\t      return false;\n\t    }\n\n\t    var results = {};\n\n\t    // Handle event maps.\n\t    if ((typeof name === 'undefined' ? 'undefined' : babelHelpers.typeof(name)) === 'object') {\n\t      for (var key in name) {\n\t        var result = obj[action].apply(obj, [key, name[key]].concat(rest));\n\t        eventSplitter.test(key) ? _.extend(results, result) : results[key] = result;\n\t      }\n\t      return results;\n\t    }\n\n\t    // Handle space separated event names.\n\t    if (eventSplitter.test(name)) {\n\t      var names = name.split(eventSplitter);\n\t      for (var i = 0, l = names.length; i < l; i++) {\n\t        results[names[i]] = obj[action].apply(obj, [names[i]].concat(rest));\n\t      }\n\t      return results;\n\t    }\n\n\t    return false;\n\t  };\n\n\t  // An optimized way to execute callbacks.\n\t  Radio._callHandler = function (callback, context, args) {\n\t    var a1 = args[0],\n\t        a2 = args[1],\n\t        a3 = args[2];\n\t    switch (args.length) {\n\t      case 0:\n\t        return callback.call(context);\n\t      case 1:\n\t        return callback.call(context, a1);\n\t      case 2:\n\t        return callback.call(context, a1, a2);\n\t      case 3:\n\t        return callback.call(context, a1, a2, a3);\n\t      default:\n\t        return callback.apply(context, args);\n\t    }\n\t  };\n\n\t  // A helper used by `off` methods to the handler from the store\n\t  function removeHandler(store, name, callback, context) {\n\t    var event = store[name];\n\t    if ((!callback || callback === event.callback || callback === event.callback._callback) && (!context || context === event.context)) {\n\t      delete store[name];\n\t      return true;\n\t    }\n\t  }\n\n\t  function removeHandlers(store, name, callback, context) {\n\t    store || (store = {});\n\t    var names = name ? [name] : _.keys(store);\n\t    var matched = false;\n\n\t    for (var i = 0, length = names.length; i < length; i++) {\n\t      name = names[i];\n\n\t      // If there's no event by this name, log it and continue\n\t      // with the loop\n\t      if (!store[name]) {\n\t        continue;\n\t      }\n\n\t      if (removeHandler(store, name, callback, context)) {\n\t        matched = true;\n\t      }\n\t    }\n\n\t    return matched;\n\t  }\n\n\t  /*\n\t   * tune-in\n\t   * -------\n\t   * Get console logs of a channel's activity\n\t   *\n\t   */\n\n\t  var _logs = {};\n\n\t  // This is to produce an identical function in both tuneIn and tuneOut,\n\t  // so that Backbone.Events unregisters it.\n\t  function _partial(channelName) {\n\t    return _logs[channelName] || (_logs[channelName] = _.bind(Radio.log, Radio, channelName));\n\t  }\n\n\t  _.extend(Radio, {\n\n\t    // Log information about the channel and event\n\t    log: function log(channelName, eventName) {\n\t      if (typeof console === 'undefined') {\n\t        return;\n\t      }\n\t      var args = _.toArray(arguments).slice(2);\n\t      console.log('[' + channelName + '] \"' + eventName + '\"', args);\n\t    },\n\n\t    // Logs all events on this channel to the console. It sets an\n\t    // internal value on the channel telling it we're listening,\n\t    // then sets a listener on the Backbone.Events\n\t    tuneIn: function tuneIn(channelName) {\n\t      var channel = Radio.channel(channelName);\n\t      channel._tunedIn = true;\n\t      channel.on('all', _partial(channelName));\n\t      return this;\n\t    },\n\n\t    // Stop logging all of the activities on this channel to the console\n\t    tuneOut: function tuneOut(channelName) {\n\t      var channel = Radio.channel(channelName);\n\t      channel._tunedIn = false;\n\t      channel.off('all', _partial(channelName));\n\t      delete _logs[channelName];\n\t      return this;\n\t    }\n\t  });\n\n\t  /*\n\t   * Backbone.Radio.Requests\n\t   * -----------------------\n\t   * A messaging system for requesting data.\n\t   *\n\t   */\n\n\t  function makeCallback(callback) {\n\t    return _.isFunction(callback) ? callback : function () {\n\t      return callback;\n\t    };\n\t  }\n\n\t  Radio.Requests = {\n\n\t    // Make a request\n\t    request: function request(name) {\n\t      var args = _.toArray(arguments).slice(1);\n\t      var results = Radio._eventsApi(this, 'request', name, args);\n\t      if (results) {\n\t        return results;\n\t      }\n\t      var channelName = this.channelName;\n\t      var requests = this._requests;\n\n\t      // Check if we should log the request, and if so, do it\n\t      if (channelName && this._tunedIn) {\n\t        Radio.log.apply(this, [channelName, name].concat(args));\n\t      }\n\n\t      // If the request isn't handled, log it in DEBUG mode and exit\n\t      if (requests && (requests[name] || requests['default'])) {\n\t        var handler = requests[name] || requests['default'];\n\t        args = requests[name] ? args : arguments;\n\t        return Radio._callHandler(handler.callback, handler.context, args);\n\t      } else {\n\t        Radio.debugLog('An unhandled request was fired', name, channelName);\n\t      }\n\t    },\n\n\t    // Set up a handler for a request\n\t    reply: function reply(name, callback, context) {\n\t      if (Radio._eventsApi(this, 'reply', name, [callback, context])) {\n\t        return this;\n\t      }\n\n\t      this._requests || (this._requests = {});\n\n\t      if (this._requests[name]) {\n\t        Radio.debugLog('A request was overwritten', name, this.channelName);\n\t      }\n\n\t      this._requests[name] = {\n\t        callback: makeCallback(callback),\n\t        context: context || this\n\t      };\n\n\t      return this;\n\t    },\n\n\t    // Set up a handler that can only be requested once\n\t    replyOnce: function replyOnce(name, callback, context) {\n\t      if (Radio._eventsApi(this, 'replyOnce', name, [callback, context])) {\n\t        return this;\n\t      }\n\n\t      var self = this;\n\n\t      var once = _.once(function () {\n\t        self.stopReplying(name);\n\t        return makeCallback(callback).apply(this, arguments);\n\t      });\n\n\t      return this.reply(name, once, context);\n\t    },\n\n\t    // Remove handler(s)\n\t    stopReplying: function stopReplying(name, callback, context) {\n\t      if (Radio._eventsApi(this, 'stopReplying', name)) {\n\t        return this;\n\t      }\n\n\t      // Remove everything if there are no arguments passed\n\t      if (!name && !callback && !context) {\n\t        delete this._requests;\n\t      } else if (!removeHandlers(this._requests, name, callback, context)) {\n\t        Radio.debugLog('Attempted to remove the unregistered request', name, this.channelName);\n\t      }\n\n\t      return this;\n\t    }\n\t  };\n\n\t  /*\n\t   * Backbone.Radio.channel\n\t   * ----------------------\n\t   * Get a reference to a channel by name.\n\t   *\n\t   */\n\n\t  Radio._channels = {};\n\n\t  Radio.channel = function (channelName) {\n\t    if (!channelName) {\n\t      throw new Error('You must provide a name for the channel.');\n\t    }\n\n\t    if (Radio._channels[channelName]) {\n\t      return Radio._channels[channelName];\n\t    } else {\n\t      return Radio._channels[channelName] = new Radio.Channel(channelName);\n\t    }\n\t  };\n\n\t  /*\n\t   * Backbone.Radio.Channel\n\t   * ----------------------\n\t   * A Channel is an object that extends from Backbone.Events,\n\t   * and Radio.Requests.\n\t   *\n\t   */\n\n\t  Radio.Channel = function (channelName) {\n\t    this.channelName = channelName;\n\t  };\n\n\t  _.extend(Radio.Channel.prototype, Backbone.Events, Radio.Requests, {\n\n\t    // Remove all handlers from the messaging systems of this channel\n\t    reset: function reset() {\n\t      this.off();\n\t      this.stopListening();\n\t      this.stopReplying();\n\t      return this;\n\t    }\n\t  });\n\n\t  /*\n\t   * Top-level API\n\t   * -------------\n\t   * Supplies the 'top-level API' for working with Channels directly\n\t   * from Backbone.Radio.\n\t   *\n\t   */\n\n\t  var channel;\n\t  var args;\n\t  var systems = [Backbone.Events, Radio.Requests];\n\t  _.each(systems, function (system) {\n\t    _.each(system, function (method, methodName) {\n\t      Radio[methodName] = function (channelName) {\n\t        args = _.toArray(arguments).slice(1);\n\t        channel = this.channel(channelName);\n\t        return channel[methodName].apply(channel, args);\n\t      };\n\t    });\n\t  });\n\n\t  Radio.reset = function (channelName) {\n\t    var channels = !channelName ? this._channels : [this._channels[channelName]];\n\t    _.each(channels, function (channel) {\n\t      channel.reset();\n\t    });\n\t  };\n\n\t  return Radio;\n\n\t}));\n\t});\n\n\tvar Radio = (backbone_radio && typeof backbone_radio === 'object' && 'default' in backbone_radio ? backbone_radio['default'] : backbone_radio);\n\n\t// MixinOptions\n\t// - channelName\n\t// - radioEvents\n\t// - radioRequests\n\n\tvar RadioMixin = {\n\t  _initRadio: function _initRadio() {\n\t    var channelName = _.result(this, 'channelName');\n\n\t    if (!channelName) {\n\t      return;\n\t    }\n\n\t    var channel = this._channel = Radio.channel(channelName);\n\n\t    var radioEvents = _.result(this, 'radioEvents');\n\t    this.bindEvents(channel, radioEvents);\n\n\t    var radioRequests = _.result(this, 'radioRequests');\n\t    this.bindRequests(channel, radioRequests);\n\n\t    this.on('destroy', this._destroyRadio);\n\t  },\n\t  _destroyRadio: function _destroyRadio() {\n\t    this._channel.stopReplying(null, null, this);\n\t  },\n\t  getChannel: function getChannel() {\n\t    return this._channel;\n\t  },\n\n\n\t  // Proxy `bindEvents`\n\t  bindEvents: bindEvents,\n\n\t  // Proxy `unbindEvents`\n\t  unbindEvents: unbindEvents,\n\n\t  // Proxy `bindRequests`\n\t  bindRequests: bindRequests,\n\n\t  // Proxy `unbindRequests`\n\t  unbindRequests: unbindRequests\n\n\t};\n\n\tvar ClassOptions = ['channelName', 'radioEvents', 'radioRequests'];\n\n\t// A Base Class that other Classes should descend from.\n\t// Object borrows many conventions and utilities from Backbone.\n\tvar MarionetteObject = function MarionetteObject(options) {\n\t  this._setOptions(options);\n\t  this.mergeOptions(options, ClassOptions);\n\t  this.cid = _.uniqueId(this.cidPrefix);\n\t  this._initRadio();\n\t  this.initialize.apply(this, arguments);\n\t};\n\n\tMarionetteObject.extend = extend;\n\n\t// Object Methods\n\t// --------------\n\n\t// Ensure it can trigger events with Backbone.Events\n\t_.extend(MarionetteObject.prototype, Backbone.Events, CommonMixin, RadioMixin, {\n\t  cidPrefix: 'mno',\n\n\t  // for parity with Marionette.AbstractView lifecyle\n\t  _isDestroyed: false,\n\n\t  isDestroyed: function isDestroyed() {\n\t    return this._isDestroyed;\n\t  },\n\n\n\t  //this is a noop method intended to be overridden by classes that extend from this base\n\t  initialize: function initialize() {},\n\t  destroy: function destroy() {\n\t    if (this._isDestroyed) {\n\t      return this;\n\t    }\n\n\t    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t      args[_key] = arguments[_key];\n\t    }\n\n\t    this.triggerMethod.apply(this, ['before:destroy', this].concat(args));\n\n\t    this._isDestroyed = true;\n\t    this.triggerMethod.apply(this, ['destroy', this].concat(args));\n\t    this.stopListening();\n\n\t    return this;\n\t  },\n\n\n\t  triggerMethod: triggerMethod\n\t});\n\n\t// Manage templates stored in `<script>` blocks,\n\t// caching them for faster access.\n\tvar TemplateCache = function TemplateCache(templateId) {\n\t  this.templateId = templateId;\n\t};\n\n\t// TemplateCache object-level methods. Manage the template\n\t// caches from these method calls instead of creating\n\t// your own TemplateCache instances\n\t_.extend(TemplateCache, {\n\t  templateCaches: {},\n\n\t  // Get the specified template by id. Either\n\t  // retrieves the cached version, or loads it\n\t  // from the DOM.\n\t  get: function get(templateId, options) {\n\t    var cachedTemplate = this.templateCaches[templateId];\n\n\t    if (!cachedTemplate) {\n\t      cachedTemplate = new TemplateCache(templateId);\n\t      this.templateCaches[templateId] = cachedTemplate;\n\t    }\n\n\t    return cachedTemplate.load(options);\n\t  },\n\n\n\t  // Clear templates from the cache. If no arguments\n\t  // are specified, clears all templates:\n\t  // `clear()`\n\t  //\n\t  // If arguments are specified, clears each of the\n\t  // specified templates from the cache:\n\t  // `clear(\"#t1\", \"#t2\", \"...\")`\n\t  clear: function clear() {\n\t    var i = void 0;\n\n\t    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t      args[_key] = arguments[_key];\n\t    }\n\n\t    var length = args.length;\n\n\t    if (length > 0) {\n\t      for (i = 0; i < length; i++) {\n\t        delete this.templateCaches[args[i]];\n\t      }\n\t    } else {\n\t      this.templateCaches = {};\n\t    }\n\t  }\n\t});\n\n\t// TemplateCache instance methods, allowing each\n\t// template cache object to manage its own state\n\t// and know whether or not it has been loaded\n\t_.extend(TemplateCache.prototype, {\n\n\t  // Internal method to load the template\n\n\t  load: function load(options) {\n\t    // Guard clause to prevent loading this template more than once\n\t    if (this.compiledTemplate) {\n\t      return this.compiledTemplate;\n\t    }\n\n\t    // Load the template and compile it\n\t    var template = this.loadTemplate(this.templateId, options);\n\t    this.compiledTemplate = this.compileTemplate(template, options);\n\n\t    return this.compiledTemplate;\n\t  },\n\n\n\t  // Load a template from the DOM, by default. Override\n\t  // this method to provide your own template retrieval\n\t  // For asynchronous loading with AMD/RequireJS, consider\n\t  // using a template-loader plugin as described here:\n\t  // https://github.com/marionettejs/backbone.marionette/wiki/Using-marionette-with-requirejs\n\t  loadTemplate: function loadTemplate(templateId, options) {\n\t    var $template = Backbone.$(templateId);\n\n\t    if (!$template.length) {\n\t      throw new MarionetteError({\n\t        name: 'NoTemplateError',\n\t        message: 'Could not find template: \"' + templateId + '\"'\n\t      });\n\t    }\n\t    return $template.html();\n\t  },\n\n\n\t  // Pre-compile the template before caching it. Override\n\t  // this method if you do not need to pre-compile a template\n\t  // (JST / RequireJS for example) or if you want to change\n\t  // the template engine used (Handebars, etc).\n\t  compileTemplate: function compileTemplate(rawTemplate, options) {\n\t    return _.template(rawTemplate, options);\n\t  }\n\t});\n\n\tvar _invoke = _.invokeMap || _.invoke;\n\n\t// MixinOptions\n\t// - behaviors\n\n\t// Takes care of getting the behavior class\n\t// given options and a key.\n\t// If a user passes in options.behaviorClass\n\t// default to using that.\n\t// If a user passes in a Behavior Class directly, use that\n\t// Otherwise delegate the lookup to the users `behaviorsLookup` implementation.\n\tfunction getBehaviorClass(options, key) {\n\t  if (options.behaviorClass) {\n\t    return options.behaviorClass;\n\t    //treat functions as a Behavior constructor\n\t  } else if (_.isFunction(options)) {\n\t    return options;\n\t  }\n\n\t  // behaviorsLookup can be either a flat object or a method\n\t  if (_.isFunction(Marionette.Behaviors.behaviorsLookup)) {\n\t    return Marionette.Behaviors.behaviorsLookup(options, key)[key];\n\t  }\n\n\t  return Marionette.Behaviors.behaviorsLookup[key];\n\t}\n\n\t// Iterate over the behaviors object, for each behavior\n\t// instantiate it and get its grouped behaviors.\n\t// This accepts a list of behaviors in either an object or array form\n\tfunction parseBehaviors(view, behaviors) {\n\t  return _.chain(behaviors).map(function (options, key) {\n\t    var BehaviorClass = getBehaviorClass(options, key);\n\t    //if we're passed a class directly instead of an object\n\t    var _options = options === BehaviorClass ? {} : options;\n\t    var behavior = new BehaviorClass(_options, view);\n\t    var nestedBehaviors = parseBehaviors(view, _.result(behavior, 'behaviors'));\n\n\t    return [behavior].concat(nestedBehaviors);\n\t  }).flatten().value();\n\t}\n\n\tvar BehaviorsMixin = {\n\t  _initBehaviors: function _initBehaviors() {\n\t    var behaviors = _.result(this, 'behaviors');\n\n\t    // Behaviors defined on a view can be a flat object literal\n\t    // or it can be a function that returns an object.\n\t    this._behaviors = _.isObject(behaviors) ? parseBehaviors(this, behaviors) : {};\n\t  },\n\t  _getBehaviorTriggers: function _getBehaviorTriggers() {\n\t    var triggers = _invoke(this._behaviors, 'getTriggers');\n\t    return _.extend.apply(_, [{}].concat(babelHelpers.toConsumableArray(triggers)));\n\t  },\n\t  _getBehaviorEvents: function _getBehaviorEvents() {\n\t    var events = _invoke(this._behaviors, 'getEvents');\n\t    return _.extend.apply(_, [{}].concat(babelHelpers.toConsumableArray(events)));\n\t  },\n\n\n\t  // proxy behavior $el to the view's $el.\n\t  _proxyBehaviorViewProperties: function _proxyBehaviorViewProperties() {\n\t    _invoke(this._behaviors, 'proxyViewProperties');\n\t  },\n\n\n\t  // delegate modelEvents and collectionEvents\n\t  _delegateBehaviorEntityEvents: function _delegateBehaviorEntityEvents() {\n\t    _invoke(this._behaviors, 'delegateEntityEvents');\n\t  },\n\n\n\t  // undelegate modelEvents and collectionEvents\n\t  _undelegateBehaviorEntityEvents: function _undelegateBehaviorEntityEvents() {\n\t    _invoke(this._behaviors, 'undelegateEntityEvents');\n\t  },\n\t  _destroyBehaviors: function _destroyBehaviors(args) {\n\t    // Call destroy on each behavior after\n\t    // destroying the view.\n\t    // This unbinds event listeners\n\t    // that behaviors have registered for.\n\t    _invoke.apply(undefined, [this._behaviors, 'destroy'].concat(babelHelpers.toConsumableArray(args)));\n\t  },\n\t  _bindBehaviorUIElements: function _bindBehaviorUIElements() {\n\t    _invoke(this._behaviors, 'bindUIElements');\n\t  },\n\t  _unbindBehaviorUIElements: function _unbindBehaviorUIElements() {\n\t    _invoke(this._behaviors, 'unbindUIElements');\n\t  },\n\t  _triggerEventOnBehaviors: function _triggerEventOnBehaviors() {\n\t    var behaviors = this._behaviors;\n\t    // Use good ol' for as this is a very hot function\n\n\t    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t      args[_key] = arguments[_key];\n\t    }\n\n\t    for (var i = 0, length = behaviors && behaviors.length; i < length; i++) {\n\t      triggerMethod.apply(behaviors[i], args);\n\t    }\n\t  }\n\t};\n\n\t// MixinOptions\n\t// - collectionEvents\n\t// - modelEvents\n\n\tvar DelegateEntityEventsMixin = {\n\t  // Handle `modelEvents`, and `collectionEvents` configuration\n\n\t  _delegateEntityEvents: function _delegateEntityEvents(model, collection) {\n\t    this._undelegateEntityEvents(model, collection);\n\n\t    var modelEvents = _.result(this, 'modelEvents');\n\t    bindEvents.call(this, model, modelEvents);\n\n\t    var collectionEvents = _.result(this, 'collectionEvents');\n\t    bindEvents.call(this, collection, collectionEvents);\n\t  },\n\t  _undelegateEntityEvents: function _undelegateEntityEvents(model, collection) {\n\t    var modelEvents = _.result(this, 'modelEvents');\n\t    unbindEvents.call(this, model, modelEvents);\n\n\t    var collectionEvents = _.result(this, 'collectionEvents');\n\t    unbindEvents.call(this, collection, collectionEvents);\n\t  }\n\t};\n\n\t// Borrow event splitter from Backbone\n\tvar delegateEventSplitter = /^(\\S+)\\s*(.*)$/;\n\n\tfunction uniqueName(eventName, selector) {\n\t  return [eventName + _.uniqueId('.evt'), selector].join(' ');\n\t}\n\n\t// Set event name to be namespaced using a unique index\n\t// to generate a non colliding event namespace\n\t// http://api.jquery.com/event.namespace/\n\tvar getUniqueEventName = function getUniqueEventName(eventName) {\n\t  var match = eventName.match(delegateEventSplitter);\n\t  return uniqueName(match[1], match[2]);\n\t};\n\n\t// Internal method to create an event handler for a given `triggerDef` like\n\t// 'click:foo'\n\tfunction buildViewTrigger(view, triggerDef) {\n\t  if (_.isString(triggerDef)) {\n\t    triggerDef = { event: triggerDef };\n\t  }\n\n\t  var eventName = triggerDef.event;\n\t  var shouldPreventDefault = triggerDef.preventDefault !== false;\n\t  var shouldStopPropagation = triggerDef.stopPropagation !== false;\n\n\t  return function (e) {\n\t    if (shouldPreventDefault) {\n\t      e.preventDefault();\n\t    }\n\n\t    if (shouldStopPropagation) {\n\t      e.stopPropagation();\n\t    }\n\n\t    view.triggerMethod(eventName, view);\n\t  };\n\t}\n\n\tvar TriggersMixin = {\n\n\t  // Configure `triggers` to forward DOM events to view\n\t  // events. `triggers: {\"click .foo\": \"do:foo\"}`\n\n\t  _getViewTriggers: function _getViewTriggers(view, triggers) {\n\t    // Configure the triggers, prevent default\n\t    // action and stop propagation of DOM events\n\t    return _.reduce(triggers, function (events, value, key) {\n\t      key = getUniqueEventName(key);\n\t      events[key] = buildViewTrigger(view, value);\n\t      return events;\n\t    }, {});\n\t  }\n\t};\n\n\t// allows for the use of the @ui. syntax within\n\t// a given key for triggers and events\n\t// swaps the @ui with the associated selector.\n\t// Returns a new, non-mutated, parsed events hash.\n\tvar _normalizeUIKeys = function _normalizeUIKeys(hash, ui) {\n\t  return _.reduce(hash, function (memo, val, key) {\n\t    var normalizedKey = normalizeUIString(key, ui);\n\t    memo[normalizedKey] = val;\n\t    return memo;\n\t  }, {});\n\t};\n\n\t// utility method for parsing @ui. syntax strings\n\t// into associated selector\n\tvar normalizeUIString = function normalizeUIString(uiString, ui) {\n\t  return uiString.replace(/@ui\\.[a-zA-Z_$0-9]*/g, function (r) {\n\t    return ui[r.slice(4)];\n\t  });\n\t};\n\n\t// allows for the use of the @ui. syntax within\n\t// a given value for regions\n\t// swaps the @ui with the associated selector\n\tvar _normalizeUIValues = function _normalizeUIValues(hash, ui, properties) {\n\t  _.each(hash, function (val, key) {\n\t    if (_.isString(val)) {\n\t      hash[key] = normalizeUIString(val, ui);\n\t    } else if (_.isObject(val) && _.isArray(properties)) {\n\t      _.extend(val, _normalizeUIValues(_.pick(val, properties), ui));\n\t      /* Value is an object, and we got an array of embedded property names to normalize. */\n\t      _.each(properties, function (property) {\n\t        var propertyVal = val[property];\n\t        if (_.isString(propertyVal)) {\n\t          val[property] = normalizeUIString(propertyVal, ui);\n\t        }\n\t      });\n\t    }\n\t  });\n\t  return hash;\n\t};\n\n\tvar UIMixin = {\n\n\t  // normalize the keys of passed hash with the views `ui` selectors.\n\t  // `{\"@ui.foo\": \"bar\"}`\n\n\t  normalizeUIKeys: function normalizeUIKeys(hash) {\n\t    var uiBindings = this._getUIBindings();\n\t    return _normalizeUIKeys(hash, uiBindings);\n\t  },\n\n\n\t  // normalize the values of passed hash with the views `ui` selectors.\n\t  // `{foo: \"@ui.bar\"}`\n\t  normalizeUIValues: function normalizeUIValues(hash, properties) {\n\t    var uiBindings = this._getUIBindings();\n\t    return _normalizeUIValues(hash, uiBindings, properties);\n\t  },\n\t  _getUIBindings: function _getUIBindings() {\n\t    var uiBindings = _.result(this, '_uiBindings');\n\t    var ui = _.result(this, 'ui');\n\t    return uiBindings || ui;\n\t  },\n\n\n\t  // This method binds the elements specified in the \"ui\" hash inside the view's code with\n\t  // the associated jQuery selectors.\n\t  _bindUIElements: function _bindUIElements() {\n\t    var _this = this;\n\n\t    if (!this.ui) {\n\t      return;\n\t    }\n\n\t    // store the ui hash in _uiBindings so they can be reset later\n\t    // and so re-rendering the view will be able to find the bindings\n\t    if (!this._uiBindings) {\n\t      this._uiBindings = this.ui;\n\t    }\n\n\t    // get the bindings result, as a function or otherwise\n\t    var bindings = _.result(this, '_uiBindings');\n\n\t    // empty the ui so we don't have anything to start with\n\t    this._ui = {};\n\n\t    // bind each of the selectors\n\t    _.each(bindings, function (selector, key) {\n\t      _this._ui[key] = _this.$(selector);\n\t    });\n\n\t    this.ui = this._ui;\n\t  },\n\t  _unbindUIElements: function _unbindUIElements() {\n\t    var _this2 = this;\n\n\t    if (!this.ui || !this._uiBindings) {\n\t      return;\n\t    }\n\n\t    // delete all of the existing ui bindings\n\t    _.each(this.ui, function ($el, name) {\n\t      delete _this2.ui[name];\n\t    });\n\n\t    // reset the ui element to the original bindings configuration\n\t    this.ui = this._uiBindings;\n\t    delete this._uiBindings;\n\t    delete this._ui;\n\t  },\n\t  _getUI: function _getUI(name) {\n\t    return this._ui[name];\n\t  }\n\t};\n\n\t// MixinOptions\n\t// - behaviors\n\t// - childViewEventPrefix\n\t// - childViewEvents\n\t// - childViewTriggers\n\t// - collectionEvents\n\t// - modelEvents\n\t// - triggers\n\t// - ui\n\n\tvar ViewMixin = {\n\t  supportsRenderLifecycle: true,\n\t  supportsDestroyLifecycle: true,\n\n\t  _isDestroyed: false,\n\n\t  isDestroyed: function isDestroyed() {\n\t    return !!this._isDestroyed;\n\t  },\n\n\n\t  _isRendered: false,\n\n\t  isRendered: function isRendered() {\n\t    return !!this._isRendered;\n\t  },\n\n\n\t  _isAttached: false,\n\n\t  isAttached: function isAttached() {\n\t    return !!this._isAttached;\n\t  },\n\n\n\t  // Overriding Backbone.View's `setElement` to handle\n\t  // if an el was previously defined. If so, the view might be\n\t  // rendered or attached on setElement.\n\t  setElement: function setElement() {\n\t    var hasEl = !!this.el;\n\n\t    Backbone.View.prototype.setElement.apply(this, arguments);\n\n\t    if (hasEl) {\n\t      this._isRendered = !!this.$el.length;\n\t      this._isAttached = isNodeAttached(this.el);\n\t    }\n\n\t    return this;\n\t  },\n\n\n\t  // Overriding Backbone.View's `delegateEvents` to handle\n\t  // `events` and `triggers`\n\t  delegateEvents: function delegateEvents(eventsArg) {\n\n\t    this._proxyBehaviorViewProperties();\n\t    this._buildEventProxies();\n\n\t    var viewEvents = this._getEvents(eventsArg);\n\n\t    if (typeof eventsArg === 'undefined') {\n\t      this.events = viewEvents;\n\t    }\n\n\t    var combinedEvents = _.extend({}, this._getBehaviorEvents(), viewEvents, this._getBehaviorTriggers(), this.getTriggers());\n\n\t    Backbone.View.prototype.delegateEvents.call(this, combinedEvents);\n\n\t    return this;\n\t  },\n\t  _getEvents: function _getEvents(eventsArg) {\n\t    var events = eventsArg || this.events;\n\n\t    if (_.isFunction(events)) {\n\t      return this.normalizeUIKeys(events());\n\t    }\n\n\t    return this.normalizeUIKeys(events);\n\t  },\n\n\n\t  // Configure `triggers` to forward DOM events to view\n\t  // events. `triggers: {\"click .foo\": \"do:foo\"}`\n\t  getTriggers: function getTriggers() {\n\t    if (!this.triggers) {\n\t      return;\n\t    }\n\n\t    // Allow `triggers` to be configured as a function\n\t    var triggers = this.normalizeUIKeys(_.result(this, 'triggers'));\n\n\t    // Configure the triggers, prevent default\n\t    // action and stop propagation of DOM events\n\t    return this._getViewTriggers(this, triggers);\n\t  },\n\n\n\t  // Handle `modelEvents`, and `collectionEvents` configuration\n\t  delegateEntityEvents: function delegateEntityEvents() {\n\t    this._delegateEntityEvents(this.model, this.collection);\n\n\t    // bind each behaviors model and collection events\n\t    this._delegateBehaviorEntityEvents();\n\n\t    return this;\n\t  },\n\n\n\t  // Handle unbinding `modelEvents`, and `collectionEvents` configuration\n\t  undelegateEntityEvents: function undelegateEntityEvents() {\n\t    this._undelegateEntityEvents(this.model, this.collection);\n\n\t    // unbind each behaviors model and collection events\n\t    this._undelegateBehaviorEntityEvents();\n\n\t    return this;\n\t  },\n\n\n\t  // Internal helper method to verify whether the view hasn't been destroyed\n\t  _ensureViewIsIntact: function _ensureViewIsIntact() {\n\t    if (this._isDestroyed) {\n\t      throw new MarionetteError({\n\t        name: 'ViewDestroyedError',\n\t        message: 'View (cid: \"' + this.cid + '\") has already been destroyed and cannot be used.'\n\t      });\n\t    }\n\t  },\n\n\n\t  // Handle destroying the view and its children.\n\t  destroy: function destroy() {\n\t    if (this._isDestroyed) {\n\t      return this;\n\t    }\n\t    var shouldTriggerDetach = !!this._isAttached;\n\n\t    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t      args[_key] = arguments[_key];\n\t    }\n\n\t    this.triggerMethod.apply(this, ['before:destroy', this].concat(args));\n\t    if (shouldTriggerDetach) {\n\t      this.triggerMethod('before:detach', this);\n\t    }\n\n\t    // unbind UI elements\n\t    this.unbindUIElements();\n\n\t    // remove the view from the DOM\n\t    // https://github.com/jashkenas/backbone/blob/1.2.3/backbone.js#L1235\n\t    this._removeElement();\n\n\t    if (shouldTriggerDetach) {\n\t      this._isAttached = false;\n\t      this.triggerMethod('detach', this);\n\t    }\n\n\t    // remove children after the remove to prevent extra paints\n\t    this._removeChildren();\n\n\t    this._destroyBehaviors(args);\n\n\t    this._isDestroyed = true;\n\t    this._isRendered = false;\n\t    this.triggerMethod.apply(this, ['destroy', this].concat(args));\n\n\t    this.stopListening();\n\n\t    return this;\n\t  },\n\t  bindUIElements: function bindUIElements() {\n\t    this._bindUIElements();\n\t    this._bindBehaviorUIElements();\n\n\t    return this;\n\t  },\n\n\n\t  // This method unbinds the elements specified in the \"ui\" hash\n\t  unbindUIElements: function unbindUIElements() {\n\t    this._unbindUIElements();\n\t    this._unbindBehaviorUIElements();\n\n\t    return this;\n\t  },\n\t  getUI: function getUI(name) {\n\t    this._ensureViewIsIntact();\n\t    return this._getUI(name);\n\t  },\n\n\n\t  // used as the prefix for child view events\n\t  // that are forwarded through the layoutview\n\t  childViewEventPrefix: 'childview',\n\n\t  // import the `triggerMethod` to trigger events with corresponding\n\t  // methods if the method exists\n\t  triggerMethod: function triggerMethod$$() {\n\t    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n\t      args[_key2] = arguments[_key2];\n\t    }\n\n\t    var ret = triggerMethod.apply(this, args);\n\n\t    this._triggerEventOnBehaviors.apply(this, args);\n\t    this._triggerEventOnParentLayout.apply(this, args);\n\n\t    return ret;\n\t  },\n\n\n\t  // Cache `childViewEvents` and `childViewTriggers`\n\t  _buildEventProxies: function _buildEventProxies() {\n\t    this._childViewEvents = _.result(this, 'childViewEvents');\n\t    this._childViewTriggers = _.result(this, 'childViewTriggers');\n\t  },\n\t  _triggerEventOnParentLayout: function _triggerEventOnParentLayout(eventName) {\n\t    var layoutView = this._parentView();\n\t    if (!layoutView) {\n\t      return;\n\t    }\n\n\t    // invoke triggerMethod on parent view\n\t    var eventPrefix = _.result(layoutView, 'childViewEventPrefix');\n\t    var prefixedEventName = eventPrefix + ':' + eventName;\n\n\t    for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n\t      args[_key3 - 1] = arguments[_key3];\n\t    }\n\n\t    layoutView.triggerMethod.apply(layoutView, [prefixedEventName].concat(args));\n\n\t    // use the parent view's childViewEvents handler\n\t    var childViewEvents = layoutView.normalizeMethods(layoutView._childViewEvents);\n\n\t    if (!!childViewEvents && _.isFunction(childViewEvents[eventName])) {\n\t      childViewEvents[eventName].apply(layoutView, args);\n\t    }\n\n\t    // use the parent view's proxyEvent handlers\n\t    var childViewTriggers = layoutView._childViewTriggers;\n\n\t    // Call the event with the proxy name on the parent layout\n\t    if (childViewTriggers && _.isString(childViewTriggers[eventName])) {\n\t      layoutView.triggerMethod.apply(layoutView, [childViewTriggers[eventName]].concat(args));\n\t    }\n\t  },\n\n\n\t  // Walk the _parent tree until we find a view (if one exists).\n\t  // Returns the parent view hierarchically closest to this view.\n\t  _parentView: function _parentView() {\n\t    var parent = this._parent;\n\n\t    while (parent) {\n\t      if (parent instanceof View) {\n\t        return parent;\n\t      }\n\t      parent = parent._parent;\n\t    }\n\t  }\n\t};\n\n\t_.extend(ViewMixin, BehaviorsMixin, CommonMixin, DelegateEntityEventsMixin, TriggersMixin, UIMixin);\n\n\tfunction destroyBackboneView(view) {\n\t  if (!view.supportsDestroyLifecycle) {\n\t    triggerMethodOn(view, 'before:destroy', view);\n\t  }\n\n\t  var shouldTriggerDetach = !!view._isAttached;\n\n\t  if (shouldTriggerDetach) {\n\t    triggerMethodOn(view, 'before:detach', view);\n\t  }\n\n\t  view.remove();\n\n\t  if (shouldTriggerDetach) {\n\t    view._isAttached = false;\n\t    triggerMethodOn(view, 'detach', view);\n\t  }\n\n\t  view._isDestroyed = true;\n\n\t  if (!view.supportsDestroyLifecycle) {\n\t    triggerMethodOn(view, 'destroy', view);\n\t  }\n\t}\n\n\tvar ClassOptions$2 = ['allowMissingEl', 'parentEl', 'replaceElement'];\n\n\tvar Region = MarionetteObject.extend({\n\t  cidPrefix: 'mnr',\n\t  replaceElement: false,\n\t  _isReplaced: false,\n\n\t  constructor: function constructor(options) {\n\t    this._setOptions(options);\n\n\t    this.mergeOptions(options, ClassOptions$2);\n\n\t    // getOption necessary because options.el may be passed as undefined\n\t    this._initEl = this.el = this.getOption('el');\n\n\t    // Handle when this.el is passed in as a $ wrapped element.\n\t    this.el = this.el instanceof Backbone.$ ? this.el[0] : this.el;\n\n\t    if (!this.el) {\n\t      throw new MarionetteError({\n\t        name: 'NoElError',\n\t        message: 'An \"el\" must be specified for a region.'\n\t      });\n\t    }\n\n\t    this.$el = this.getEl(this.el);\n\t    MarionetteObject.call(this, options);\n\t  },\n\n\n\t  // Displays a backbone view instance inside of the region. Handles calling the `render`\n\t  // method for you. Reads content directly from the `el` attribute. The `preventDestroy`\n\t  // option can be used to prevent a view from the old view being destroyed on show.\n\t  show: function show(view, options) {\n\t    if (!this._ensureElement(options)) {\n\t      return;\n\t    }\n\t    this._ensureView(view);\n\t    if (view === this.currentView) {\n\t      return this;\n\t    }\n\n\t    this.triggerMethod('before:show', this, view, options);\n\n\t    monitorViewEvents(view);\n\n\t    this.empty(options);\n\n\t    // We need to listen for if a view is destroyed in a way other than through the region.\n\t    // If this happens we need to remove the reference to the currentView since once a view\n\t    // has been destroyed we can not reuse it.\n\t    view.on('destroy', this.empty, this);\n\n\t    // Make this region the view's parent.\n\t    // It's important that this parent binding happens before rendering so that any events\n\t    // the child may trigger during render can also be triggered on the child's ancestor views.\n\t    view._parent = this;\n\n\t    this._renderView(view);\n\n\t    this._attachView(view, options);\n\n\t    this.triggerMethod('show', this, view, options);\n\t    return this;\n\t  },\n\t  _renderView: function _renderView(view) {\n\t    if (view._isRendered) {\n\t      return;\n\t    }\n\n\t    if (!view.supportsRenderLifecycle) {\n\t      triggerMethodOn(view, 'before:render', view);\n\t    }\n\n\t    view.render();\n\n\t    if (!view.supportsRenderLifecycle) {\n\t      view._isRendered = true;\n\t      triggerMethodOn(view, 'render', view);\n\t    }\n\t  },\n\t  _attachView: function _attachView(view) {\n\t    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n\t    var shouldTriggerAttach = !view._isAttached && isNodeAttached(this.el);\n\t    var shouldReplaceEl = typeof options.replaceElement === 'undefined' ? !!_.result(this, 'replaceElement') : !!options.replaceElement;\n\n\t    if (shouldTriggerAttach) {\n\t      triggerMethodOn(view, 'before:attach', view);\n\t    }\n\n\t    this.attachHtml(view, shouldReplaceEl);\n\n\t    if (shouldTriggerAttach) {\n\t      view._isAttached = true;\n\t      triggerMethodOn(view, 'attach', view);\n\t    }\n\n\t    this.currentView = view;\n\t  },\n\t  _ensureElement: function _ensureElement() {\n\t    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n\t    if (!_.isObject(this.el)) {\n\t      this.$el = this.getEl(this.el);\n\t      this.el = this.$el[0];\n\t    }\n\n\t    if (!this.$el || this.$el.length === 0) {\n\t      var allowMissingEl = typeof options.allowMissingEl === 'undefined' ? !!_.result(this, 'allowMissingEl') : !!options.allowMissingEl;\n\n\t      if (allowMissingEl) {\n\t        return false;\n\t      } else {\n\t        throw new MarionetteError('An \"el\" must exist in DOM for this region ' + this.cid);\n\t      }\n\t    }\n\t    return true;\n\t  },\n\t  _ensureView: function _ensureView(view) {\n\t    if (!view) {\n\t      throw new MarionetteError({\n\t        name: 'ViewNotValid',\n\t        message: 'The view passed is undefined and therefore invalid. You must pass a view instance to show.'\n\t      });\n\t    }\n\n\t    if (view._isDestroyed) {\n\t      throw new MarionetteError({\n\t        name: 'ViewDestroyedError',\n\t        message: 'View (cid: \"' + view.cid + '\") has already been destroyed and cannot be used.'\n\t      });\n\t    }\n\t  },\n\n\n\t  // Override this method to change how the region finds the DOM element that it manages. Return\n\t  // a jQuery selector object scoped to a provided parent el or the document if none exists.\n\t  getEl: function getEl(el) {\n\t    return Backbone.$(el, _.result(this, 'parentEl'));\n\t  },\n\t  _replaceEl: function _replaceEl(view) {\n\t    // always restore the el to ensure the regions el is present before replacing\n\t    this._restoreEl();\n\n\t    var parent = this.el.parentNode;\n\n\t    parent.replaceChild(view.el, this.el);\n\t    this._isReplaced = true;\n\t  },\n\n\n\t  // Restore the region's element in the DOM.\n\t  _restoreEl: function _restoreEl() {\n\t    if (!this.currentView) {\n\t      return;\n\t    }\n\n\t    var view = this.currentView;\n\t    var parent = view.el.parentNode;\n\n\t    if (!parent) {\n\t      return;\n\t    }\n\n\t    parent.replaceChild(this.el, view.el);\n\t    this._isReplaced = false;\n\t  },\n\t  isReplaced: function isReplaced() {\n\t    return !!this._isReplaced;\n\t  },\n\n\n\t  // Override this method to change how the new view is appended to the `$el` that the\n\t  // region is managing\n\t  attachHtml: function attachHtml(view, shouldReplace) {\n\t    if (shouldReplace) {\n\t      // replace the region's node with the view's node\n\t      this._replaceEl(view);\n\t    } else {\n\t      this.el.appendChild(view.el);\n\t    }\n\t  },\n\n\n\t  // Destroy the current view, if there is one. If there is no current view, it does\n\t  // nothing and returns immediately.\n\t  empty: function empty() {\n\t    var options = arguments.length <= 0 || arguments[0] === undefined ? { allowMissingEl: true } : arguments[0];\n\n\t    var view = this.currentView;\n\n\t    // If there is no view in the region we should only detach current html\n\t    if (!view) {\n\t      if (this._ensureElement(options)) {\n\t        this.detachHtml();\n\t      }\n\t      return this;\n\t    }\n\n\t    view.off('destroy', this.empty, this);\n\t    this.triggerMethod('before:empty', this, view);\n\n\t    if (this._isReplaced) {\n\t      this._restoreEl();\n\t    }\n\n\t    delete this.currentView;\n\n\t    if (!view._isDestroyed) {\n\t      this._removeView(view, options);\n\t      delete view._parent;\n\t    }\n\n\t    this.triggerMethod('empty', this, view);\n\t    return this;\n\t  },\n\t  _removeView: function _removeView(view) {\n\t    var _ref = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n\t    var preventDestroy = _ref.preventDestroy;\n\n\t    var shouldPreventDestroy = !!preventDestroy;\n\n\t    if (shouldPreventDestroy) {\n\t      this._detachView(view);\n\t      return;\n\t    }\n\n\t    if (view.destroy) {\n\t      view.destroy();\n\t    } else {\n\t      destroyBackboneView(view);\n\t    }\n\t  },\n\t  _detachView: function _detachView(view) {\n\t    var shouldTriggerDetach = !!view._isAttached;\n\t    if (shouldTriggerDetach) {\n\t      triggerMethodOn(view, 'before:detach', view);\n\t    }\n\n\t    this.detachHtml();\n\n\t    if (shouldTriggerDetach) {\n\t      view._isAttached = false;\n\t      triggerMethodOn(view, 'detach', view);\n\t    }\n\t  },\n\n\n\t  // Override this method to change how the region detaches current content\n\t  detachHtml: function detachHtml() {\n\t    this.$el.contents().detach();\n\t  },\n\n\n\t  // Checks whether a view is currently present within the region. Returns `true` if there is\n\t  // and `false` if no view is present.\n\t  hasView: function hasView() {\n\t    return !!this.currentView;\n\t  },\n\n\n\t  // Reset the region by destroying any existing view and clearing out the cached `$el`.\n\t  // The next time a view is shown via this region, the region will re-query the DOM for\n\t  // the region's `el`.\n\t  reset: function reset(options) {\n\t    this.empty(options);\n\n\t    if (this.$el) {\n\t      this.el = this._initEl;\n\t    }\n\n\t    delete this.$el;\n\t    return this;\n\t  },\n\t  destroy: function destroy(options) {\n\t    this.reset(options);\n\t    return MarionetteObject.prototype.destroy.apply(this, arguments);\n\t  }\n\t});\n\n\t// MixinOptions\n\t// - regions\n\t// - regionClass\n\n\tvar RegionsMixin = {\n\t  regionClass: Region,\n\n\t  // Internal method to initialize the regions that have been defined in a\n\t  // `regions` attribute on this View.\n\t  _initRegions: function _initRegions() {\n\n\t    // init regions hash\n\t    this.regions = this.regions || {};\n\t    this._regions = {};\n\n\t    this.addRegions(_.result(this, 'regions'));\n\t  },\n\n\n\t  // Internal method to re-initialize all of the regions by updating\n\t  // the `el` that they point to\n\t  _reInitRegions: function _reInitRegions() {\n\t    _invoke(this._regions, 'reset');\n\t  },\n\n\n\t  // Add a single region, by name, to the View\n\t  addRegion: function addRegion(name, definition) {\n\t    var regions = {};\n\t    regions[name] = definition;\n\t    return this.addRegions(regions)[name];\n\t  },\n\n\n\t  // Add multiple regions as a {name: definition, name2: def2} object literal\n\t  addRegions: function addRegions(regions) {\n\t    // If there's nothing to add, stop here.\n\t    if (_.isEmpty(regions)) {\n\t      return;\n\t    }\n\n\t    // Normalize region selectors hash to allow\n\t    // a user to use the @ui. syntax.\n\t    regions = this.normalizeUIValues(regions, ['selector', 'el']);\n\n\t    // Add the regions definitions to the regions property\n\t    this.regions = _.extend({}, this.regions, regions);\n\n\t    return this._addRegions(regions);\n\t  },\n\n\n\t  // internal method to build and add regions\n\t  _addRegions: function _addRegions(regionDefinitions) {\n\t    var _this = this;\n\n\t    return _.reduce(regionDefinitions, function (regions, definition, name) {\n\t      regions[name] = _this._buildRegion(definition);\n\t      _this._addRegion(regions[name], name);\n\t      return regions;\n\t    }, {});\n\t  },\n\n\n\t  // return the region instance from the definition\n\t  _buildRegion: function _buildRegion(definition) {\n\t    if (definition instanceof Region) {\n\t      return definition;\n\t    }\n\n\t    return this._buildRegionFromDefinition(definition);\n\t  },\n\t  _buildRegionFromDefinition: function _buildRegionFromDefinition(definition) {\n\t    if (_.isString(definition)) {\n\t      return this._buildRegionFromObject({ el: definition });\n\t    }\n\n\t    if (_.isFunction(definition)) {\n\t      return this._buildRegionFromRegionClass(definition);\n\t    }\n\n\t    if (_.isObject(definition)) {\n\t      return this._buildRegionFromObject(definition);\n\t    }\n\n\t    throw new MarionetteError({\n\t      message: 'Improper region configuration type.',\n\t      url: 'marionette.region.html#region-configuration-types'\n\t    });\n\t  },\n\t  _buildRegionFromObject: function _buildRegionFromObject(definition) {\n\t    var RegionClass = definition.regionClass || this.regionClass;\n\n\t    var options = _.omit(definition, 'regionClass');\n\n\t    _.defaults(options, {\n\t      el: definition.selector,\n\t      parentEl: _.partial(_.result, this, 'el')\n\t    });\n\n\t    return new RegionClass(options);\n\t  },\n\n\n\t  // Build the region directly from a given `RegionClass`\n\t  _buildRegionFromRegionClass: function _buildRegionFromRegionClass(RegionClass) {\n\t    return new RegionClass({\n\t      parentEl: _.partial(_.result, this, 'el')\n\t    });\n\t  },\n\t  _addRegion: function _addRegion(region, name) {\n\t    this.triggerMethod('before:add:region', this, name, region);\n\n\t    region._parent = this;\n\n\t    this._regions[name] = region;\n\n\t    this.triggerMethod('add:region', this, name, region);\n\t  },\n\n\n\t  // Remove a single region from the View, by name\n\t  removeRegion: function removeRegion(name) {\n\t    var region = this._regions[name];\n\n\t    this._removeRegion(region, name);\n\n\t    return region;\n\t  },\n\n\n\t  // Remove all regions from the View\n\t  removeRegions: function removeRegions() {\n\t    var regions = this.getRegions();\n\n\t    _.each(this._regions, _.bind(this._removeRegion, this));\n\n\t    return regions;\n\t  },\n\t  _removeRegion: function _removeRegion(region, name) {\n\t    this.triggerMethod('before:remove:region', this, name, region);\n\n\t    region.empty();\n\t    region.stopListening();\n\n\t    delete this.regions[name];\n\t    delete this._regions[name];\n\n\t    this.triggerMethod('remove:region', this, name, region);\n\t  },\n\n\n\t  // Empty all regions in the region manager, but\n\t  // leave them attached\n\t  emptyRegions: function emptyRegions() {\n\t    var regions = this.getRegions();\n\t    _invoke(regions, 'empty');\n\t    return regions;\n\t  },\n\n\n\t  // Checks to see if view contains region\n\t  // Accepts the region name\n\t  // hasRegion('main')\n\t  hasRegion: function hasRegion(name) {\n\t    return !!this.getRegion(name);\n\t  },\n\n\n\t  // Provides access to regions\n\t  // Accepts the region name\n\t  // getRegion('main')\n\t  getRegion: function getRegion(name) {\n\t    return this._regions[name];\n\t  },\n\n\n\t  // Get all regions\n\t  getRegions: function getRegions() {\n\t    return _.clone(this._regions);\n\t  },\n\t  showChildView: function showChildView(name, view) {\n\t    var region = this.getRegion(name);\n\n\t    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n\t      args[_key - 2] = arguments[_key];\n\t    }\n\n\t    return region.show.apply(region, [view].concat(args));\n\t  },\n\t  getChildView: function getChildView(name) {\n\t    return this.getRegion(name).currentView;\n\t  }\n\t};\n\n\t// Render a template with data by passing in the template\n\t// selector and the data to render.\n\tvar Renderer = {\n\n\t  // Render a template with data. The `template` parameter is\n\t  // passed to the `TemplateCache` object to retrieve the\n\t  // template function. Override this method to provide your own\n\t  // custom rendering and template handling for all of Marionette.\n\n\t  render: function render(template, data) {\n\t    if (!template) {\n\t      throw new MarionetteError({\n\t        name: 'TemplateNotFoundError',\n\t        message: 'Cannot render the template since its false, null or undefined.'\n\t      });\n\t    }\n\n\t    var templateFunc = _.isFunction(template) ? template : TemplateCache.get(template);\n\n\t    return templateFunc(data);\n\t  }\n\t};\n\n\tvar ClassOptions$1 = ['behaviors', 'childViewEventPrefix', 'childViewEvents', 'childViewTriggers', 'collectionEvents', 'events', 'modelEvents', 'regionClass', 'regions', 'template', 'templateContext', 'triggers', 'ui'];\n\n\t// The standard view. Includes view events, automatic rendering\n\t// of Underscore templates, nested views, and more.\n\tvar View = Backbone.View.extend({\n\t  constructor: function constructor(options) {\n\t    this.render = _.bind(this.render, this);\n\n\t    this._setOptions(options);\n\n\t    this.mergeOptions(options, ClassOptions$1);\n\n\t    monitorViewEvents(this);\n\n\t    this._initBehaviors();\n\t    this._initRegions();\n\n\t    var args = Array.prototype.slice.call(arguments);\n\t    args[0] = this.options;\n\t    Backbone.View.prototype.constructor.apply(this, args);\n\n\t    this.delegateEntityEvents();\n\t  },\n\n\n\t  // Serialize the view's model *or* collection, if\n\t  // it exists, for the template\n\t  serializeData: function serializeData() {\n\t    if (!this.model && !this.collection) {\n\t      return {};\n\t    }\n\n\t    // If we have a model, we serialize that\n\t    if (this.model) {\n\t      return this.serializeModel();\n\t    }\n\n\t    // Otherwise, we serialize the collection,\n\t    // making it available under the `items` property\n\t    return {\n\t      items: this.serializeCollection()\n\t    };\n\t  },\n\n\n\t  // Prepares the special `model` property of a view\n\t  // for being displayed in the template. By default\n\t  // we simply clone the attributes. Override this if\n\t  // you need a custom transformation for your view's model\n\t  serializeModel: function serializeModel() {\n\t    if (!this.model) {\n\t      return {};\n\t    }\n\t    return _.clone(this.model.attributes);\n\t  },\n\n\n\t  // Serialize a collection by cloning each of\n\t  // its model's attributes\n\t  serializeCollection: function serializeCollection() {\n\t    if (!this.collection) {\n\t      return {};\n\t    }\n\t    return this.collection.map(function (model) {\n\t      return _.clone(model.attributes);\n\t    });\n\t  },\n\n\n\t  // Render the view, defaulting to underscore.js templates.\n\t  // You can override this in your view definition to provide\n\t  // a very specific rendering for your view. In general, though,\n\t  // you should override the `Marionette.Renderer` object to\n\t  // change how Marionette renders views.\n\t  // Subsequent renders after the first will re-render all nested\n\t  // views.\n\t  render: function render() {\n\t    this._ensureViewIsIntact();\n\n\t    this.triggerMethod('before:render', this);\n\n\t    // If this is not the first render call, then we need to\n\t    // re-initialize the `el` for each region\n\t    if (this._isRendered) {\n\t      this._reInitRegions();\n\t    }\n\n\t    this._renderTemplate();\n\t    this.bindUIElements();\n\n\t    this._isRendered = true;\n\t    this.triggerMethod('render', this);\n\n\t    return this;\n\t  },\n\n\n\t  // Internal method to render the template with the serialized data\n\t  // and template context via the `Marionette.Renderer` object.\n\t  _renderTemplate: function _renderTemplate() {\n\t    var template = this.getTemplate();\n\n\t    // Allow template-less views\n\t    if (template === false) {\n\t      return;\n\t    }\n\n\t    // Add in entity data and template context\n\t    var data = this.mixinTemplateContext(this.serializeData());\n\n\t    // Render and add to el\n\t    var html = Renderer.render(template, data, this);\n\t    this.attachElContent(html);\n\t  },\n\n\n\t  // Get the template for this view\n\t  // instance. You can set a `template` attribute in the view\n\t  // definition or pass a `template: \"whatever\"` parameter in\n\t  // to the constructor options.\n\t  getTemplate: function getTemplate() {\n\t    return this.template;\n\t  },\n\n\n\t  // Mix in template context methods. Looks for a\n\t  // `templateContext` attribute, which can either be an\n\t  // object literal, or a function that returns an object\n\t  // literal. All methods and attributes from this object\n\t  // are copies to the object passed in.\n\t  mixinTemplateContext: function mixinTemplateContext() {\n\t    var target = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n\t    var templateContext = _.result(this, 'templateContext');\n\t    return _.extend(target, templateContext);\n\t  },\n\n\n\t  // Attaches the content of a given view.\n\t  // This method can be overridden to optimize rendering,\n\t  // or to render in a non standard way.\n\t  //\n\t  // For example, using `innerHTML` instead of `$el.html`\n\t  //\n\t  // ```js\n\t  // attachElContent(html) {\n\t  //   this.el.innerHTML = html;\n\t  //   return this;\n\t  // }\n\t  // ```\n\t  attachElContent: function attachElContent(html) {\n\t    this.$el.html(html);\n\n\t    return this;\n\t  },\n\n\n\t  // called by ViewMixin destroy\n\t  _removeChildren: function _removeChildren() {\n\t    this.removeRegions();\n\t  },\n\t  _getImmediateChildren: function _getImmediateChildren() {\n\t    return _.chain(this.getRegions()).map('currentView').compact().value();\n\t  }\n\t});\n\n\t_.extend(View.prototype, ViewMixin, RegionsMixin);\n\n\tvar backbone_babysitter = __commonjs(function (module, exports, global) {\n\t// Backbone.BabySitter\n\t// -------------------\n\t// v1.0.0-pre.1\n\t//\n\t// Copyright (c)2016 Derick Bailey, Muted Solutions, LLC.\n\t// Distributed under MIT license\n\t//\n\t// http://github.com/marionettejs/backbone.babysitter\n\n\t(function(root, factory) {\n\n\t  if (typeof define === 'function' && define.amd) {\n\t    define(['backbone', 'underscore'], function(Backbone$$, _$$) {\n\t      return factory(Backbone$$, _$$);\n\t    });\n\t  } else if (typeof exports !== 'undefined') {\n\t    var Backbone$$ = Backbone;\n\t    var _$$ = _;\n\t    module.exports = factory(Backbone$$, _$$);\n\t  } else {\n\t    factory(root.Backbone, root._);\n\t  }\n\n\t}(__commonjs_global, function(Backbone$$, _$$) {\n\t  'use strict';\n\n\t  var previousChildViewContainer = Backbone$$.ChildViewContainer;\n\n\t  // BabySitter.ChildViewContainer\n\t  // -----------------------------\n\t  //\n\t  // Provide a container to store, retrieve and\n\t  // shut down child views.\n\t  \n\t  Backbone$$.ChildViewContainer = (function (Backbone$$, _$$) {\n\t  \n\t    // Container Constructor\n\t    // ---------------------\n\t  \n\t    var Container = function(views){\n\t      this._views = {};\n\t      this._indexByModel = {};\n\t      this._indexByCustom = {};\n\t      this._updateLength();\n\t  \n\t      _$$.each(views, _$$.bind(this.add, this));\n\t    };\n\t  \n\t    // Container Methods\n\t    // -----------------\n\t  \n\t    _$$.extend(Container.prototype, {\n\t  \n\t      // Add a view to this container. Stores the view\n\t      // by `cid` and makes it searchable by the model\n\t      // cid (and model itself). Optionally specify\n\t      // a custom key to store an retrieve the view.\n\t      add: function(view, customIndex){\n\t        return this._add(view, customIndex)\n\t                   ._updateLength();\n\t      },\n\t  \n\t      // Find a view by the model that was attached to\n\t      // it. Uses the model's `cid` to find it.\n\t      findByModel: function(model){\n\t        return this.findByModelCid(model.cid);\n\t      },\n\t  \n\t      // Find a view by the `cid` of the model that was attached to\n\t      // it. Uses the model's `cid` to find the view `cid` and\n\t      // retrieve the view using it.\n\t      findByModelCid: function(modelCid){\n\t        var viewCid = this._indexByModel[modelCid];\n\t        return this.findByCid(viewCid);\n\t      },\n\t  \n\t      // Find a view by a custom indexer.\n\t      findByCustom: function(index){\n\t        var viewCid = this._indexByCustom[index];\n\t        return this.findByCid(viewCid);\n\t      },\n\t  \n\t      // Find by index. This is not guaranteed to be a\n\t      // stable index.\n\t      findByIndex: function(index){\n\t        return _$$.values(this._views)[index];\n\t      },\n\t  \n\t      // retrieve a view by its `cid` directly\n\t      findByCid: function(cid){\n\t        return this._views[cid];\n\t      },\n\t  \n\t      // Remove a view\n\t      remove: function(view){\n\t        return this._remove(view)\n\t                   ._updateLength();\n\t      },\n\t  \n\t      // Call a method on every view in the container,\n\t      // passing parameters to the call method one at a\n\t      // time, like `function.call`.\n\t      call: function(method){\n\t        this.apply(method, _$$.toArray(arguments).slice(1));\n\t      },\n\t  \n\t      // Apply a method on every view in the container,\n\t      // passing parameters to the call method one at a\n\t      // time, like `function.apply`.\n\t      apply: function(method, args){\n\t        _$$.each(this._views, function(view){\n\t          if (_$$.isFunction(view[method])){\n\t            view[method].apply(view, args || []);\n\t          }\n\t        });\n\t      },\n\t  \n\t      // Update the `.length` attribute on this container\n\t      _updateLength: function(){\n\t        this.length = _$$.size(this._views);\n\t  \n\t        return this;\n\t      },\n\t      // To be used when avoiding call _updateLength\n\t      // When you are done adding all your new views\n\t      // call _updateLength\n\t      _add: function(view, customIndex){\n\t        var viewCid = view.cid;\n\t  \n\t        // store the view\n\t        this._views[viewCid] = view;\n\t  \n\t        // index it by model\n\t        if (view.model){\n\t          this._indexByModel[view.model.cid] = viewCid;\n\t        }\n\t  \n\t        // index by custom\n\t        if (customIndex){\n\t          this._indexByCustom[customIndex] = viewCid;\n\t        }\n\t  \n\t        return this;\n\t      },\n\t      // To be used when avoiding call _updateLength\n\t      // When you are done adding all your new views\n\t      // call _updateLength\n\t      _remove: function (view){\n\t        var viewCid = view.cid;\n\t  \n\t        // delete model index\n\t        if (view.model){\n\t          delete this._indexByModel[view.model.cid];\n\t        }\n\t  \n\t        // delete custom index\n\t        _$$.some(this._indexByCustom, _$$.bind(function(cid, key) {\n\t          if (cid === viewCid) {\n\t            delete this._indexByCustom[key];\n\t            return true;\n\t          }\n\t        }, this));\n\t  \n\t        // remove the view from the container\n\t        delete this._views[viewCid];\n\t  \n\t        return this;\n\t      }\n\t    });\n\t  \n\t    // Borrowing this code from Backbone.Collection:\n\t    // http://backbonejs.org/docs/backbone.html#section-106\n\t    //\n\t    // Mix in methods from Underscore, for iteration, and other\n\t    // collection related features.\n\t    var methods = ['forEach', 'each', 'map', 'find', 'detect', 'filter',\n\t      'select', 'reject', 'every', 'all', 'some', 'any', 'include',\n\t      'contains', 'invoke', 'toArray', 'first', 'initial', 'rest',\n\t      'last', 'without', 'isEmpty', 'pluck', 'reduce'];\n\t  \n\t    _$$.each(methods, function(method) {\n\t      Container.prototype[method] = function() {\n\t        var views = _$$.values(this._views);\n\t        var args = [views].concat(_$$.toArray(arguments));\n\t        return _$$[method].apply(_$$, args);\n\t      };\n\t    });\n\t  \n\t    // return the public API\n\t    return Container;\n\t  })(Backbone$$, _$$);\n\t  \n\n\t  Backbone$$.ChildViewContainer.VERSION = '1.0.0-pre.1';\n\n\t  Backbone$$.ChildViewContainer.noConflict = function () {\n\t    Backbone$$.ChildViewContainer = previousChildViewContainer;\n\t    return this;\n\t  };\n\n\t  return Backbone$$.ChildViewContainer;\n\n\t}));\n\t});\n\n\tvar ChildViewContainer = (backbone_babysitter && typeof backbone_babysitter === 'object' && 'default' in backbone_babysitter ? backbone_babysitter['default'] : backbone_babysitter);\n\n\tvar ClassOptions$3 = ['behaviors', 'childView', 'childViewEventPrefix', 'childViewEvents', 'childViewOptions', 'childViewTriggers', 'collectionEvents', 'events', 'filter', 'emptyView', 'emptyViewOptions', 'modelEvents', 'reorderOnSort', 'sort', 'triggers', 'ui', 'viewComparator'];\n\n\t// A view that iterates over a Backbone.Collection\n\t// and renders an individual child view for each model.\n\tvar CollectionView = Backbone.View.extend({\n\n\t  // flag for maintaining the sorted order of the collection\n\t  sort: true,\n\n\t  // constructor\n\t  // option to pass `{sort: false}` to prevent the `CollectionView` from\n\t  // maintaining the sorted order of the collection.\n\t  // This will fallback onto appending childView's to the end.\n\t  //\n\t  // option to pass `{viewComparator: compFunction()}` to allow the `CollectionView`\n\t  // to use a custom sort order for the collection.\n\t  constructor: function constructor(options) {\n\t    this.render = _.bind(this.render, this);\n\n\t    this._setOptions(options);\n\n\t    this.mergeOptions(options, ClassOptions$3);\n\n\t    monitorViewEvents(this);\n\n\t    this._initBehaviors();\n\t    this.once('render', this._initialEvents);\n\t    this._initChildViewStorage();\n\t    this._bufferedChildren = [];\n\n\t    var args = Array.prototype.slice.call(arguments);\n\t    args[0] = this.options;\n\t    Backbone.View.prototype.constructor.apply(this, args);\n\n\t    this.delegateEntityEvents();\n\t  },\n\n\n\t  // Instead of inserting elements one by one into the page, it's much more performant to insert\n\t  // elements into a document fragment and then insert that document fragment into the page\n\t  _startBuffering: function _startBuffering() {\n\t    this._isBuffering = true;\n\t  },\n\t  _endBuffering: function _endBuffering() {\n\t    var shouldTriggerAttach = !!this._isAttached;\n\t    var triggerOnChildren = shouldTriggerAttach ? this._getImmediateChildren() : [];\n\n\t    this._isBuffering = false;\n\n\t    _.each(triggerOnChildren, function (child) {\n\t      triggerMethodOn(child, 'before:attach', child);\n\t    });\n\n\t    this.attachBuffer(this, this._createBuffer());\n\n\t    _.each(triggerOnChildren, function (child) {\n\t      child._isAttached = true;\n\t      triggerMethodOn(child, 'attach', child);\n\t    });\n\n\t    this._bufferedChildren = [];\n\t  },\n\t  _getImmediateChildren: function _getImmediateChildren() {\n\t    return _.values(this.children._views);\n\t  },\n\n\n\t  // Configured the initial events that the collection view binds to.\n\t  _initialEvents: function _initialEvents() {\n\t    if (this.collection) {\n\t      this.listenTo(this.collection, 'add', this._onCollectionAdd);\n\t      this.listenTo(this.collection, 'update', this._onCollectionUpdate);\n\t      this.listenTo(this.collection, 'reset', this.render);\n\n\t      if (this.sort) {\n\t        this.listenTo(this.collection, 'sort', this._sortViews);\n\t      }\n\t    }\n\t  },\n\n\n\t  // Handle a child added to the collection\n\t  _onCollectionAdd: function _onCollectionAdd(child, collection, opts) {\n\t    // `index` is present when adding with `at` since BB 1.2; indexOf fallback for < 1.2\n\t    var index = opts.at !== undefined && (opts.index || collection.indexOf(child));\n\n\t    // When filtered or when there is no initial index, calculate index.\n\t    if (this.filter || index === false) {\n\t      index = _.indexOf(this._filteredSortedModels(index), child);\n\t    }\n\n\t    if (this._shouldAddChild(child, index)) {\n\t      this._destroyEmptyView();\n\t      var ChildView = this._getChildView(child);\n\t      this._addChild(child, ChildView, index);\n\t    }\n\t  },\n\n\n\t  // Handle collection update model removals\n\t  _onCollectionUpdate: function _onCollectionUpdate(collection, options) {\n\t    var removed = options.changes.removed;\n\t    var isRemoving = _.isArray(removed) && removed.length;\n\n\t    if (isRemoving) {\n\t      this._removeChildViews(removed);\n\t    }\n\t  },\n\n\n\t  // Remove the child views and destroy them.\n\t  // This function also updates the indices of later views\n\t  // in the collection in order to keep the children in sync with the collection.\n\t  // Return array of views where the first view has the index that\n\t  // tells CollectionView#_updateIndices where to start syncing remaining\n\t  // view indices.\n\t  _removeChildViews: function _removeChildViews(modelsOrViews) {\n\t    var _this = this;\n\n\t    var _ref = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n\t    var checkEmpty = _ref.checkEmpty;\n\n\t    if (!modelsOrViews.length) {\n\t      return modelsOrViews;\n\t    }\n\n\t    var shouldCheckEmpty = checkEmpty !== false;\n\n\t    // Used to determine where to update the remaining\n\t    // sibling view indices after these views are removed.\n\t    var removedViews = _.reduce(modelsOrViews, function (removingViews, modelOrView) {\n\t      var view = modelOrView;\n\n\t      if (modelOrView instanceof Backbone.Model) {\n\t        view = _this.children.findByModel(modelOrView);\n\t      }\n\n\t      if (!view || view._isDestroyed) {\n\t        return removingViews;\n\t      }\n\n\t      if (!removingViews.length || removingViews[0]._index > view._index) {\n\t        removingViews.unshift(view);\n\t      }\n\n\t      _this.triggerMethod('before:remove:child', _this, view);\n\n\t      // everything after this could be async destructed\n\t      _this.children._remove(view);\n\t      if (view.destroy) {\n\t        view.destroy();\n\t      } else {\n\t        destroyBackboneView(view);\n\t      }\n\n\t      view._parent = void 0;\n\t      _this.stopListening(view);\n\t      _this.triggerMethod('remove:child', _this, view);\n\n\t      return removingViews;\n\t    }, []);\n\n\t    if (!removedViews.length) {\n\t      return removedViews;\n\t    }\n\n\t    this.children._updateLength();\n\t    // decrement the index of views after this one\n\t    this._updateIndices(removedViews[0], false);\n\n\t    if (shouldCheckEmpty) {\n\t      this._checkEmpty();\n\t    }\n\n\t    return removedViews;\n\t  },\n\n\n\t  // Render children views. Override this method to provide your own implementation of a\n\t  // render function for the collection view.\n\t  render: function render() {\n\t    this._ensureViewIsIntact();\n\t    this.triggerMethod('before:render', this);\n\t    this._renderChildren();\n\t    this._isRendered = true;\n\t    this.triggerMethod('render', this);\n\t    return this;\n\t  },\n\n\n\t  // An efficient rendering used for filtering. Instead of modifying the whole DOM for the\n\t  // collection view, we are only adding or removing the related childrenViews.\n\t  setFilter: function setFilter(filter) {\n\t    var _ref2 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n\t    var preventRender = _ref2.preventRender;\n\n\t    var canBeRendered = this._isRendered && !this._isDestroyed;\n\t    var filterChanged = this.filter !== filter;\n\t    var shouldRender = canBeRendered && filterChanged && !preventRender;\n\n\t    if (shouldRender) {\n\t      var previousModels = this._filteredSortedModels();\n\t      this.filter = filter;\n\t      var models = this._filteredSortedModels();\n\t      this._applyModelDeltas(models, previousModels);\n\t    } else {\n\t      this.filter = filter;\n\t    }\n\t    return this;\n\t  },\n\n\n\t  // `removeFilter` is actually an alias for removing filters.\n\t  removeFilter: function removeFilter(options) {\n\t    this.setFilter(null, options);\n\t    return this;\n\t  },\n\n\n\t  // Calculate and apply difference by cid between `models` and `previousModels`.\n\t  _applyModelDeltas: function _applyModelDeltas(models, previousModels) {\n\t    var _this2 = this;\n\n\t    var currentIds = {};\n\t    _.each(models, function (model, index) {\n\t      var addedChildNotExists = !_this2.children.findByModel(model);\n\t      if (addedChildNotExists) {\n\t        _this2._onCollectionAdd(model, _this2.collection, { at: index });\n\t      }\n\t      currentIds[model.cid] = true;\n\t    });\n\n\t    var removeModel = _.filter(previousModels, function (prevModel) {\n\t      return !currentIds[prevModel.cid] && _this2.children.findByModel(prevModel);\n\t    });\n\n\t    this._removeChildViews(removeModel);\n\t  },\n\n\n\t  // Reorder DOM after sorting. When your element's rendering do not use their index,\n\t  // you can pass reorderOnSort: true to only reorder the DOM after a sort instead of\n\t  // rendering all the collectionView.\n\t  reorder: function reorder() {\n\t    var _this3 = this;\n\n\t    var children = this.children;\n\t    var models = this._filteredSortedModels();\n\n\t    if (!models.length && this._showingEmptyView) {\n\t      return this;\n\t    }\n\n\t    var anyModelsAdded = _.some(models, function (model) {\n\t      return !children.findByModel(model);\n\t    });\n\n\t    // If there are any new models added due to filtering we need to add child views,\n\t    // so render as normal.\n\t    if (anyModelsAdded) {\n\t      this.render();\n\t    } else {\n\t      (function () {\n\t        // Get the DOM nodes in the same order as the models.\n\t        var elsToReorder = _.map(models, function (model, index) {\n\t          var view = children.findByModel(model);\n\t          view._index = index;\n\t          return view.el;\n\t        });\n\n\t        // Find the views that were children before but aren't in this new ordering.\n\t        var filteredOutViews = children.filter(function (view) {\n\t          return !_.contains(elsToReorder, view.el);\n\t        });\n\n\t        _this3.triggerMethod('before:reorder', _this3);\n\n\t        // Since append moves elements that are already in the DOM, appending the elements\n\t        // will effectively reorder them.\n\t        _this3._appendReorderedChildren(elsToReorder);\n\n\t        // remove any views that have been filtered out\n\t        _this3._removeChildViews(filteredOutViews);\n\n\t        _this3.triggerMethod('reorder', _this3);\n\t      })();\n\t    }\n\t    return this;\n\t  },\n\n\n\t  // Render view after sorting. Override this method to change how the view renders\n\t  // after a `sort` on the collection.\n\t  resortView: function resortView() {\n\t    if (this.reorderOnSort) {\n\t      this.reorder();\n\t    } else {\n\t      this._renderChildren();\n\t    }\n\t    return this;\n\t  },\n\n\n\t  // Internal method. This checks for any changes in the order of the collection.\n\t  // If the index of any view doesn't match, it will render.\n\t  _sortViews: function _sortViews() {\n\t    var _this4 = this;\n\n\t    var models = this._filteredSortedModels();\n\n\t    // check for any changes in sort order of views\n\t    var orderChanged = _.find(models, function (item, index) {\n\t      var view = _this4.children.findByModel(item);\n\t      return !view || view._index !== index;\n\t    });\n\n\t    if (orderChanged) {\n\t      this.resortView();\n\t    }\n\t  },\n\n\n\t  // Internal reference to what index a `emptyView` is.\n\t  _emptyViewIndex: -1,\n\n\t  // Internal method. Separated so that CompositeView can append to the childViewContainer\n\t  // if necessary\n\t  _appendReorderedChildren: function _appendReorderedChildren(children) {\n\t    this.$el.append(children);\n\t  },\n\n\n\t  // Internal method. Separated so that CompositeView can have more control over events\n\t  // being triggered, around the rendering process\n\t  _renderChildren: function _renderChildren() {\n\t    if (this._isRendered) {\n\t      this._destroyEmptyView();\n\t      this._destroyChildren({ checkEmpty: false });\n\t    }\n\n\t    var models = this._filteredSortedModels();\n\t    if (this.isEmpty({ processedModels: models })) {\n\t      this._showEmptyView();\n\t    } else {\n\t      this.triggerMethod('before:render:children', this);\n\t      this._startBuffering();\n\t      this._showCollection(models);\n\t      this._endBuffering();\n\t      this.triggerMethod('render:children', this);\n\t    }\n\t  },\n\n\n\t  // Internal method to loop through collection and show each child view.\n\t  _showCollection: function _showCollection(models) {\n\t    var _this5 = this;\n\n\t    _.each(models, function (child, index) {\n\t      var ChildView = _this5._getChildView(child);\n\t      _this5._addChild(child, ChildView, index);\n\t    });\n\t  },\n\n\n\t  // Allow the collection to be sorted by a custom view comparator\n\t  _filteredSortedModels: function _filteredSortedModels(addedAt) {\n\t    if (!this.collection) {\n\t      return [];\n\t    }\n\n\t    var viewComparator = this.getViewComparator();\n\t    var models = this.collection.models;\n\t    addedAt = Math.min(Math.max(addedAt, 0), models.length - 1);\n\n\t    if (viewComparator) {\n\t      var addedModel = void 0;\n\t      // Preserve `at` location, even for a sorted view\n\t      if (addedAt) {\n\t        addedModel = models[addedAt];\n\t        models = models.slice(0, addedAt).concat(models.slice(addedAt + 1));\n\t      }\n\t      models = this._sortModelsBy(models, viewComparator);\n\t      if (addedModel) {\n\t        models.splice(addedAt, 0, addedModel);\n\t      }\n\t    }\n\n\t    // Filter after sorting in case the filter uses the index\n\t    models = this._filterModels(models);\n\n\t    return models;\n\t  },\n\t  getViewComparator: function getViewComparator() {\n\t    return this.viewComparator;\n\t  },\n\n\n\t  // Filter an array of models, if a filter exists\n\t  _filterModels: function _filterModels(models) {\n\t    var _this6 = this;\n\n\t    if (this.filter) {\n\t      models = _.filter(models, function (model, index) {\n\t        return _this6._shouldAddChild(model, index);\n\t      });\n\t    }\n\t    return models;\n\t  },\n\t  _sortModelsBy: function _sortModelsBy(models, comparator) {\n\t    if (typeof comparator === 'string') {\n\t      return _.sortBy(models, function (model) {\n\t        return model.get(comparator);\n\t      });\n\t    } else if (comparator.length === 1) {\n\t      return _.sortBy(models, _.bind(comparator, this));\n\t    } else {\n\t      return models.sort(_.bind(comparator, this));\n\t    }\n\t  },\n\n\n\t  // Internal method to show an empty view in place of a collection of child views,\n\t  // when the collection is empty\n\t  _showEmptyView: function _showEmptyView() {\n\t    var EmptyView = this._getEmptyView();\n\n\t    if (EmptyView && !this._showingEmptyView) {\n\t      this._showingEmptyView = true;\n\n\t      var model = new Backbone.Model();\n\t      var emptyViewOptions = this.emptyViewOptions || this.childViewOptions;\n\t      if (_.isFunction(emptyViewOptions)) {\n\t        emptyViewOptions = emptyViewOptions.call(this, model, this._emptyViewIndex);\n\t      }\n\n\t      var view = this.buildChildView(model, EmptyView, emptyViewOptions);\n\n\t      this.triggerMethod('before:render:empty', this, view);\n\t      this._addChildView(view, 0);\n\t      this.triggerMethod('render:empty', this, view);\n\n\t      view._parent = this;\n\t    }\n\t  },\n\n\n\t  // Internal method to destroy an existing emptyView instance if one exists. Called when\n\t  // a collection view has been rendered empty, and then a child is added to the collection.\n\t  _destroyEmptyView: function _destroyEmptyView() {\n\t    if (this._showingEmptyView) {\n\t      this.triggerMethod('before:remove:empty', this);\n\n\t      this._destroyChildren();\n\t      delete this._showingEmptyView;\n\n\t      this.triggerMethod('remove:empty', this);\n\t    }\n\t  },\n\n\n\t  // Retrieve the empty view class\n\t  _getEmptyView: function _getEmptyView() {\n\t    var emptyView = this.emptyView;\n\n\t    if (!emptyView) {\n\t      return;\n\t    }\n\n\t    return this._getView(emptyView);\n\t  },\n\n\n\t  // Retrieve the `childView` class\n\t  // The `childView` property can be either a view class or a function that\n\t  // returns a view class. If it is a function, it will receive the model that\n\t  // will be passed to the view instance (created from the returned view class)\n\t  _getChildView: function _getChildView(child) {\n\t    var childView = this.childView;\n\n\t    if (!childView) {\n\t      throw new MarionetteError({\n\t        name: 'NoChildViewError',\n\t        message: 'A \"childView\" must be specified'\n\t      });\n\t    }\n\n\t    childView = this._getView(childView, child);\n\n\t    if (!childView) {\n\t      throw new MarionetteError({\n\t        name: 'InvalidChildViewError',\n\t        message: '\"childView\" must be a view class or a function that returns a view class'\n\t      });\n\t    }\n\n\t    return childView;\n\t  },\n\n\n\t  // First check if the `view` is a view class (the common case)\n\t  // Then check if it's a function (which we assume that returns a view class)\n\t  _getView: function _getView(view, child) {\n\t    if (view.prototype instanceof Backbone.View || view === Backbone.View) {\n\t      return view;\n\t    } else if (_.isFunction(view)) {\n\t      return view.call(this, child);\n\t    }\n\t  },\n\n\n\t  // Internal method for building and adding a child view\n\t  _addChild: function _addChild(child, ChildView, index) {\n\t    var childViewOptions = this._getChildViewOptions(child, index);\n\n\t    var view = this.buildChildView(child, ChildView, childViewOptions);\n\n\t    this.addChildView(view, index);\n\n\t    return view;\n\t  },\n\t  _getChildViewOptions: function _getChildViewOptions(child, index) {\n\t    if (_.isFunction(this.childViewOptions)) {\n\t      return this.childViewOptions(child, index);\n\t    }\n\n\t    return this.childViewOptions;\n\t  },\n\n\n\t  // Render the child's view and add it to the HTML for the collection view at a given index.\n\t  // This will also update the indices of later views in the collection in order to keep the\n\t  // children in sync with the collection.\n\t  addChildView: function addChildView(view, index) {\n\t    this.triggerMethod('before:add:child', this, view);\n\n\t    // increment indices of views after this one\n\t    this._updateIndices(view, true, index);\n\n\t    view._parent = this;\n\n\t    this._addChildView(view, index);\n\n\t    this.triggerMethod('add:child', this, view);\n\n\t    return view;\n\t  },\n\n\n\t  // Internal method. This decrements or increments the indices of views after the added/removed\n\t  // view to keep in sync with the collection.\n\t  _updateIndices: function _updateIndices(view, increment, index) {\n\t    if (!this.sort) {\n\t      return this;\n\t    }\n\n\t    if (increment) {\n\t      // assign the index to the view\n\t      view._index = index;\n\t    }\n\n\t    // update the indexes of views after this one\n\t    this.children.each(function (laterView) {\n\t      if (laterView._index >= view._index) {\n\t        laterView._index += increment ? 1 : -1;\n\t      }\n\t    });\n\n\t    return this;\n\t  },\n\n\n\t  // Internal Method. Add the view to children and render it at the given index.\n\t  _addChildView: function _addChildView(view, index) {\n\t    // Only trigger attach if already attached and not buffering,\n\t    // otherwise _endBuffering() or Region#show() handles this.\n\t    var shouldTriggerAttach = !this._isBuffering && this._isAttached;\n\n\t    monitorViewEvents(view);\n\n\t    // set up the child view event forwarding\n\t    this._proxyChildEvents(view);\n\n\t    // Store the child view itself so we can properly remove and/or destroy it later\n\t    this.children.add(view);\n\n\t    if (!view.supportsRenderLifecycle) {\n\t      triggerMethodOn(view, 'before:render', view);\n\t    }\n\n\t    // Render view\n\t    view.render();\n\n\t    if (!view.supportsRenderLifecycle) {\n\t      view._isRendered = true;\n\t      triggerMethodOn(view, 'render', view);\n\t    }\n\n\t    if (shouldTriggerAttach) {\n\t      triggerMethodOn(view, 'before:attach', view);\n\t    }\n\n\t    // Attach view\n\t    this.attachHtml(this, view, index);\n\n\t    if (shouldTriggerAttach) {\n\t      view._isAttached = true;\n\t      triggerMethodOn(view, 'attach', view);\n\t    }\n\t  },\n\n\n\t  // Build a `childView` for a model in the collection.\n\t  buildChildView: function buildChildView(child, ChildViewClass, childViewOptions) {\n\t    var options = _.extend({ model: child }, childViewOptions);\n\t    return new ChildViewClass(options);\n\t  },\n\n\n\t  // check if the collection is empty or optionally whether an array of pre-processed models is empty\n\t  isEmpty: function isEmpty(options) {\n\t    var models = void 0;\n\t    if (_.result(options, 'processedModels')) {\n\t      models = options.processedModels;\n\t    } else {\n\t      models = this.collection ? this.collection.models : [];\n\t      models = this._filterModels(models);\n\t    }\n\t    return models.length === 0;\n\t  },\n\n\n\t  // If empty, show the empty view\n\t  _checkEmpty: function _checkEmpty() {\n\t    if (this.isEmpty()) {\n\t      this._showEmptyView();\n\t    }\n\n\t    return this;\n\t  },\n\n\n\t  // You might need to override this if you've overridden attachHtml\n\t  attachBuffer: function attachBuffer(collectionView, buffer) {\n\t    collectionView.$el.append(buffer);\n\t  },\n\n\n\t  // Create a fragment buffer from the currently buffered children\n\t  _createBuffer: function _createBuffer() {\n\t    var elBuffer = document.createDocumentFragment();\n\t    _.each(this._bufferedChildren, function (b) {\n\t      elBuffer.appendChild(b.el);\n\t    });\n\t    return elBuffer;\n\t  },\n\n\n\t  // Append the HTML to the collection's `el`. Override this method to do something other\n\t  // than `.append`.\n\t  attachHtml: function attachHtml(collectionView, childView, index) {\n\t    if (collectionView._isBuffering) {\n\t      // buffering happens on reset events and initial renders\n\t      // in order to reduce the number of inserts into the\n\t      // document, which are expensive.\n\t      collectionView._bufferedChildren.splice(index, 0, childView);\n\t    } else {\n\t      // If we've already rendered the main collection, append\n\t      // the new child into the correct order if we need to. Otherwise\n\t      // append to the end.\n\t      if (!collectionView._insertBefore(childView, index)) {\n\t        collectionView._insertAfter(childView);\n\t      }\n\t    }\n\t  },\n\n\n\t  // Internal method. Check whether we need to insert the view into the correct position.\n\t  _insertBefore: function _insertBefore(childView, index) {\n\t    var currentView = void 0;\n\t    var findPosition = this.sort && index < this.children.length - 1;\n\t    if (findPosition) {\n\t      // Find the view after this one\n\t      currentView = this.children.find(function (view) {\n\t        return view._index === index + 1;\n\t      });\n\t    }\n\n\t    if (currentView) {\n\t      currentView.$el.before(childView.el);\n\t      return true;\n\t    }\n\n\t    return false;\n\t  },\n\n\n\t  // Internal method. Append a view to the end of the $el\n\t  _insertAfter: function _insertAfter(childView) {\n\t    this.$el.append(childView.el);\n\t  },\n\n\n\t  // Internal method to set up the `children` object for storing all of the child views\n\t  _initChildViewStorage: function _initChildViewStorage() {\n\t    this.children = new ChildViewContainer();\n\t  },\n\n\n\t  // called by ViewMixin destroy\n\t  _removeChildren: function _removeChildren() {\n\t    this._destroyChildren({ checkEmpty: false });\n\t  },\n\n\n\t  // Destroy the child views that this collection view is holding on to, if any\n\t  _destroyChildren: function _destroyChildren(options) {\n\t    var childViews = this.children.map(_.identity);\n\n\t    if (childViews.length) {\n\t      this.triggerMethod('before:destroy:children', this);\n\t      this._removeChildViews(childViews, options);\n\t      this.triggerMethod('destroy:children', this);\n\t    }\n\n\t    return childViews;\n\t  },\n\n\n\t  // Return true if the given child should be shown. Return false otherwise.\n\t  // The filter will be passed (child, index, collection), where\n\t  //  'child' is the given model\n\t  //  'index' is the index of that model in the collection\n\t  //  'collection' is the collection referenced by this CollectionView\n\t  _shouldAddChild: function _shouldAddChild(child, index) {\n\t    var filter = this.filter;\n\t    return !_.isFunction(filter) || filter.call(this, child, index, this.collection);\n\t  },\n\n\n\t  // Set up the child view event forwarding. Uses a \"childview:\" prefix in front of all forwarded events.\n\t  _proxyChildEvents: function _proxyChildEvents(view) {\n\t    var _this7 = this;\n\n\t    var prefix = _.result(this, 'childViewEventPrefix');\n\n\t    // Forward all child view events through the parent,\n\t    // prepending \"childview:\" to the event name\n\t    this.listenTo(view, 'all', function (eventName) {\n\t      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t        args[_key - 1] = arguments[_key];\n\t      }\n\n\t      var childEventName = prefix + ':' + eventName;\n\n\t      var childViewEvents = _this7.normalizeMethods(_this7._childViewEvents);\n\n\t      // call collectionView childViewEvent if defined\n\t      if (typeof childViewEvents !== 'undefined' && _.isFunction(childViewEvents[eventName])) {\n\t        childViewEvents[eventName].apply(_this7, args);\n\t      }\n\n\t      // use the parent view's proxyEvent handlers\n\t      var childViewTriggers = _this7._childViewTriggers;\n\n\t      // Call the event with the proxy name on the parent layout\n\t      if (childViewTriggers && _.isString(childViewTriggers[eventName])) {\n\t        _this7.triggerMethod.apply(_this7, [childViewTriggers[eventName]].concat(args));\n\t      }\n\n\t      _this7.triggerMethod.apply(_this7, [childEventName].concat(args));\n\t    });\n\t  }\n\t});\n\n\t_.extend(CollectionView.prototype, ViewMixin);\n\n\tvar ClassOptions$4 = ['childViewContainer', 'template', 'templateContext'];\n\n\t// Used for rendering a branch-leaf, hierarchical structure.\n\t// Extends directly from CollectionView\n\t// @deprecated\n\tvar CompositeView = CollectionView.extend({\n\n\t  // Setting up the inheritance chain which allows changes to\n\t  // Marionette.CollectionView.prototype.constructor which allows overriding\n\t  // option to pass '{sort: false}' to prevent the CompositeView from\n\t  // maintaining the sorted order of the collection.\n\t  // This will fallback onto appending childView's to the end.\n\n\t  constructor: function constructor(options) {\n\t    deprecate('CompositeView is deprecated. Convert to View at your earliest convenience');\n\n\t    this.mergeOptions(options, ClassOptions$4);\n\n\t    CollectionView.prototype.constructor.apply(this, arguments);\n\t  },\n\n\n\t  // Configured the initial events that the composite view\n\t  // binds to. Override this method to prevent the initial\n\t  // events, or to add your own initial events.\n\t  _initialEvents: function _initialEvents() {\n\n\t    // Bind only after composite view is rendered to avoid adding child views\n\t    // to nonexistent childViewContainer\n\n\t    if (this.collection) {\n\t      this.listenTo(this.collection, 'add', this._onCollectionAdd);\n\t      this.listenTo(this.collection, 'update', this._onCollectionUpdate);\n\t      this.listenTo(this.collection, 'reset', this.renderChildren);\n\n\t      if (this.sort) {\n\t        this.listenTo(this.collection, 'sort', this._sortViews);\n\t      }\n\t    }\n\t  },\n\n\n\t  // Retrieve the `childView` to be used when rendering each of\n\t  // the items in the collection. The default is to return\n\t  // `this.childView` or Marionette.CompositeView if no `childView`\n\t  // has been defined. As happens in CollectionView, `childView` can\n\t  // be a function (which should return a view class).\n\t  _getChildView: function _getChildView(child) {\n\t    var childView = this.childView;\n\n\t    // for CompositeView, if `childView` is not specified, we'll get the same\n\t    // composite view class rendered for each child in the collection\n\t    // then check if the `childView` is a view class (the common case)\n\t    // finally check if it's a function (which we assume that returns a view class)\n\t    if (!childView) {\n\t      return this.constructor;\n\t    }\n\n\t    childView = this._getView(childView, child);\n\n\t    if (!childView) {\n\t      throw new MarionetteError({\n\t        name: 'InvalidChildViewError',\n\t        message: '\"childView\" must be a view class or a function that returns a view class'\n\t      });\n\t    }\n\n\t    return childView;\n\t  },\n\n\n\t  // Return the serialized model\n\t  serializeData: function serializeData() {\n\t    return this.serializeModel();\n\t  },\n\n\n\t  // Renders the model and the collection.\n\t  render: function render() {\n\t    this._ensureViewIsIntact();\n\t    this._isRendering = true;\n\t    this.resetChildViewContainer();\n\n\t    this.triggerMethod('before:render', this);\n\n\t    this._renderTemplate();\n\t    this.bindUIElements();\n\t    this.renderChildren();\n\n\t    this._isRendering = false;\n\t    this._isRendered = true;\n\t    this.triggerMethod('render', this);\n\t    return this;\n\t  },\n\t  renderChildren: function renderChildren() {\n\t    if (this._isRendered || this._isRendering) {\n\t      CollectionView.prototype._renderChildren.call(this);\n\t    }\n\t  },\n\n\n\t  // You might need to override this if you've overridden attachHtml\n\t  attachBuffer: function attachBuffer(compositeView, buffer) {\n\t    var $container = this.getChildViewContainer(compositeView);\n\t    $container.append(buffer);\n\t  },\n\n\n\t  // Internal method. Append a view to the end of the $el.\n\t  // Overidden from CollectionView to ensure view is appended to\n\t  // childViewContainer\n\t  _insertAfter: function _insertAfter(childView) {\n\t    var $container = this.getChildViewContainer(this, childView);\n\t    $container.append(childView.el);\n\t  },\n\n\n\t  // Internal method. Append reordered childView'.\n\t  // Overidden from CollectionView to ensure reordered views\n\t  // are appended to childViewContainer\n\t  _appendReorderedChildren: function _appendReorderedChildren(children) {\n\t    var $container = this.getChildViewContainer(this);\n\t    $container.append(children);\n\t  },\n\n\n\t  // Internal method to ensure an `$childViewContainer` exists, for the\n\t  // `attachHtml` method to use.\n\t  getChildViewContainer: function getChildViewContainer(containerView, childView) {\n\t    if (!!containerView.$childViewContainer) {\n\t      return containerView.$childViewContainer;\n\t    }\n\n\t    var container = void 0;\n\t    var childViewContainer = containerView.childViewContainer;\n\t    if (childViewContainer) {\n\n\t      var selector = _.result(containerView, 'childViewContainer');\n\n\t      if (selector.charAt(0) === '@' && containerView.ui) {\n\t        container = containerView.ui[selector.substr(4)];\n\t      } else {\n\t        container = containerView.$(selector);\n\t      }\n\n\t      if (container.length <= 0) {\n\t        throw new MarionetteError({\n\t          name: 'ChildViewContainerMissingError',\n\t          message: 'The specified \"childViewContainer\" was not found: ' + containerView.childViewContainer\n\t        });\n\t      }\n\t    } else {\n\t      container = containerView.$el;\n\t    }\n\n\t    containerView.$childViewContainer = container;\n\t    return container;\n\t  },\n\n\n\t  // Internal method to reset the `$childViewContainer` on render\n\t  resetChildViewContainer: function resetChildViewContainer() {\n\t    if (this.$childViewContainer) {\n\t      this.$childViewContainer = undefined;\n\t    }\n\t  }\n\t});\n\n\t// To prevent duplication but allow the best View organization\n\t// Certain View methods are mixed directly into the deprecated CompositeView\n\tvar MixinFromView = _.pick(View.prototype, 'serializeModel', 'getTemplate', '_renderTemplate', 'mixinTemplateContext', 'attachElContent');\n\t_.extend(CompositeView.prototype, MixinFromView);\n\n\tvar ClassOptions$5 = ['collectionEvents', 'events', 'modelEvents', 'triggers', 'ui'];\n\n\tvar Behavior = MarionetteObject.extend({\n\t  cidPrefix: 'mnb',\n\n\t  constructor: function constructor(options, view) {\n\t    // Setup reference to the view.\n\t    // this comes in handle when a behavior\n\t    // wants to directly talk up the chain\n\t    // to the view.\n\t    this.view = view;\n\t    this.defaults = _.clone(_.result(this, 'defaults', {}));\n\t    this._setOptions(this.defaults, options);\n\t    this.mergeOptions(this.options, ClassOptions$5);\n\n\t    // Construct an internal UI hash using\n\t    // the behaviors UI hash and then the view UI hash.\n\t    // This allows the user to use UI hash elements\n\t    // defined in the parent view as well as those\n\t    // defined in the given behavior.\n\t    // This order will help the reuse and share of a behavior\n\t    // between multiple views, while letting a view override a\n\t    // selector under an UI key.\n\t    this.ui = _.extend({}, _.result(this, 'ui'), _.result(view, 'ui'));\n\n\t    MarionetteObject.apply(this, arguments);\n\t  },\n\n\n\t  // proxy behavior $ method to the view\n\t  // this is useful for doing jquery DOM lookups\n\t  // scoped to behaviors view.\n\t  $: function $() {\n\t    return this.view.$.apply(this.view, arguments);\n\t  },\n\n\n\t  // Stops the behavior from listening to events.\n\t  // Overrides Object#destroy to prevent additional events from being triggered.\n\t  destroy: function destroy() {\n\t    this.stopListening();\n\n\t    return this;\n\t  },\n\t  proxyViewProperties: function proxyViewProperties() {\n\t    this.$el = this.view.$el;\n\t    this.el = this.view.el;\n\n\t    return this;\n\t  },\n\t  bindUIElements: function bindUIElements() {\n\t    this._bindUIElements();\n\n\t    return this;\n\t  },\n\t  unbindUIElements: function unbindUIElements() {\n\t    this._unbindUIElements();\n\n\t    return this;\n\t  },\n\t  getUI: function getUI(name) {\n\t    this.view._ensureViewIsIntact();\n\t    return this._getUI(name);\n\t  },\n\n\n\t  // Handle `modelEvents`, and `collectionEvents` configuration\n\t  delegateEntityEvents: function delegateEntityEvents() {\n\t    this._delegateEntityEvents(this.view.model, this.view.collection);\n\n\t    return this;\n\t  },\n\t  undelegateEntityEvents: function undelegateEntityEvents() {\n\t    this._undelegateEntityEvents(this.view.model, this.view.collection);\n\n\t    return this;\n\t  },\n\t  getEvents: function getEvents() {\n\t    // Normalize behavior events hash to allow\n\t    // a user to use the @ui. syntax.\n\t    var behaviorEvents = this.normalizeUIKeys(_.result(this, 'events'));\n\n\t    // binds the handler to the behavior and builds a unique eventName\n\t    return _.reduce(behaviorEvents, function (events, behaviorHandler, key) {\n\t      if (!_.isFunction(behaviorHandler)) {\n\t        behaviorHandler = this[behaviorHandler];\n\t      }\n\t      if (!behaviorHandler) {\n\t        return;\n\t      }\n\t      key = getUniqueEventName(key);\n\t      events[key] = _.bind(behaviorHandler, this);\n\t      return events;\n\t    }, {}, this);\n\t  },\n\n\n\t  // Internal method to build all trigger handlers for a given behavior\n\t  getTriggers: function getTriggers() {\n\t    if (!this.triggers) {\n\t      return;\n\t    }\n\n\t    // Normalize behavior triggers hash to allow\n\t    // a user to use the @ui. syntax.\n\t    var behaviorTriggers = this.normalizeUIKeys(_.result(this, 'triggers'));\n\n\t    return this._getViewTriggers(this.view, behaviorTriggers);\n\t  }\n\t});\n\n\t_.extend(Behavior.prototype, DelegateEntityEventsMixin, TriggersMixin, UIMixin);\n\n\tvar ClassOptions$6 = ['region', 'regionClass'];\n\n\t// A container for a Marionette application.\n\tvar Application = MarionetteObject.extend({\n\t  cidPrefix: 'mna',\n\n\t  constructor: function constructor(options) {\n\t    this._setOptions(options);\n\n\t    this.mergeOptions(options, ClassOptions$6);\n\n\t    this._initRegion();\n\n\t    MarionetteObject.prototype.constructor.apply(this, arguments);\n\t  },\n\n\n\t  regionClass: Region,\n\n\t  _initRegion: function _initRegion(options) {\n\t    var region = this.region;\n\t    var RegionClass = this.regionClass;\n\n\t    // if the region is a string expect an el or selector\n\t    // and instantiate a region\n\t    if (_.isString(region)) {\n\t      this._region = new RegionClass({\n\t        el: region\n\t      });\n\t      return;\n\t    }\n\n\t    this._region = region;\n\t  },\n\t  getRegion: function getRegion() {\n\t    return this._region;\n\t  },\n\t  showView: function showView(view) {\n\t    var region = this.getRegion();\n\n\t    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t      args[_key - 1] = arguments[_key];\n\t    }\n\n\t    return region.show.apply(region, [view].concat(args));\n\t  },\n\t  getView: function getView() {\n\t    return this.getRegion().currentView;\n\t  },\n\n\n\t  // kick off all of the application's processes.\n\t  start: function start(options) {\n\t    this.triggerMethod('before:start', this, options);\n\t    this.triggerMethod('start', this, options);\n\t    return this;\n\t  }\n\t});\n\n\tvar ClassOptions$7 = ['appRoutes', 'controller'];\n\n\tvar AppRouter = Backbone.Router.extend({\n\t  constructor: function constructor(options) {\n\t    this._setOptions(options);\n\n\t    this.mergeOptions(options, ClassOptions$7);\n\n\t    Backbone.Router.apply(this, arguments);\n\n\t    var appRoutes = this.appRoutes;\n\t    var controller = this._getController();\n\t    this.processAppRoutes(controller, appRoutes);\n\t    this.on('route', this._processOnRoute, this);\n\t  },\n\n\n\t  // Similar to route method on a Backbone Router but\n\t  // method is called on the controller\n\t  appRoute: function appRoute(route, methodName) {\n\t    var controller = this._getController();\n\t    this._addAppRoute(controller, route, methodName);\n\t    return this;\n\t  },\n\n\n\t  // process the route event and trigger the onRoute\n\t  // method call, if it exists\n\t  _processOnRoute: function _processOnRoute(routeName, routeArgs) {\n\t    // make sure an onRoute before trying to call it\n\t    if (_.isFunction(this.onRoute)) {\n\t      // find the path that matches the current route\n\t      var routePath = _.invert(this.appRoutes)[routeName];\n\t      this.onRoute(routeName, routePath, routeArgs);\n\t    }\n\t  },\n\n\n\t  // Internal method to process the `appRoutes` for the\n\t  // router, and turn them in to routes that trigger the\n\t  // specified method on the specified `controller`.\n\t  processAppRoutes: function processAppRoutes(controller, appRoutes) {\n\t    var _this = this;\n\n\t    if (!appRoutes) {\n\t      return this;\n\t    }\n\n\t    var routeNames = _.keys(appRoutes).reverse(); // Backbone requires reverted order of routes\n\n\t    _.each(routeNames, function (route) {\n\t      _this._addAppRoute(controller, route, appRoutes[route]);\n\t    });\n\n\t    return this;\n\t  },\n\t  _getController: function _getController() {\n\t    return this.controller;\n\t  },\n\t  _addAppRoute: function _addAppRoute(controller, route, methodName) {\n\t    var method = controller[methodName];\n\n\t    if (!method) {\n\t      throw new MarionetteError('Method \"' + methodName + '\" was not found on the controller');\n\t    }\n\n\t    this.route(route, methodName, _.bind(method, controller));\n\t  },\n\n\n\t  triggerMethod: triggerMethod\n\t});\n\n\t_.extend(AppRouter.prototype, CommonMixin);\n\n\t// Placeholder method to be extended by the user.\n\t// The method should define the object that stores the behaviors.\n\t// i.e.\n\t//\n\t// ```js\n\t// Marionette.Behaviors.behaviorsLookup: function() {\n\t//   return App.Behaviors\n\t// }\n\t// ```\n\tfunction behaviorsLookup() {\n\t  throw new MarionetteError({\n\t    message: 'You must define where your behaviors are stored.',\n\t    url: 'marionette.behaviors.md#behaviorslookup'\n\t  });\n\t}\n\n\t// Add Feature flags here\n\t// e.g. 'class' => false\n\tvar FEATURES = {};\n\n\tfunction isEnabled(name) {\n\t  return !!FEATURES[name];\n\t}\n\n\tfunction setEnabled(name, state) {\n\t  return FEATURES[name] = state;\n\t}\n\n\tvar previousMarionette = Backbone.Marionette;\n\tvar Marionette = Backbone.Marionette = {};\n\n\t// This allows you to run multiple instances of Marionette on the same\n\t// webapp. After loading the new version, call `noConflict()` to\n\t// get a reference to it. At the same time the old version will be\n\t// returned to Backbone.Marionette.\n\tMarionette.noConflict = function () {\n\t  Backbone.Marionette = previousMarionette;\n\t  return this;\n\t};\n\n\t// Utilities\n\tMarionette.bindEvents = proxy(bindEvents);\n\tMarionette.unbindEvents = proxy(unbindEvents);\n\tMarionette.bindRequests = proxy(bindRequests);\n\tMarionette.unbindRequests = proxy(unbindRequests);\n\tMarionette.mergeOptions = proxy(mergeOptions);\n\tMarionette.getOption = proxy(getOption);\n\tMarionette.normalizeMethods = proxy(normalizeMethods);\n\tMarionette.extend = extend;\n\tMarionette.isNodeAttached = isNodeAttached;\n\tMarionette.deprecate = deprecate;\n\tMarionette.triggerMethod = proxy(triggerMethod);\n\tMarionette.triggerMethodOn = triggerMethodOn;\n\tMarionette.isEnabled = isEnabled;\n\tMarionette.setEnabled = setEnabled;\n\tMarionette.monitorViewEvents = monitorViewEvents;\n\n\tMarionette.Behaviors = {};\n\tMarionette.Behaviors.behaviorsLookup = behaviorsLookup;\n\n\t// Classes\n\tMarionette.Application = Application;\n\tMarionette.AppRouter = AppRouter;\n\tMarionette.Renderer = Renderer;\n\tMarionette.TemplateCache = TemplateCache;\n\tMarionette.View = View;\n\tMarionette.CollectionView = CollectionView;\n\tMarionette.CompositeView = CompositeView;\n\tMarionette.Behavior = Behavior;\n\tMarionette.Region = Region;\n\tMarionette.Error = MarionetteError;\n\tMarionette.Object = MarionetteObject;\n\n\t// Configuration\n\tMarionette.DEV_MODE = false;\n\tMarionette.FEATURES = FEATURES;\n\tMarionette.VERSION = version;\n\n\treturn Marionette;\n\n}));\n\n//# sourceMappingURL=backbone.marionette.js.map\n","// Trigger Method\n// --------------\n\nimport _         from 'underscore';\nimport getOption from './get-option';\n\n// split the event name on the \":\"\nconst splitter = /(^|:)(\\w)/gi;\n\n// take the event section (\"section1:section2:section3\")\n// and turn it in to uppercase name onSection1Section2Section3\nfunction getEventName(match, prefix, eventName) {\n  return eventName.toUpperCase();\n}\n\n// Trigger an event and/or a corresponding method name. Examples:\n//\n// `this.triggerMethod(\"foo\")` will trigger the \"foo\" event and\n// call the \"onFoo\" method.\n//\n// `this.triggerMethod(\"foo:bar\")` will trigger the \"foo:bar\" event and\n// call the \"onFooBar\" method.\nexport function triggerMethod(event, ...args) {\n  // get the method name from the event name\n  const methodName = 'on' + event.replace(splitter, getEventName);\n  const method = getOption.call(this, methodName);\n  let result;\n\n  // call the onMethodName if it exists\n  if (_.isFunction(method)) {\n    // pass all args, except the event name\n    result = method.apply(this, args);\n  }\n\n  // trigger the event\n  this.trigger(event, ...args);\n\n  return result;\n}\n\n// triggerMethodOn invokes triggerMethod on a specific context\n//\n// e.g. `Marionette.triggerMethodOn(view, 'show')`\n// will trigger a \"show\" event or invoke onShow the view.\nexport function triggerMethodOn(context, ...args) {\n  const fnc = _.isFunction(context.triggerMethod) ? context.triggerMethod : triggerMethod;\n  return fnc.apply(context, args);\n}\n","// DOM Refresh\n// -----------\n\nimport _ from 'underscore';\nimport { triggerMethodOn } from './trigger-method';\n\n// Trigger method on children unless a pure Backbone.View\nfunction triggerMethodChildren(view, event, shouldTrigger) {\n  if (!view._getImmediateChildren) { return; }\n  _.each(view._getImmediateChildren(), child => {\n    if (!shouldTrigger(child)) { return; }\n    triggerMethodOn(child, event, child);\n  });\n}\n\nfunction shouldTriggerAttach(view) {\n  return !view._isAttached;\n}\n\nfunction shouldAttach(view) {\n  if (!shouldTriggerAttach(view)) { return false; }\n  view._isAttached = true;\n  return true;\n}\n\nfunction shouldTriggerDetach(view) {\n  return view._isAttached;\n}\n\nfunction shouldDetach(view) {\n  if (!shouldTriggerDetach(view)) { return false; }\n  view._isAttached = false;\n  return true;\n}\n\n// Monitor a view's state, propagating attach/detach events to children and firing dom:refresh\n// whenever a rendered view is attached or an attached view is rendered.\nfunction monitorViewEvents(view) {\n  if (view._areViewEventsMonitored) { return; }\n\n  view._areViewEventsMonitored = true;\n\n  function handleBeforeAttach() {\n    triggerMethodChildren(view, 'before:attach', shouldTriggerAttach);\n  }\n\n  function handleAttach() {\n    triggerMethodChildren(view, 'attach', shouldAttach);\n    triggerDOMRefresh();\n  }\n\n  function handleBeforeDetach() {\n    triggerMethodChildren(view, 'before:detach', shouldTriggerDetach);\n  }\n\n  function handleDetach() {\n    triggerMethodChildren(view, 'detach', shouldDetach);\n  }\n\n  function handleRender() {\n    triggerDOMRefresh();\n  }\n\n  function triggerDOMRefresh() {\n    if (view._isAttached && view._isRendered) {\n      triggerMethodOn(view, 'dom:refresh', view);\n    }\n  }\n\n  view.on({\n    'before:attach': handleBeforeAttach,\n    'attach': handleAttach,\n    'before:detach': handleBeforeDetach,\n    'detach': handleDetach,\n    'render': handleRender\n  });\n}\n\nexport default monitorViewEvents;\n","// Bind Entity Events & Unbind Entity Events\n// -----------------------------------------\n//\n// These methods are used to bind/unbind a backbone \"entity\" (e.g. collection/model)\n// to methods on a target object.\n//\n// The first parameter, `target`, must have the Backbone.Events module mixed in.\n//\n// The second parameter is the `entity` (Backbone.Model, Backbone.Collection or\n// any object that has Backbone.Events mixed in) to bind the events from.\n//\n// The third parameter is a hash of { \"event:name\": \"eventHandler\" }\n// configuration. Multiple handlers can be separated by a space. A\n// function can be supplied instead of a string handler name.\n\nimport _               from 'underscore';\nimport MarionetteError from '../error';\n\n// Bind/unbind the event to handlers specified as a string of\n// handler names on the target object\nfunction bindFromStrings(target, entity, evt, methods, actionName) {\n  const methodNames = methods.split(/\\s+/);\n\n  _.each(methodNames, function(methodName) {\n    const method = target[methodName];\n    if (!method) {\n      throw new MarionetteError(`Method \"${methodName}\" was configured as an event handler, but does not exist.`);\n    }\n\n    target[actionName](entity, evt, method);\n  });\n}\n\n// generic looping function\nfunction iterateEvents(target, entity, bindings, actionName) {\n  if (!entity || !bindings) { return; }\n\n  // type-check bindings\n  if (!_.isObject(bindings)) {\n    throw new MarionetteError({\n      message: 'Bindings must be an object.',\n      url: 'marionette.functions.html#marionettebindevents'\n    });\n  }\n\n  // iterate the bindings and bind/unbind them\n  _.each(bindings, function(method, evt) {\n\n    // allow for a list of method names as a string\n    if (_.isString(method)) {\n      bindFromStrings(target, entity, evt, method, actionName);\n      return;\n    }\n\n    target[actionName](entity, evt, method);\n  });\n}\n\nfunction bindEvents(entity, bindings) {\n  iterateEvents(this, entity, bindings, 'listenTo');\n  return this;\n}\n\nfunction unbindEvents(entity, bindings) {\n  iterateEvents(this, entity, bindings, 'stopListening');\n  return this;\n}\n\n// Export Public API\nexport {\n  bindEvents,\n  unbindEvents\n};\n","// Bind/Unbind Radio Requests\n// -----------------------------------------\n//\n// These methods are used to bind/unbind a backbone.radio request\n// to methods on a target object.\n//\n// The first parameter, `target`, will set the context of the reply method\n//\n// The second parameter is the `Radio.channel` to bind the reply to.\n//\n// The third parameter is a hash of { \"request:name\": \"replyHandler\" }\n// configuration. A function can be supplied instead of a string handler name.\n\nimport _ from 'underscore';\nimport normalizeMethods from './normalize-methods';\nimport MarionetteError from '../error';\n\nfunction iterateReplies(target, channel, bindings, actionName) {\n  if (!channel || !bindings) { return; }\n\n  // type-check bindings\n  if (!_.isObject(bindings)) {\n    throw new MarionetteError({\n      message: 'Bindings must be an object.',\n      url: 'marionette.functions.html#marionettebindrequests'\n    });\n  }\n\n  const normalizedRadioRequests = normalizeMethods.call(target, bindings);\n\n  channel[actionName](normalizedRadioRequests, target);\n}\n\nfunction bindRequests(channel, bindings) {\n  iterateReplies(this, channel, bindings, 'reply');\n  return this;\n}\n\nfunction unbindRequests(channel, bindings) {\n  iterateReplies(this, channel, bindings, 'stopReplying');\n  return this;\n}\n\nexport {\n  bindRequests,\n  unbindRequests\n};\n","import _                        from 'underscore';\nimport _invoke                  from '../utils/invoke';\nimport { triggerMethod }        from '../common/trigger-method';\nimport Marionette               from '../backbone.marionette';\n\n// MixinOptions\n// - behaviors\n\n// Takes care of getting the behavior class\n// given options and a key.\n// If a user passes in options.behaviorClass\n// default to using that.\n// If a user passes in a Behavior Class directly, use that\n// Otherwise delegate the lookup to the users `behaviorsLookup` implementation.\nfunction getBehaviorClass(options, key) {\n  if (options.behaviorClass) {\n    return options.behaviorClass;\n    //treat functions as a Behavior constructor\n  } else if (_.isFunction(options)) {\n    return options;\n  }\n\n  // behaviorsLookup can be either a flat object or a method\n  if (_.isFunction(Marionette.Behaviors.behaviorsLookup)) {\n    return Marionette.Behaviors.behaviorsLookup(options, key)[key];\n  }\n\n  return Marionette.Behaviors.behaviorsLookup[key];\n}\n\n// Iterate over the behaviors object, for each behavior\n// instantiate it and get its grouped behaviors.\n// This accepts a list of behaviors in either an object or array form\nfunction parseBehaviors(view, behaviors) {\n  return _.chain(behaviors).map(function(options, key) {\n    const BehaviorClass = getBehaviorClass(options, key);\n    //if we're passed a class directly instead of an object\n    const _options = options === BehaviorClass ? {} : options;\n    const behavior = new BehaviorClass(_options, view);\n    const nestedBehaviors = parseBehaviors(view, _.result(behavior, 'behaviors'));\n\n    return [behavior].concat(nestedBehaviors);\n  }).flatten().value();\n}\n\nexport default {\n  _initBehaviors() {\n    const behaviors = _.result(this, 'behaviors');\n\n    // Behaviors defined on a view can be a flat object literal\n    // or it can be a function that returns an object.\n    this._behaviors = _.isObject(behaviors) ? parseBehaviors(this, behaviors) : {};\n  },\n\n  _getBehaviorTriggers() {\n    const triggers = _invoke(this._behaviors, 'getTriggers');\n    return _.extend({}, ...triggers);\n  },\n\n  _getBehaviorEvents() {\n    const events = _invoke(this._behaviors, 'getEvents');\n    return _.extend({}, ...events);\n  },\n\n  // proxy behavior $el to the view's $el.\n  _proxyBehaviorViewProperties() {\n    _invoke(this._behaviors, 'proxyViewProperties');\n  },\n\n  // delegate modelEvents and collectionEvents\n  _delegateBehaviorEntityEvents() {\n    _invoke(this._behaviors, 'delegateEntityEvents');\n  },\n\n  // undelegate modelEvents and collectionEvents\n  _undelegateBehaviorEntityEvents() {\n    _invoke(this._behaviors, 'undelegateEntityEvents');\n  },\n\n  _destroyBehaviors(args) {\n    // Call destroy on each behavior after\n    // destroying the view.\n    // This unbinds event listeners\n    // that behaviors have registered for.\n    _invoke(this._behaviors, 'destroy', ...args);\n  },\n\n  _bindBehaviorUIElements() {\n    _invoke(this._behaviors, 'bindUIElements');\n  },\n\n  _unbindBehaviorUIElements() {\n    _invoke(this._behaviors, 'unbindUIElements');\n  },\n\n  _triggerEventOnBehaviors(...args) {\n    const behaviors = this._behaviors;\n    // Use good ol' for as this is a very hot function\n    for (let i = 0, length = behaviors && behaviors.length; i < length; i++) {\n      triggerMethod.apply(behaviors[i], args);\n    }\n  }\n};\n","import _ from 'underscore';\n\n// Borrow event splitter from Backbone\nconst delegateEventSplitter = /^(\\S+)\\s*(.*)$/;\n\nfunction uniqueName(eventName, selector) {\n  return [eventName + _.uniqueId('.evt'), selector].join(' ');\n}\n\n// Set event name to be namespaced using a unique index\n// to generate a non colliding event namespace\n// http://api.jquery.com/event.namespace/\nconst getUniqueEventName = function(eventName) {\n  const match = eventName.match(delegateEventSplitter);\n  return uniqueName(match[1], match[2]);\n};\n\nexport default getUniqueEventName;\n","import _ from 'underscore';\nimport getUniqueEventName from '../utils/get-unique-event-name';\n\n// Internal method to create an event handler for a given `triggerDef` like\n// 'click:foo'\nfunction buildViewTrigger(view, triggerDef) {\n  if (_.isString(triggerDef)) {\n    triggerDef = {event: triggerDef};\n  }\n\n  const eventName = triggerDef.event;\n  const shouldPreventDefault = triggerDef.preventDefault !== false;\n  const shouldStopPropagation = triggerDef.stopPropagation !== false;\n\n  return function(e) {\n    if (shouldPreventDefault) {\n      e.preventDefault();\n    }\n\n    if (shouldStopPropagation) {\n      e.stopPropagation();\n    }\n\n    view.triggerMethod(eventName, view);\n  };\n}\n\nexport default {\n\n  // Configure `triggers` to forward DOM events to view\n  // events. `triggers: {\"click .foo\": \"do:foo\"}`\n  _getViewTriggers(view, triggers) {\n    // Configure the triggers, prevent default\n    // action and stop propagation of DOM events\n    return _.reduce(triggers, (events, value, key) => {\n      key = getUniqueEventName(key);\n      events[key] = buildViewTrigger(view, value);\n      return events;\n    }, {});\n  }\n\n};\n","import { triggerMethodOn } from '../common/trigger-method';\n\nexport default function destroyBackboneView(view) {\n  if (!view.supportsDestroyLifecycle) {\n    triggerMethodOn(view, 'before:destroy', view);\n  }\n\n  const shouldTriggerDetach = !!view._isAttached;\n\n  if (shouldTriggerDetach) {\n    triggerMethodOn(view, 'before:detach', view);\n  }\n\n  view.remove();\n\n  if (shouldTriggerDetach) {\n    view._isAttached = false;\n    triggerMethodOn(view, 'detach', view);\n  }\n\n  view._isDestroyed = true;\n\n  if (!view.supportsDestroyLifecycle) {\n    triggerMethodOn(view, 'destroy', view);\n  }\n}\n","import MarionetteError          from '../error';\n\n// Placeholder method to be extended by the user.\n// The method should define the object that stores the behaviors.\n// i.e.\n//\n// ```js\n// Marionette.Behaviors.behaviorsLookup: function() {\n//   return App.Behaviors\n// }\n// ```\nexport default function behaviorsLookup() {\n  throw new MarionetteError({\n    message: 'You must define where your behaviors are stored.',\n    url: 'marionette.behaviors.md#behaviorslookup'\n  });\n}\n","// Add Feature flags here\n// e.g. 'class' => false\nconst FEATURES = {\n};\n\nfunction isEnabled(name) {\n  return !!FEATURES[name];\n}\n\nfunction setEnabled(name, state) {\n  return FEATURES[name] = state;\n}\n\nexport {\n  FEATURES,\n  setEnabled,\n  isEnabled\n};\n","//Internal utility for creating context style global utils\nconst proxy = function(method) {\n  return function(context, ...args) {\n    return method.apply(context, args);\n  };\n};\n\nexport default proxy;\n","// Marionette.extend\n// -----------------\n\nimport Backbone from 'backbone';\n\n// Borrow the Backbone `extend` method so we can use it as needed\nconst extend = Backbone.Model.extend;\n\nexport default extend;\n","/* global console */\n\nimport _ from 'underscore';\n\nimport Marionette from '../backbone.marionette';\n\nconst deprecate = function(message, test) {\n  if (_.isObject(message)) {\n    message = (\n      message.prev + ' is going to be removed in the future. ' +\n      'Please use ' + message.next + ' instead.' +\n      (message.url ? ' See: ' + message.url : '')\n    );\n  }\n\n  if (!Marionette.DEV_MODE) {\n    return;\n  }\n\n  if ((test === undefined || !test) && !deprecate._cache[message]) {\n    deprecate._warn('Deprecation warning: ' + message);\n    deprecate._cache[message] = true;\n  }\n};\n\ndeprecate._console = typeof console !== 'undefined' ? console : {};\ndeprecate._warn = function() {\n  const warn = deprecate._console.warn || deprecate._console.log || _.noop;\n  return warn.apply(deprecate._console, arguments);\n};\ndeprecate._cache = {};\n\nexport default deprecate;\n","// Marionette.isNodeAttached\n// -------------------------\n\nimport Backbone from 'backbone';\n\n// Determine if `el` is a child of the document\nconst isNodeAttached = function(el) {\n  return Backbone.$.contains(document.documentElement, el);\n};\n\nexport default isNodeAttached;\n","import _ from 'underscore';\n\n// Merge `keys` from `options` onto `this`\nconst mergeOptions = function(options, keys) {\n  if (!options) { return; }\n  _.extend(this, _.pick(options, keys));\n};\n\nexport default mergeOptions;\n","// Marionette.getOption\n// --------------------\n\n// Retrieve an object, function or other value from the\n// object or its `options`, with `options` taking precedence.\nconst getOption = function(optionName) {\n  if (!optionName) { return; }\n  if (this.options && (this.options[optionName] !== undefined)) {\n    return this.options[optionName];\n  } else {\n    return this[optionName];\n  }\n};\n\nexport default getOption;\n","import _ from 'underscore';\n\n// Marionette.normalizeMethods\n// ----------------------\n\n// Pass in a mapping of events => functions or function names\n// and return a mapping of events => functions\nconst normalizeMethods = function(hash) {\n  return _.reduce(hash, (normalizedHash, method, name) => {\n    if (!_.isFunction(method)) {\n      method = this[method];\n    }\n    if (method) {\n      normalizedHash[name] = method;\n    }\n    return normalizedHash;\n  }, {});\n};\n\nexport default normalizeMethods;\n","// Error\n// -----\n\nimport _      from 'underscore';\nimport extend from './utils/extend';\nimport {version} from '../package.json';\n\nconst errorProps = ['description', 'fileName', 'lineNumber', 'name', 'message', 'number'];\n\nconst MarionetteError = extend.call(Error, {\n  urlRoot: `http://marionettejs.com/docs/v${version}/`,\n\n  constructor(message, options) {\n    if (_.isObject(message)) {\n      options = message;\n      message = options.message;\n    } else if (!options) {\n      options = {};\n    }\n\n    const error = Error.call(this, message);\n    _.extend(this, _.pick(error, errorProps), _.pick(options, errorProps));\n\n    this.captureStackTrace();\n\n    if (options.url) {\n      this.url = this.urlRoot + options.url;\n    }\n  },\n\n  captureStackTrace() {\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, MarionetteError);\n    }\n  },\n\n  toString() {\n    return this.name + ': ' + this.message + (this.url ? ' See: ' + this.url : '');\n  }\n});\n\nMarionetteError.extend = extend;\n\nexport default MarionetteError;\n","import _ from 'underscore';\n\n// Internal utility for setting options consistently across Mn\nconst setOptions = function(...args) {\n  this.options = _.extend({}, _.result(this, 'options'), ...args);\n};\n\nexport default setOptions;\n","import _setOptions              from '../utils/set-options';\nimport getOption                from '../common/get-option';\nimport mergeOptions             from '../common/merge-options';\nimport normalizeMethods         from '../common/normalize-methods';\nimport {\n  bindEvents,\n  unbindEvents\n}                               from '../common/bind-events';\n\nexport default {\n\n  // Imports the \"normalizeMethods\" to transform hashes of\n  // events=>function references/names to a hash of events=>function references\n  normalizeMethods: normalizeMethods,\n\n  _setOptions: _setOptions,\n\n  // A handy way to merge passed-in options onto the instance\n  mergeOptions: mergeOptions,\n\n  // Enable getting options from this or this.options by name.\n  getOption: getOption,\n\n  // Enable binding view's events from another entity.\n  bindEvents: bindEvents,\n\n  // Enable unbinding view's events from another entity.\n  unbindEvents: unbindEvents\n};\n","// Backbone.Radio v2.0.0-pre.1\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('underscore'), require('backbone')) :\n  typeof define === 'function' && define.amd ? define(['underscore', 'backbone'], factory) :\n  (global.Backbone = global.Backbone || {}, global.Backbone.Radio = factory(global._,global.Backbone));\n}(this, function (_,Backbone) { 'use strict';\n\n  _ = 'default' in _ ? _['default'] : _;\n  Backbone = 'default' in Backbone ? Backbone['default'] : Backbone;\n\n  var babelHelpers = {};\n  babelHelpers.typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n  };\n  babelHelpers;\n\n  var previousRadio = Backbone.Radio;\n\n  var Radio = Backbone.Radio = {};\n\n  Radio.VERSION = '2.0.0-pre.1';\n\n  // This allows you to run multiple instances of Radio on the same\n  // webapp. After loading the new version, call `noConflict()` to\n  // get a reference to it. At the same time the old version will be\n  // returned to Backbone.Radio.\n  Radio.noConflict = function () {\n    Backbone.Radio = previousRadio;\n    return this;\n  };\n\n  // Whether or not we're in DEBUG mode or not. DEBUG mode helps you\n  // get around the issues of lack of warnings when events are mis-typed.\n  Radio.DEBUG = false;\n\n  // Format debug text.\n  Radio._debugText = function (warning, eventName, channelName) {\n    return warning + (channelName ? ' on the ' + channelName + ' channel' : '') + ': \"' + eventName + '\"';\n  };\n\n  // This is the method that's called when an unregistered event was called.\n  // By default, it logs warning to the console. By overriding this you could\n  // make it throw an Error, for instance. This would make firing a nonexistent event\n  // have the same consequence as firing a nonexistent method on an Object.\n  Radio.debugLog = function (warning, eventName, channelName) {\n    if (Radio.DEBUG && console && console.warn) {\n      console.warn(Radio._debugText(warning, eventName, channelName));\n    }\n  };\n\n  var eventSplitter = /\\s+/;\n\n  // An internal method used to handle Radio's method overloading for Requests.\n  // It's borrowed from Backbone.Events. It differs from Backbone's overload\n  // API (which is used in Backbone.Events) in that it doesn't support space-separated\n  // event names.\n  Radio._eventsApi = function (obj, action, name, rest) {\n    if (!name) {\n      return false;\n    }\n\n    var results = {};\n\n    // Handle event maps.\n    if ((typeof name === 'undefined' ? 'undefined' : babelHelpers.typeof(name)) === 'object') {\n      for (var key in name) {\n        var result = obj[action].apply(obj, [key, name[key]].concat(rest));\n        eventSplitter.test(key) ? _.extend(results, result) : results[key] = result;\n      }\n      return results;\n    }\n\n    // Handle space separated event names.\n    if (eventSplitter.test(name)) {\n      var names = name.split(eventSplitter);\n      for (var i = 0, l = names.length; i < l; i++) {\n        results[names[i]] = obj[action].apply(obj, [names[i]].concat(rest));\n      }\n      return results;\n    }\n\n    return false;\n  };\n\n  // An optimized way to execute callbacks.\n  Radio._callHandler = function (callback, context, args) {\n    var a1 = args[0],\n        a2 = args[1],\n        a3 = args[2];\n    switch (args.length) {\n      case 0:\n        return callback.call(context);\n      case 1:\n        return callback.call(context, a1);\n      case 2:\n        return callback.call(context, a1, a2);\n      case 3:\n        return callback.call(context, a1, a2, a3);\n      default:\n        return callback.apply(context, args);\n    }\n  };\n\n  // A helper used by `off` methods to the handler from the store\n  function removeHandler(store, name, callback, context) {\n    var event = store[name];\n    if ((!callback || callback === event.callback || callback === event.callback._callback) && (!context || context === event.context)) {\n      delete store[name];\n      return true;\n    }\n  }\n\n  function removeHandlers(store, name, callback, context) {\n    store || (store = {});\n    var names = name ? [name] : _.keys(store);\n    var matched = false;\n\n    for (var i = 0, length = names.length; i < length; i++) {\n      name = names[i];\n\n      // If there's no event by this name, log it and continue\n      // with the loop\n      if (!store[name]) {\n        continue;\n      }\n\n      if (removeHandler(store, name, callback, context)) {\n        matched = true;\n      }\n    }\n\n    return matched;\n  }\n\n  /*\n   * tune-in\n   * -------\n   * Get console logs of a channel's activity\n   *\n   */\n\n  var _logs = {};\n\n  // This is to produce an identical function in both tuneIn and tuneOut,\n  // so that Backbone.Events unregisters it.\n  function _partial(channelName) {\n    return _logs[channelName] || (_logs[channelName] = _.bind(Radio.log, Radio, channelName));\n  }\n\n  _.extend(Radio, {\n\n    // Log information about the channel and event\n    log: function log(channelName, eventName) {\n      if (typeof console === 'undefined') {\n        return;\n      }\n      var args = _.toArray(arguments).slice(2);\n      console.log('[' + channelName + '] \"' + eventName + '\"', args);\n    },\n\n    // Logs all events on this channel to the console. It sets an\n    // internal value on the channel telling it we're listening,\n    // then sets a listener on the Backbone.Events\n    tuneIn: function tuneIn(channelName) {\n      var channel = Radio.channel(channelName);\n      channel._tunedIn = true;\n      channel.on('all', _partial(channelName));\n      return this;\n    },\n\n    // Stop logging all of the activities on this channel to the console\n    tuneOut: function tuneOut(channelName) {\n      var channel = Radio.channel(channelName);\n      channel._tunedIn = false;\n      channel.off('all', _partial(channelName));\n      delete _logs[channelName];\n      return this;\n    }\n  });\n\n  /*\n   * Backbone.Radio.Requests\n   * -----------------------\n   * A messaging system for requesting data.\n   *\n   */\n\n  function makeCallback(callback) {\n    return _.isFunction(callback) ? callback : function () {\n      return callback;\n    };\n  }\n\n  Radio.Requests = {\n\n    // Make a request\n    request: function request(name) {\n      var args = _.toArray(arguments).slice(1);\n      var results = Radio._eventsApi(this, 'request', name, args);\n      if (results) {\n        return results;\n      }\n      var channelName = this.channelName;\n      var requests = this._requests;\n\n      // Check if we should log the request, and if so, do it\n      if (channelName && this._tunedIn) {\n        Radio.log.apply(this, [channelName, name].concat(args));\n      }\n\n      // If the request isn't handled, log it in DEBUG mode and exit\n      if (requests && (requests[name] || requests['default'])) {\n        var handler = requests[name] || requests['default'];\n        args = requests[name] ? args : arguments;\n        return Radio._callHandler(handler.callback, handler.context, args);\n      } else {\n        Radio.debugLog('An unhandled request was fired', name, channelName);\n      }\n    },\n\n    // Set up a handler for a request\n    reply: function reply(name, callback, context) {\n      if (Radio._eventsApi(this, 'reply', name, [callback, context])) {\n        return this;\n      }\n\n      this._requests || (this._requests = {});\n\n      if (this._requests[name]) {\n        Radio.debugLog('A request was overwritten', name, this.channelName);\n      }\n\n      this._requests[name] = {\n        callback: makeCallback(callback),\n        context: context || this\n      };\n\n      return this;\n    },\n\n    // Set up a handler that can only be requested once\n    replyOnce: function replyOnce(name, callback, context) {\n      if (Radio._eventsApi(this, 'replyOnce', name, [callback, context])) {\n        return this;\n      }\n\n      var self = this;\n\n      var once = _.once(function () {\n        self.stopReplying(name);\n        return makeCallback(callback).apply(this, arguments);\n      });\n\n      return this.reply(name, once, context);\n    },\n\n    // Remove handler(s)\n    stopReplying: function stopReplying(name, callback, context) {\n      if (Radio._eventsApi(this, 'stopReplying', name)) {\n        return this;\n      }\n\n      // Remove everything if there are no arguments passed\n      if (!name && !callback && !context) {\n        delete this._requests;\n      } else if (!removeHandlers(this._requests, name, callback, context)) {\n        Radio.debugLog('Attempted to remove the unregistered request', name, this.channelName);\n      }\n\n      return this;\n    }\n  };\n\n  /*\n   * Backbone.Radio.channel\n   * ----------------------\n   * Get a reference to a channel by name.\n   *\n   */\n\n  Radio._channels = {};\n\n  Radio.channel = function (channelName) {\n    if (!channelName) {\n      throw new Error('You must provide a name for the channel.');\n    }\n\n    if (Radio._channels[channelName]) {\n      return Radio._channels[channelName];\n    } else {\n      return Radio._channels[channelName] = new Radio.Channel(channelName);\n    }\n  };\n\n  /*\n   * Backbone.Radio.Channel\n   * ----------------------\n   * A Channel is an object that extends from Backbone.Events,\n   * and Radio.Requests.\n   *\n   */\n\n  Radio.Channel = function (channelName) {\n    this.channelName = channelName;\n  };\n\n  _.extend(Radio.Channel.prototype, Backbone.Events, Radio.Requests, {\n\n    // Remove all handlers from the messaging systems of this channel\n    reset: function reset() {\n      this.off();\n      this.stopListening();\n      this.stopReplying();\n      return this;\n    }\n  });\n\n  /*\n   * Top-level API\n   * -------------\n   * Supplies the 'top-level API' for working with Channels directly\n   * from Backbone.Radio.\n   *\n   */\n\n  var channel;\n  var args;\n  var systems = [Backbone.Events, Radio.Requests];\n  _.each(systems, function (system) {\n    _.each(system, function (method, methodName) {\n      Radio[methodName] = function (channelName) {\n        args = _.toArray(arguments).slice(1);\n        channel = this.channel(channelName);\n        return channel[methodName].apply(channel, args);\n      };\n    });\n  });\n\n  Radio.reset = function (channelName) {\n    var channels = !channelName ? this._channels : [this._channels[channelName]];\n    _.each(channels, function (channel) {\n      channel.reset();\n    });\n  };\n\n  return Radio;\n\n}));\n//# sourceMappingURL=./backbone.radio.js.map","import _ from 'underscore';\nimport Radio from 'backbone.radio';\n\nimport {\n  bindRequests,\n  unbindRequests\n} from '../common/bind-requests';\n\nimport {\n  bindEvents,\n  unbindEvents\n} from '../common/bind-events';\n\n// MixinOptions\n// - channelName\n// - radioEvents\n// - radioRequests\n\nexport default {\n\n  _initRadio() {\n    const channelName = _.result(this, 'channelName');\n\n    if (!channelName) {\n      return;\n    }\n\n    const channel = this._channel = Radio.channel(channelName);\n\n    const radioEvents = _.result(this, 'radioEvents');\n    this.bindEvents(channel, radioEvents);\n\n    const radioRequests = _.result(this, 'radioRequests');\n    this.bindRequests(channel, radioRequests);\n\n    this.on('destroy', this._destroyRadio);\n  },\n\n  _destroyRadio() {\n    this._channel.stopReplying(null, null, this);\n  },\n\n  getChannel() {\n    return this._channel;\n  },\n\n  // Proxy `bindEvents`\n  bindEvents: bindEvents,\n\n  // Proxy `unbindEvents`\n  unbindEvents: unbindEvents,\n\n  // Proxy `bindRequests`\n  bindRequests: bindRequests,\n\n  // Proxy `unbindRequests`\n  unbindRequests: unbindRequests\n\n};\n","// Object\n// ------\n\nimport _ from 'underscore';\nimport Backbone from 'backbone';\nimport extend from './utils/extend';\nimport { triggerMethod } from './common/trigger-method';\nimport CommonMixin from './mixins/common';\nimport RadioMixin from './mixins/radio';\n\nconst ClassOptions = [\n  'channelName',\n  'radioEvents',\n  'radioRequests'\n];\n\n// A Base Class that other Classes should descend from.\n// Object borrows many conventions and utilities from Backbone.\nconst MarionetteObject = function(options) {\n  this._setOptions(options);\n  this.mergeOptions(options, ClassOptions);\n  this.cid = _.uniqueId(this.cidPrefix);\n  this._initRadio();\n  this.initialize.apply(this, arguments);\n};\n\nMarionetteObject.extend = extend;\n\n// Object Methods\n// --------------\n\n// Ensure it can trigger events with Backbone.Events\n_.extend(MarionetteObject.prototype, Backbone.Events, CommonMixin, RadioMixin, {\n  cidPrefix: 'mno',\n\n  // for parity with Marionette.AbstractView lifecyle\n  _isDestroyed: false,\n\n  isDestroyed() {\n    return this._isDestroyed;\n  },\n\n  //this is a noop method intended to be overridden by classes that extend from this base\n  initialize() {},\n\n  destroy(...args) {\n    if (this._isDestroyed) { return this; }\n\n    this.triggerMethod('before:destroy', this, ...args);\n\n    this._isDestroyed = true;\n    this.triggerMethod('destroy', this, ...args);\n    this.stopListening();\n\n    return this;\n  },\n\n  triggerMethod: triggerMethod\n});\n\nexport default MarionetteObject;\n","// Template Cache\n// --------------\n\nimport _               from 'underscore';\nimport Backbone        from 'backbone';\nimport MarionetteError from './error';\n\n// Manage templates stored in `<script>` blocks,\n// caching them for faster access.\nconst TemplateCache = function(templateId) {\n  this.templateId = templateId;\n};\n\n// TemplateCache object-level methods. Manage the template\n// caches from these method calls instead of creating\n// your own TemplateCache instances\n_.extend(TemplateCache, {\n  templateCaches: {},\n\n  // Get the specified template by id. Either\n  // retrieves the cached version, or loads it\n  // from the DOM.\n  get(templateId, options) {\n    let cachedTemplate = this.templateCaches[templateId];\n\n    if (!cachedTemplate) {\n      cachedTemplate = new TemplateCache(templateId);\n      this.templateCaches[templateId] = cachedTemplate;\n    }\n\n    return cachedTemplate.load(options);\n  },\n\n  // Clear templates from the cache. If no arguments\n  // are specified, clears all templates:\n  // `clear()`\n  //\n  // If arguments are specified, clears each of the\n  // specified templates from the cache:\n  // `clear(\"#t1\", \"#t2\", \"...\")`\n  clear(...args) {\n    let i;\n    const length = args.length;\n\n    if (length > 0) {\n      for (i = 0; i < length; i++) {\n        delete this.templateCaches[args[i]];\n      }\n    } else {\n      this.templateCaches = {};\n    }\n  }\n});\n\n// TemplateCache instance methods, allowing each\n// template cache object to manage its own state\n// and know whether or not it has been loaded\n_.extend(TemplateCache.prototype, {\n\n  // Internal method to load the template\n  load(options) {\n    // Guard clause to prevent loading this template more than once\n    if (this.compiledTemplate) {\n      return this.compiledTemplate;\n    }\n\n    // Load the template and compile it\n    const template = this.loadTemplate(this.templateId, options);\n    this.compiledTemplate = this.compileTemplate(template, options);\n\n    return this.compiledTemplate;\n  },\n\n  // Load a template from the DOM, by default. Override\n  // this method to provide your own template retrieval\n  // For asynchronous loading with AMD/RequireJS, consider\n  // using a template-loader plugin as described here:\n  // https://github.com/marionettejs/backbone.marionette/wiki/Using-marionette-with-requirejs\n  loadTemplate(templateId, options) {\n    const $template = Backbone.$(templateId);\n\n    if (!$template.length) {\n      throw new MarionetteError({\n        name: 'NoTemplateError',\n        message: `Could not find template: \"${templateId}\"`\n      });\n    }\n    return $template.html();\n  },\n\n  // Pre-compile the template before caching it. Override\n  // this method if you do not need to pre-compile a template\n  // (JST / RequireJS for example) or if you want to change\n  // the template engine used (Handebars, etc).\n  compileTemplate(rawTemplate, options) {\n    return _.template(rawTemplate, options);\n  }\n});\n\nexport default TemplateCache;\n","// Implementation of the invoke method (http://underscorejs.org/#invoke) with support for\n// lodash v3, v4, and underscore.js\nimport _ from 'underscore';\n\nexport default _.invokeMap || _.invoke;\n","import _ from 'underscore';\n\nimport {\n  bindEvents,\n  unbindEvents\n} from '../common/bind-events';\n\n// MixinOptions\n// - collectionEvents\n// - modelEvents\n\nexport default {\n  // Handle `modelEvents`, and `collectionEvents` configuration\n  _delegateEntityEvents(model, collection) {\n    this._undelegateEntityEvents(model, collection);\n\n    const modelEvents = _.result(this, 'modelEvents');\n    bindEvents.call(this, model, modelEvents);\n\n    const collectionEvents = _.result(this, 'collectionEvents');\n    bindEvents.call(this, collection, collectionEvents);\n  },\n\n  _undelegateEntityEvents(model, collection) {\n    const modelEvents = _.result(this, 'modelEvents');\n    unbindEvents.call(this, model, modelEvents);\n\n    const collectionEvents = _.result(this, 'collectionEvents');\n    unbindEvents.call(this, collection, collectionEvents);\n  }\n};\n","import _ from 'underscore';\n// allows for the use of the @ui. syntax within\n// a given key for triggers and events\n// swaps the @ui with the associated selector.\n// Returns a new, non-mutated, parsed events hash.\nconst normalizeUIKeys = function(hash, ui) {\n  return _.reduce(hash, (memo, val, key) => {\n    const normalizedKey = normalizeUIString(key, ui);\n    memo[normalizedKey] = val;\n    return memo;\n  }, {});\n};\n\n// utility method for parsing @ui. syntax strings\n// into associated selector\nconst normalizeUIString = function(uiString, ui) {\n  return uiString.replace(/@ui\\.[a-zA-Z_$0-9]*/g, (r) => {\n    return ui[r.slice(4)];\n  });\n};\n\n// allows for the use of the @ui. syntax within\n// a given value for regions\n// swaps the @ui with the associated selector\nconst normalizeUIValues = function(hash, ui, properties) {\n  _.each(hash, (val, key) => {\n    if (_.isString(val)) {\n      hash[key] = normalizeUIString(val, ui);\n    } else if (_.isObject(val) && _.isArray(properties)) {\n      _.extend(val, normalizeUIValues(_.pick(val, properties), ui));\n      /* Value is an object, and we got an array of embedded property names to normalize. */\n      _.each(properties, (property) => {\n        const propertyVal = val[property];\n        if (_.isString(propertyVal)) {\n          val[property] = normalizeUIString(propertyVal, ui);\n        }\n      });\n    }\n  });\n  return hash;\n};\n\nexport default {\n\n  // normalize the keys of passed hash with the views `ui` selectors.\n  // `{\"@ui.foo\": \"bar\"}`\n  normalizeUIKeys(hash) {\n    const uiBindings = this._getUIBindings();\n    return normalizeUIKeys(hash, uiBindings);\n  },\n\n  // normalize the values of passed hash with the views `ui` selectors.\n  // `{foo: \"@ui.bar\"}`\n  normalizeUIValues(hash, properties) {\n    const uiBindings = this._getUIBindings();\n    return normalizeUIValues(hash, uiBindings, properties);\n  },\n\n  _getUIBindings() {\n    const uiBindings = _.result(this, '_uiBindings');\n    const ui = _.result(this, 'ui');\n    return uiBindings || ui;\n  },\n\n  // This method binds the elements specified in the \"ui\" hash inside the view's code with\n  // the associated jQuery selectors.\n  _bindUIElements() {\n    if (!this.ui) { return; }\n\n    // store the ui hash in _uiBindings so they can be reset later\n    // and so re-rendering the view will be able to find the bindings\n    if (!this._uiBindings) {\n      this._uiBindings = this.ui;\n    }\n\n    // get the bindings result, as a function or otherwise\n    const bindings = _.result(this, '_uiBindings');\n\n    // empty the ui so we don't have anything to start with\n    this._ui = {};\n\n    // bind each of the selectors\n    _.each(bindings, (selector, key) => {\n      this._ui[key] = this.$(selector);\n    });\n\n    this.ui = this._ui;\n  },\n\n  _unbindUIElements() {\n    if (!this.ui || !this._uiBindings) { return; }\n\n    // delete all of the existing ui bindings\n    _.each(this.ui, ($el, name) => {\n      delete this.ui[name];\n    });\n\n    // reset the ui element to the original bindings configuration\n    this.ui = this._uiBindings;\n    delete this._uiBindings;\n    delete this._ui;\n  },\n\n  _getUI(name) {\n    return this._ui[name];\n  }\n};\n","// ViewMixin\n//  ---------\n\nimport Backbone from 'backbone';\nimport _ from 'underscore';\nimport isNodeAttached from '../common/is-node-attached';\nimport { triggerMethod } from '../common/trigger-method';\nimport BehaviorsMixin from './behaviors';\nimport CommonMixin from './common';\nimport DelegateEntityEventsMixin from './delegate-entity-events';\nimport TriggersMixin from './triggers';\nimport UIMixin from './ui';\nimport View from '../view';\nimport MarionetteError from '../error';\n\n// MixinOptions\n// - behaviors\n// - childViewEventPrefix\n// - childViewEvents\n// - childViewTriggers\n// - collectionEvents\n// - modelEvents\n// - triggers\n// - ui\n\n\nconst ViewMixin = {\n  supportsRenderLifecycle: true,\n  supportsDestroyLifecycle: true,\n\n  _isDestroyed: false,\n\n  isDestroyed() {\n    return !!this._isDestroyed;\n  },\n\n  _isRendered: false,\n\n  isRendered() {\n    return !!this._isRendered;\n  },\n\n  _isAttached: false,\n\n  isAttached() {\n    return !!this._isAttached;\n  },\n\n  // Overriding Backbone.View's `setElement` to handle\n  // if an el was previously defined. If so, the view might be\n  // rendered or attached on setElement.\n  setElement() {\n    const hasEl = !!this.el;\n\n    Backbone.View.prototype.setElement.apply(this, arguments);\n\n    if (hasEl) {\n      this._isRendered = !!this.$el.length;\n      this._isAttached = isNodeAttached(this.el);\n    }\n\n    return this;\n  },\n\n  // Overriding Backbone.View's `delegateEvents` to handle\n  // `events` and `triggers`\n  delegateEvents(eventsArg) {\n\n    this._proxyBehaviorViewProperties();\n    this._buildEventProxies();\n\n    const viewEvents = this._getEvents(eventsArg);\n\n    if (typeof eventsArg === 'undefined') {\n      this.events = viewEvents;\n    }\n\n    const combinedEvents = _.extend({},\n      this._getBehaviorEvents(),\n      viewEvents,\n      this._getBehaviorTriggers(),\n      this.getTriggers()\n    );\n\n    Backbone.View.prototype.delegateEvents.call(this, combinedEvents);\n\n    return this;\n  },\n\n  _getEvents(eventsArg) {\n    const events = eventsArg || this.events;\n\n    if (_.isFunction(events)) {\n      return this.normalizeUIKeys(events());\n    }\n\n    return this.normalizeUIKeys(events);\n  },\n\n  // Configure `triggers` to forward DOM events to view\n  // events. `triggers: {\"click .foo\": \"do:foo\"}`\n  getTriggers() {\n    if (!this.triggers) { return; }\n\n    // Allow `triggers` to be configured as a function\n    const triggers = this.normalizeUIKeys(_.result(this, 'triggers'));\n\n    // Configure the triggers, prevent default\n    // action and stop propagation of DOM events\n    return this._getViewTriggers(this, triggers);\n  },\n\n  // Handle `modelEvents`, and `collectionEvents` configuration\n  delegateEntityEvents() {\n    this._delegateEntityEvents(this.model, this.collection);\n\n    // bind each behaviors model and collection events\n    this._delegateBehaviorEntityEvents();\n\n    return this;\n  },\n\n  // Handle unbinding `modelEvents`, and `collectionEvents` configuration\n  undelegateEntityEvents() {\n    this._undelegateEntityEvents(this.model, this.collection);\n\n    // unbind each behaviors model and collection events\n    this._undelegateBehaviorEntityEvents();\n\n    return this;\n  },\n\n  // Internal helper method to verify whether the view hasn't been destroyed\n  _ensureViewIsIntact() {\n    if (this._isDestroyed) {\n      throw new MarionetteError({\n        name: 'ViewDestroyedError',\n        message: `View (cid: \"${this.cid}\") has already been destroyed and cannot be used.`\n      });\n    }\n  },\n\n  // Handle destroying the view and its children.\n  destroy(...args) {\n    if (this._isDestroyed) { return this; }\n    const shouldTriggerDetach = !!this._isAttached;\n\n    this.triggerMethod('before:destroy', this, ...args);\n    if (shouldTriggerDetach) {\n      this.triggerMethod('before:detach', this);\n    }\n\n    // unbind UI elements\n    this.unbindUIElements();\n\n    // remove the view from the DOM\n    // https://github.com/jashkenas/backbone/blob/1.2.3/backbone.js#L1235\n    this._removeElement();\n\n    if (shouldTriggerDetach) {\n      this._isAttached = false;\n      this.triggerMethod('detach', this);\n    }\n\n    // remove children after the remove to prevent extra paints\n    this._removeChildren();\n\n    this._destroyBehaviors(args);\n\n    this._isDestroyed = true;\n    this._isRendered = false;\n    this.triggerMethod('destroy', this, ...args);\n\n    this.stopListening();\n\n    return this;\n  },\n\n  bindUIElements() {\n    this._bindUIElements();\n    this._bindBehaviorUIElements();\n\n    return this;\n  },\n\n  // This method unbinds the elements specified in the \"ui\" hash\n  unbindUIElements() {\n    this._unbindUIElements();\n    this._unbindBehaviorUIElements();\n\n    return this;\n  },\n\n  getUI(name) {\n    this._ensureViewIsIntact();\n    return this._getUI(name);\n  },\n\n  // used as the prefix for child view events\n  // that are forwarded through the layoutview\n  childViewEventPrefix: 'childview',\n\n  // import the `triggerMethod` to trigger events with corresponding\n  // methods if the method exists\n  triggerMethod(...args) {\n    const ret = triggerMethod.apply(this, args);\n\n    this._triggerEventOnBehaviors(...args);\n    this._triggerEventOnParentLayout(...args);\n\n    return ret;\n  },\n\n  // Cache `childViewEvents` and `childViewTriggers`\n  _buildEventProxies() {\n    this._childViewEvents = _.result(this, 'childViewEvents');\n    this._childViewTriggers = _.result(this, 'childViewTriggers');\n  },\n\n  _triggerEventOnParentLayout(eventName, ...args) {\n    const layoutView = this._parentView();\n    if (!layoutView) {\n      return;\n    }\n\n    // invoke triggerMethod on parent view\n    const eventPrefix = _.result(layoutView, 'childViewEventPrefix');\n    const prefixedEventName = eventPrefix + ':' + eventName;\n\n    layoutView.triggerMethod(prefixedEventName, ...args);\n\n    // use the parent view's childViewEvents handler\n    const childViewEvents = layoutView.normalizeMethods(layoutView._childViewEvents);\n\n    if (!!childViewEvents && _.isFunction(childViewEvents[eventName])) {\n      childViewEvents[eventName].apply(layoutView, args);\n    }\n\n    // use the parent view's proxyEvent handlers\n    const childViewTriggers = layoutView._childViewTriggers;\n\n    // Call the event with the proxy name on the parent layout\n    if (childViewTriggers && _.isString(childViewTriggers[eventName])) {\n      layoutView.triggerMethod(childViewTriggers[eventName], ...args);\n    }\n  },\n\n  // Walk the _parent tree until we find a view (if one exists).\n  // Returns the parent view hierarchically closest to this view.\n  _parentView() {\n    let parent = this._parent;\n\n    while (parent) {\n      if (parent instanceof View) {\n        return parent;\n      }\n      parent = parent._parent;\n    }\n  }\n};\n\n_.extend(ViewMixin, BehaviorsMixin, CommonMixin, DelegateEntityEventsMixin, TriggersMixin,  UIMixin);\n\nexport default ViewMixin;\n","// Region\n// ------\n\nimport _ from 'underscore';\nimport Backbone from 'backbone';\nimport destroyBackboneView from './utils/destroy-backbone-view';\nimport monitorViewEvents from './common/monitor-view-events';\nimport isNodeAttached from './common/is-node-attached';\nimport { triggerMethodOn } from './common/trigger-method';\nimport MarionetteObject from './object';\nimport MarionetteError from './error';\n\nconst ClassOptions = [\n  'allowMissingEl',\n  'parentEl',\n  'replaceElement'\n];\n\nconst Region = MarionetteObject.extend({\n  cidPrefix: 'mnr',\n  replaceElement: false,\n  _isReplaced: false,\n\n  constructor(options) {\n    this._setOptions(options);\n\n    this.mergeOptions(options, ClassOptions);\n\n    // getOption necessary because options.el may be passed as undefined\n    this._initEl = this.el = this.getOption('el');\n\n    // Handle when this.el is passed in as a $ wrapped element.\n    this.el = this.el instanceof Backbone.$ ? this.el[0] : this.el;\n\n    if (!this.el) {\n      throw new MarionetteError({\n        name: 'NoElError',\n        message: 'An \"el\" must be specified for a region.'\n      });\n    }\n\n    this.$el = this.getEl(this.el);\n    MarionetteObject.call(this, options);\n  },\n\n  // Displays a backbone view instance inside of the region. Handles calling the `render`\n  // method for you. Reads content directly from the `el` attribute. The `preventDestroy`\n  // option can be used to prevent a view from the old view being destroyed on show.\n  show(view, options) {\n    if (!this._ensureElement(options)) {\n      return;\n    }\n    this._ensureView(view);\n    if (view === this.currentView) { return this; }\n\n    this.triggerMethod('before:show', this, view, options);\n\n    monitorViewEvents(view);\n\n    this.empty(options);\n\n    // We need to listen for if a view is destroyed in a way other than through the region.\n    // If this happens we need to remove the reference to the currentView since once a view\n    // has been destroyed we can not reuse it.\n    view.on('destroy', this.empty, this);\n\n    // Make this region the view's parent.\n    // It's important that this parent binding happens before rendering so that any events\n    // the child may trigger during render can also be triggered on the child's ancestor views.\n    view._parent = this;\n\n    this._renderView(view);\n\n    this._attachView(view, options);\n\n    this.triggerMethod('show', this, view, options);\n    return this;\n  },\n\n  _renderView(view) {\n    if (view._isRendered) {\n      return;\n    }\n\n    if (!view.supportsRenderLifecycle) {\n      triggerMethodOn(view, 'before:render', view);\n    }\n\n    view.render();\n\n    if (!view.supportsRenderLifecycle) {\n      view._isRendered = true;\n      triggerMethodOn(view, 'render', view);\n    }\n  },\n\n  _attachView(view, options = {}) {\n    const shouldTriggerAttach = !view._isAttached && isNodeAttached(this.el);\n    const shouldReplaceEl = typeof options.replaceElement === 'undefined' ? !!_.result(this, 'replaceElement') : !!options.replaceElement;\n\n    if (shouldTriggerAttach) {\n      triggerMethodOn(view, 'before:attach', view);\n    }\n\n    this.attachHtml(view, shouldReplaceEl);\n\n    if (shouldTriggerAttach) {\n      view._isAttached = true;\n      triggerMethodOn(view, 'attach', view);\n    }\n\n    this.currentView = view;\n  },\n\n  _ensureElement(options = {}) {\n    if (!_.isObject(this.el)) {\n      this.$el = this.getEl(this.el);\n      this.el = this.$el[0];\n    }\n\n    if (!this.$el || this.$el.length === 0) {\n      const allowMissingEl = typeof options.allowMissingEl === 'undefined' ? !!_.result(this, 'allowMissingEl') : !!options.allowMissingEl;\n\n      if (allowMissingEl) {\n        return false;\n      } else {\n        throw new MarionetteError(`An \"el\" must exist in DOM for this region ${this.cid}`);\n      }\n    }\n    return true;\n  },\n\n  _ensureView(view) {\n    if (!view) {\n      throw new MarionetteError({\n        name: 'ViewNotValid',\n        message: 'The view passed is undefined and therefore invalid. You must pass a view instance to show.'\n      });\n    }\n\n    if (view._isDestroyed) {\n      throw new MarionetteError({\n        name: 'ViewDestroyedError',\n        message: `View (cid: \"${view.cid}\") has already been destroyed and cannot be used.`\n      });\n    }\n  },\n\n  // Override this method to change how the region finds the DOM element that it manages. Return\n  // a jQuery selector object scoped to a provided parent el or the document if none exists.\n  getEl(el) {\n    return Backbone.$(el, _.result(this, 'parentEl'));\n  },\n\n  _replaceEl(view) {\n    // always restore the el to ensure the regions el is present before replacing\n    this._restoreEl();\n\n    const parent = this.el.parentNode;\n\n    parent.replaceChild(view.el, this.el);\n    this._isReplaced = true;\n  },\n\n  // Restore the region's element in the DOM.\n  _restoreEl() {\n    if (!this.currentView) {\n      return;\n    }\n\n    const view = this.currentView;\n    const parent = view.el.parentNode;\n\n    if (!parent) {\n      return;\n    }\n\n    parent.replaceChild(this.el, view.el);\n    this._isReplaced = false;\n  },\n\n  isReplaced() {\n    return !!this._isReplaced;\n  },\n\n  // Override this method to change how the new view is appended to the `$el` that the\n  // region is managing\n  attachHtml(view, shouldReplace) {\n    if (shouldReplace) {\n      // replace the region's node with the view's node\n      this._replaceEl(view);\n    } else {\n      this.el.appendChild(view.el);\n    }\n  },\n\n  // Destroy the current view, if there is one. If there is no current view, it does\n  // nothing and returns immediately.\n  empty(options = { allowMissingEl: true }) {\n    const view = this.currentView;\n\n    // If there is no view in the region we should only detach current html\n    if (!view) {\n      if (this._ensureElement(options)) {\n        this.detachHtml();\n      }\n      return this;\n    }\n\n    view.off('destroy', this.empty, this);\n    this.triggerMethod('before:empty', this, view);\n\n    if (this._isReplaced) {\n      this._restoreEl();\n    }\n\n    delete this.currentView;\n\n    if (!view._isDestroyed) {\n      this._removeView(view, options);\n      delete view._parent;\n    }\n\n    this.triggerMethod('empty', this, view);\n    return this;\n  },\n\n  _removeView(view, {preventDestroy} = {}) {\n    const shouldPreventDestroy = !!preventDestroy;\n\n    if (shouldPreventDestroy) {\n      this._detachView(view);\n      return;\n    }\n\n    if (view.destroy) {\n      view.destroy();\n    } else {\n      destroyBackboneView(view);\n    }\n  },\n\n  _detachView(view) {\n    const shouldTriggerDetach = !!view._isAttached;\n    if (shouldTriggerDetach) {\n      triggerMethodOn(view, 'before:detach', view);\n    }\n\n    this.detachHtml();\n\n    if (shouldTriggerDetach) {\n      view._isAttached = false;\n      triggerMethodOn(view, 'detach', view);\n    }\n  },\n\n  // Override this method to change how the region detaches current content\n  detachHtml() {\n    this.$el.contents().detach();\n  },\n\n  // Checks whether a view is currently present within the region. Returns `true` if there is\n  // and `false` if no view is present.\n  hasView() {\n    return !!this.currentView;\n  },\n\n  // Reset the region by destroying any existing view and clearing out the cached `$el`.\n  // The next time a view is shown via this region, the region will re-query the DOM for\n  // the region's `el`.\n  reset(options) {\n    this.empty(options);\n\n    if (this.$el) {\n      this.el = this._initEl;\n    }\n\n    delete this.$el;\n    return this;\n  },\n\n  destroy(options) {\n    this.reset(options);\n    return MarionetteObject.prototype.destroy.apply(this, arguments);\n  }\n});\n\nexport default Region;\n","import _                    from 'underscore';\nimport _invoke              from '../utils/invoke';\nimport Region               from '../region';\nimport MarionetteError      from '../error';\n\n// MixinOptions\n// - regions\n// - regionClass\n\nexport default {\n  regionClass: Region,\n\n  // Internal method to initialize the regions that have been defined in a\n  // `regions` attribute on this View.\n  _initRegions() {\n\n    // init regions hash\n    this.regions =  this.regions || {};\n    this._regions = {};\n\n    this.addRegions(_.result(this, 'regions'));\n  },\n\n  // Internal method to re-initialize all of the regions by updating\n  // the `el` that they point to\n  _reInitRegions() {\n    _invoke(this._regions, 'reset');\n  },\n\n  // Add a single region, by name, to the View\n  addRegion(name, definition) {\n    const regions = {};\n    regions[name] = definition;\n    return this.addRegions(regions)[name];\n  },\n\n  // Add multiple regions as a {name: definition, name2: def2} object literal\n  addRegions(regions) {\n    // If there's nothing to add, stop here.\n    if (_.isEmpty(regions)) {\n      return;\n    }\n\n    // Normalize region selectors hash to allow\n    // a user to use the @ui. syntax.\n    regions = this.normalizeUIValues(regions, ['selector', 'el']);\n\n    // Add the regions definitions to the regions property\n    this.regions = _.extend({}, this.regions, regions);\n\n    return this._addRegions(regions);\n  },\n\n  // internal method to build and add regions\n  _addRegions(regionDefinitions) {\n    return _.reduce(regionDefinitions, (regions, definition, name) => {\n      regions[name] = this._buildRegion(definition);\n      this._addRegion(regions[name], name);\n      return regions;\n    }, {});\n  },\n\n  // return the region instance from the definition\n  _buildRegion(definition) {\n    if (definition instanceof Region) {\n      return definition;\n    }\n\n    return this._buildRegionFromDefinition(definition);\n  },\n\n  _buildRegionFromDefinition(definition) {\n    if (_.isString(definition)) {\n      return this._buildRegionFromObject({el: definition});\n    }\n\n    if (_.isFunction(definition)) {\n      return this._buildRegionFromRegionClass(definition);\n    }\n\n    if (_.isObject(definition)) {\n      return this._buildRegionFromObject(definition);\n    }\n\n    throw new MarionetteError({\n      message: 'Improper region configuration type.',\n      url: 'marionette.region.html#region-configuration-types'\n    });\n  },\n\n  _buildRegionFromObject(definition) {\n    const RegionClass = definition.regionClass || this.regionClass;\n\n    const options = _.omit(definition, 'regionClass');\n\n    _.defaults(options, {\n      el: definition.selector,\n      parentEl: _.partial(_.result, this, 'el')\n    });\n\n    return new RegionClass(options);\n  },\n\n  // Build the region directly from a given `RegionClass`\n  _buildRegionFromRegionClass(RegionClass) {\n    return new RegionClass({\n      parentEl: _.partial(_.result, this, 'el')\n    });\n  },\n\n  _addRegion(region, name) {\n    this.triggerMethod('before:add:region', this, name, region);\n\n    region._parent = this;\n\n    this._regions[name] = region;\n\n    this.triggerMethod('add:region', this, name, region);\n  },\n\n  // Remove a single region from the View, by name\n  removeRegion(name) {\n    const region = this._regions[name];\n\n    this._removeRegion(region, name);\n\n    return region;\n  },\n\n  // Remove all regions from the View\n  removeRegions() {\n    const regions = this.getRegions();\n\n    _.each(this._regions, _.bind(this._removeRegion, this));\n\n    return regions;\n  },\n\n  _removeRegion(region, name) {\n    this.triggerMethod('before:remove:region', this, name, region);\n\n    region.empty();\n    region.stopListening();\n\n    delete this.regions[name];\n    delete this._regions[name];\n\n    this.triggerMethod('remove:region', this, name, region);\n  },\n\n  // Empty all regions in the region manager, but\n  // leave them attached\n  emptyRegions() {\n    const regions = this.getRegions();\n    _invoke(regions, 'empty');\n    return regions;\n  },\n\n  // Checks to see if view contains region\n  // Accepts the region name\n  // hasRegion('main')\n  hasRegion(name) {\n    return !!this.getRegion(name);\n  },\n\n  // Provides access to regions\n  // Accepts the region name\n  // getRegion('main')\n  getRegion(name) {\n    return this._regions[name];\n  },\n\n  // Get all regions\n  getRegions() {\n    return _.clone(this._regions);\n  },\n\n  showChildView(name, view, ...args) {\n    const region = this.getRegion(name);\n    return region.show(view, ...args);\n  },\n\n  getChildView(name) {\n    return this.getRegion(name).currentView;\n  }\n\n};\n","// Renderer\n// --------\n\nimport _               from 'underscore';\nimport MarionetteError from '../error';\nimport TemplateCache   from '../template-cache';\n\n// Render a template with data by passing in the template\n// selector and the data to render.\nconst Renderer = {\n\n  // Render a template with data. The `template` parameter is\n  // passed to the `TemplateCache` object to retrieve the\n  // template function. Override this method to provide your own\n  // custom rendering and template handling for all of Marionette.\n  render(template, data) {\n    if (!template) {\n      throw new MarionetteError({\n        name: 'TemplateNotFoundError',\n        message: 'Cannot render the template since its false, null or undefined.'\n      });\n    }\n\n    const templateFunc = _.isFunction(template) ? template : TemplateCache.get(template);\n\n    return templateFunc(data);\n  }\n};\n\nexport default Renderer;\n","// View\n// ---------\n\nimport _                  from 'underscore';\nimport Backbone           from 'backbone';\nimport monitorViewEvents  from './common/monitor-view-events';\nimport ViewMixin          from './mixins/view';\nimport RegionsMixin       from './mixins/regions';\nimport Renderer           from './config/renderer';\n\nconst ClassOptions = [\n  'behaviors',\n  'childViewEventPrefix',\n  'childViewEvents',\n  'childViewTriggers',\n  'collectionEvents',\n  'events',\n  'modelEvents',\n  'regionClass',\n  'regions',\n  'template',\n  'templateContext',\n  'triggers',\n  'ui'\n];\n\n// The standard view. Includes view events, automatic rendering\n// of Underscore templates, nested views, and more.\nconst View = Backbone.View.extend({\n\n  constructor(options) {\n    this.render = _.bind(this.render, this);\n\n    this._setOptions(options);\n\n    this.mergeOptions(options, ClassOptions);\n\n    monitorViewEvents(this);\n\n    this._initBehaviors();\n    this._initRegions();\n\n    const args = Array.prototype.slice.call(arguments);\n    args[0] = this.options;\n    Backbone.View.prototype.constructor.apply(this, args);\n\n    this.delegateEntityEvents();\n  },\n\n  // Serialize the view's model *or* collection, if\n  // it exists, for the template\n  serializeData() {\n    if (!this.model && !this.collection) {\n      return {};\n    }\n\n    // If we have a model, we serialize that\n    if (this.model) {\n      return this.serializeModel();\n    }\n\n    // Otherwise, we serialize the collection,\n    // making it available under the `items` property\n    return {\n      items: this.serializeCollection()\n    };\n  },\n\n  // Prepares the special `model` property of a view\n  // for being displayed in the template. By default\n  // we simply clone the attributes. Override this if\n  // you need a custom transformation for your view's model\n  serializeModel() {\n    if (!this.model) { return {}; }\n    return _.clone(this.model.attributes);\n  },\n\n  // Serialize a collection by cloning each of\n  // its model's attributes\n  serializeCollection() {\n    if (!this.collection) { return {}; }\n    return this.collection.map(function(model) { return _.clone(model.attributes); });\n  },\n\n  // Render the view, defaulting to underscore.js templates.\n  // You can override this in your view definition to provide\n  // a very specific rendering for your view. In general, though,\n  // you should override the `Marionette.Renderer` object to\n  // change how Marionette renders views.\n  // Subsequent renders after the first will re-render all nested\n  // views.\n  render() {\n    this._ensureViewIsIntact();\n\n    this.triggerMethod('before:render', this);\n\n    // If this is not the first render call, then we need to\n    // re-initialize the `el` for each region\n    if (this._isRendered) {\n      this._reInitRegions();\n    }\n\n    this._renderTemplate();\n    this.bindUIElements();\n\n    this._isRendered = true;\n    this.triggerMethod('render', this);\n\n    return this;\n  },\n\n  // Internal method to render the template with the serialized data\n  // and template context via the `Marionette.Renderer` object.\n  _renderTemplate() {\n    const template = this.getTemplate();\n\n    // Allow template-less views\n    if (template === false) {\n      return;\n    }\n\n    // Add in entity data and template context\n    const data = this.mixinTemplateContext(this.serializeData());\n\n    // Render and add to el\n    const html = Renderer.render(template, data, this);\n    this.attachElContent(html);\n  },\n\n  // Get the template for this view\n  // instance. You can set a `template` attribute in the view\n  // definition or pass a `template: \"whatever\"` parameter in\n  // to the constructor options.\n  getTemplate() {\n    return this.template;\n  },\n\n  // Mix in template context methods. Looks for a\n  // `templateContext` attribute, which can either be an\n  // object literal, or a function that returns an object\n  // literal. All methods and attributes from this object\n  // are copies to the object passed in.\n  mixinTemplateContext(target = {}) {\n    const templateContext = _.result(this, 'templateContext');\n    return _.extend(target, templateContext);\n  },\n\n  // Attaches the content of a given view.\n  // This method can be overridden to optimize rendering,\n  // or to render in a non standard way.\n  //\n  // For example, using `innerHTML` instead of `$el.html`\n  //\n  // ```js\n  // attachElContent(html) {\n  //   this.el.innerHTML = html;\n  //   return this;\n  // }\n  // ```\n  attachElContent(html) {\n    this.$el.html(html);\n\n    return this;\n  },\n\n  // called by ViewMixin destroy\n  _removeChildren() {\n    this.removeRegions();\n  },\n\n  _getImmediateChildren() {\n    return _.chain(this.getRegions())\n      .map('currentView')\n      .compact()\n      .value();\n  }\n});\n\n_.extend(View.prototype, ViewMixin, RegionsMixin);\n\nexport default View;\n","// Backbone.BabySitter\n// -------------------\n// v1.0.0-pre.1\n//\n// Copyright (c)2016 Derick Bailey, Muted Solutions, LLC.\n// Distributed under MIT license\n//\n// http://github.com/marionettejs/backbone.babysitter\n\n(function(root, factory) {\n\n  if (typeof define === 'function' && define.amd) {\n    define(['backbone', 'underscore'], function(Backbone, _) {\n      return factory(Backbone, _);\n    });\n  } else if (typeof exports !== 'undefined') {\n    var Backbone = require('backbone');\n    var _ = require('underscore');\n    module.exports = factory(Backbone, _);\n  } else {\n    factory(root.Backbone, root._);\n  }\n\n}(this, function(Backbone, _) {\n  'use strict';\n\n  var previousChildViewContainer = Backbone.ChildViewContainer;\n\n  // BabySitter.ChildViewContainer\n  // -----------------------------\n  //\n  // Provide a container to store, retrieve and\n  // shut down child views.\n  \n  Backbone.ChildViewContainer = (function (Backbone, _) {\n  \n    // Container Constructor\n    // ---------------------\n  \n    var Container = function(views){\n      this._views = {};\n      this._indexByModel = {};\n      this._indexByCustom = {};\n      this._updateLength();\n  \n      _.each(views, _.bind(this.add, this));\n    };\n  \n    // Container Methods\n    // -----------------\n  \n    _.extend(Container.prototype, {\n  \n      // Add a view to this container. Stores the view\n      // by `cid` and makes it searchable by the model\n      // cid (and model itself). Optionally specify\n      // a custom key to store an retrieve the view.\n      add: function(view, customIndex){\n        return this._add(view, customIndex)\n                   ._updateLength();\n      },\n  \n      // Find a view by the model that was attached to\n      // it. Uses the model's `cid` to find it.\n      findByModel: function(model){\n        return this.findByModelCid(model.cid);\n      },\n  \n      // Find a view by the `cid` of the model that was attached to\n      // it. Uses the model's `cid` to find the view `cid` and\n      // retrieve the view using it.\n      findByModelCid: function(modelCid){\n        var viewCid = this._indexByModel[modelCid];\n        return this.findByCid(viewCid);\n      },\n  \n      // Find a view by a custom indexer.\n      findByCustom: function(index){\n        var viewCid = this._indexByCustom[index];\n        return this.findByCid(viewCid);\n      },\n  \n      // Find by index. This is not guaranteed to be a\n      // stable index.\n      findByIndex: function(index){\n        return _.values(this._views)[index];\n      },\n  \n      // retrieve a view by its `cid` directly\n      findByCid: function(cid){\n        return this._views[cid];\n      },\n  \n      // Remove a view\n      remove: function(view){\n        return this._remove(view)\n                   ._updateLength();\n      },\n  \n      // Call a method on every view in the container,\n      // passing parameters to the call method one at a\n      // time, like `function.call`.\n      call: function(method){\n        this.apply(method, _.toArray(arguments).slice(1));\n      },\n  \n      // Apply a method on every view in the container,\n      // passing parameters to the call method one at a\n      // time, like `function.apply`.\n      apply: function(method, args){\n        _.each(this._views, function(view){\n          if (_.isFunction(view[method])){\n            view[method].apply(view, args || []);\n          }\n        });\n      },\n  \n      // Update the `.length` attribute on this container\n      _updateLength: function(){\n        this.length = _.size(this._views);\n  \n        return this;\n      },\n      // To be used when avoiding call _updateLength\n      // When you are done adding all your new views\n      // call _updateLength\n      _add: function(view, customIndex){\n        var viewCid = view.cid;\n  \n        // store the view\n        this._views[viewCid] = view;\n  \n        // index it by model\n        if (view.model){\n          this._indexByModel[view.model.cid] = viewCid;\n        }\n  \n        // index by custom\n        if (customIndex){\n          this._indexByCustom[customIndex] = viewCid;\n        }\n  \n        return this;\n      },\n      // To be used when avoiding call _updateLength\n      // When you are done adding all your new views\n      // call _updateLength\n      _remove: function (view){\n        var viewCid = view.cid;\n  \n        // delete model index\n        if (view.model){\n          delete this._indexByModel[view.model.cid];\n        }\n  \n        // delete custom index\n        _.some(this._indexByCustom, _.bind(function(cid, key) {\n          if (cid === viewCid) {\n            delete this._indexByCustom[key];\n            return true;\n          }\n        }, this));\n  \n        // remove the view from the container\n        delete this._views[viewCid];\n  \n        return this;\n      }\n    });\n  \n    // Borrowing this code from Backbone.Collection:\n    // http://backbonejs.org/docs/backbone.html#section-106\n    //\n    // Mix in methods from Underscore, for iteration, and other\n    // collection related features.\n    var methods = ['forEach', 'each', 'map', 'find', 'detect', 'filter',\n      'select', 'reject', 'every', 'all', 'some', 'any', 'include',\n      'contains', 'invoke', 'toArray', 'first', 'initial', 'rest',\n      'last', 'without', 'isEmpty', 'pluck', 'reduce'];\n  \n    _.each(methods, function(method) {\n      Container.prototype[method] = function() {\n        var views = _.values(this._views);\n        var args = [views].concat(_.toArray(arguments));\n        return _[method].apply(_, args);\n      };\n    });\n  \n    // return the public API\n    return Container;\n  })(Backbone, _);\n  \n\n  Backbone.ChildViewContainer.VERSION = '1.0.0-pre.1';\n\n  Backbone.ChildViewContainer.noConflict = function () {\n    Backbone.ChildViewContainer = previousChildViewContainer;\n    return this;\n  };\n\n  return Backbone.ChildViewContainer;\n\n}));\n","// Collection View\n// ---------------\n\nimport _                  from 'underscore';\nimport Backbone           from 'backbone';\nimport ChildViewContainer from 'backbone.babysitter';\nimport destroyBackboneView from './utils/destroy-backbone-view';\nimport monitorViewEvents  from './common/monitor-view-events';\nimport { triggerMethodOn } from './common/trigger-method';\nimport MarionetteError    from './error';\nimport ViewMixin          from './mixins/view';\n\nconst ClassOptions = [\n  'behaviors',\n  'childView',\n  'childViewEventPrefix',\n  'childViewEvents',\n  'childViewOptions',\n  'childViewTriggers',\n  'collectionEvents',\n  'events',\n  'filter',\n  'emptyView',\n  'emptyViewOptions',\n  'modelEvents',\n  'reorderOnSort',\n  'sort',\n  'triggers',\n  'ui',\n  'viewComparator'\n];\n\n// A view that iterates over a Backbone.Collection\n// and renders an individual child view for each model.\nconst CollectionView = Backbone.View.extend({\n\n  // flag for maintaining the sorted order of the collection\n  sort: true,\n\n  // constructor\n  // option to pass `{sort: false}` to prevent the `CollectionView` from\n  // maintaining the sorted order of the collection.\n  // This will fallback onto appending childView's to the end.\n  //\n  // option to pass `{viewComparator: compFunction()}` to allow the `CollectionView`\n  // to use a custom sort order for the collection.\n  constructor(options) {\n    this.render = _.bind(this.render, this);\n\n    this._setOptions(options);\n\n    this.mergeOptions(options, ClassOptions);\n\n    monitorViewEvents(this);\n\n    this._initBehaviors();\n    this.once('render', this._initialEvents);\n    this._initChildViewStorage();\n    this._bufferedChildren = [];\n\n    const args = Array.prototype.slice.call(arguments);\n    args[0] = this.options;\n    Backbone.View.prototype.constructor.apply(this, args);\n\n    this.delegateEntityEvents();\n  },\n\n  // Instead of inserting elements one by one into the page, it's much more performant to insert\n  // elements into a document fragment and then insert that document fragment into the page\n  _startBuffering() {\n    this._isBuffering = true;\n  },\n\n  _endBuffering() {\n    const shouldTriggerAttach = !!this._isAttached;\n    const triggerOnChildren = shouldTriggerAttach ? this._getImmediateChildren() : [];\n\n    this._isBuffering = false;\n\n    _.each(triggerOnChildren, child => {\n      triggerMethodOn(child, 'before:attach', child);\n    });\n\n    this.attachBuffer(this, this._createBuffer());\n\n    _.each(triggerOnChildren, child => {\n      child._isAttached = true;\n      triggerMethodOn(child, 'attach', child);\n    });\n\n    this._bufferedChildren = [];\n  },\n\n  _getImmediateChildren() {\n    return _.values(this.children._views);\n  },\n\n  // Configured the initial events that the collection view binds to.\n  _initialEvents() {\n    if (this.collection) {\n      this.listenTo(this.collection, 'add', this._onCollectionAdd);\n      this.listenTo(this.collection, 'update', this._onCollectionUpdate);\n      this.listenTo(this.collection, 'reset', this.render);\n\n      if (this.sort) {\n        this.listenTo(this.collection, 'sort', this._sortViews);\n      }\n    }\n  },\n\n  // Handle a child added to the collection\n  _onCollectionAdd(child, collection, opts) {\n    // `index` is present when adding with `at` since BB 1.2; indexOf fallback for < 1.2\n    let index = opts.at !== undefined && (opts.index || collection.indexOf(child));\n\n    // When filtered or when there is no initial index, calculate index.\n    if (this.filter || index === false) {\n      index = _.indexOf(this._filteredSortedModels(index), child);\n    }\n\n    if (this._shouldAddChild(child, index)) {\n      this._destroyEmptyView();\n      const ChildView = this._getChildView(child);\n      this._addChild(child, ChildView, index);\n    }\n  },\n\n  // Handle collection update model removals\n  _onCollectionUpdate(collection, options) {\n    const removed = options.changes.removed;\n    const isRemoving = _.isArray(removed) && removed.length;\n\n    if (isRemoving) {\n      this._removeChildViews(removed);\n    }\n  },\n\n  // Remove the child views and destroy them.\n  // This function also updates the indices of later views\n  // in the collection in order to keep the children in sync with the collection.\n  // Return array of views where the first view has the index that\n  // tells CollectionView#_updateIndices where to start syncing remaining\n  // view indices.\n  _removeChildViews(modelsOrViews, {checkEmpty} = {}) {\n    if (!modelsOrViews.length) {\n      return modelsOrViews;\n    }\n\n    const shouldCheckEmpty = checkEmpty !== false;\n\n    // Used to determine where to update the remaining\n    // sibling view indices after these views are removed.\n    const removedViews = _.reduce(modelsOrViews, (removingViews, modelOrView) => {\n      let view = modelOrView;\n\n      if (modelOrView instanceof Backbone.Model) {\n        view = this.children.findByModel(modelOrView);\n      }\n\n      if (!view || view._isDestroyed) {\n        return removingViews;\n      }\n\n      if (!removingViews.length || removingViews[0]._index > view._index) {\n        removingViews.unshift(view);\n      }\n\n      this.triggerMethod('before:remove:child', this, view);\n\n      // everything after this could be async destructed\n      this.children._remove(view);\n      if (view.destroy) {\n        view.destroy();\n      } else {\n        destroyBackboneView(view);\n      }\n\n      view._parent = void 0;\n      this.stopListening(view);\n      this.triggerMethod('remove:child', this, view);\n\n      return removingViews;\n    }, []);\n\n    if (!removedViews.length) {\n      return removedViews;\n    }\n\n    this.children._updateLength();\n    // decrement the index of views after this one\n    this._updateIndices(removedViews[0], false);\n\n    if (shouldCheckEmpty) {\n      this._checkEmpty();\n    }\n\n    return removedViews;\n  },\n\n  // Render children views. Override this method to provide your own implementation of a\n  // render function for the collection view.\n  render() {\n    this._ensureViewIsIntact();\n    this.triggerMethod('before:render', this);\n    this._renderChildren();\n    this._isRendered = true;\n    this.triggerMethod('render', this);\n    return this;\n  },\n\n  // An efficient rendering used for filtering. Instead of modifying the whole DOM for the\n  // collection view, we are only adding or removing the related childrenViews.\n  setFilter(filter, {preventRender} = {}) {\n    const canBeRendered = this._isRendered && !this._isDestroyed;\n    const filterChanged = this.filter !== filter;\n    const shouldRender = canBeRendered && filterChanged && !preventRender;\n\n    if (shouldRender) {\n      const previousModels = this._filteredSortedModels();\n      this.filter = filter;\n      const models = this._filteredSortedModels();\n      this._applyModelDeltas(models, previousModels);\n    } else {\n      this.filter = filter;\n    }\n    return this;\n  },\n\n  // `removeFilter` is actually an alias for removing filters.\n  removeFilter(options) {\n    this.setFilter(null, options);\n    return this;\n  },\n\n  // Calculate and apply difference by cid between `models` and `previousModels`.\n  _applyModelDeltas(models, previousModels) {\n    const currentIds = {};\n    _.each(models, (model, index) => {\n      const addedChildNotExists = !this.children.findByModel(model);\n      if (addedChildNotExists) {\n        this._onCollectionAdd(model, this.collection, {at: index});\n      }\n      currentIds[model.cid] = true;\n    });\n\n    const removeModel = _.filter(previousModels, (prevModel) => {\n      return !currentIds[prevModel.cid] && this.children.findByModel(prevModel);\n    });\n\n    this._removeChildViews(removeModel);\n  },\n\n  // Reorder DOM after sorting. When your element's rendering do not use their index,\n  // you can pass reorderOnSort: true to only reorder the DOM after a sort instead of\n  // rendering all the collectionView.\n  reorder() {\n    const children = this.children;\n    const models = this._filteredSortedModels();\n\n    if (!models.length && this._showingEmptyView) { return this; }\n\n    const anyModelsAdded = _.some(models, function(model) {\n      return !children.findByModel(model);\n    });\n\n    // If there are any new models added due to filtering we need to add child views,\n    // so render as normal.\n    if (anyModelsAdded) {\n      this.render();\n    } else {\n      // Get the DOM nodes in the same order as the models.\n      const elsToReorder = _.map(models, function(model, index) {\n        const view = children.findByModel(model);\n        view._index = index;\n        return view.el;\n      });\n\n      // Find the views that were children before but aren't in this new ordering.\n      const filteredOutViews = children.filter(function(view) {\n        return !_.contains(elsToReorder, view.el);\n      });\n\n      this.triggerMethod('before:reorder', this);\n\n      // Since append moves elements that are already in the DOM, appending the elements\n      // will effectively reorder them.\n      this._appendReorderedChildren(elsToReorder);\n\n      // remove any views that have been filtered out\n      this._removeChildViews(filteredOutViews);\n\n      this.triggerMethod('reorder', this);\n    }\n    return this;\n  },\n\n  // Render view after sorting. Override this method to change how the view renders\n  // after a `sort` on the collection.\n  resortView() {\n    if (this.reorderOnSort) {\n      this.reorder();\n    } else {\n      this._renderChildren();\n    }\n    return this;\n  },\n\n  // Internal method. This checks for any changes in the order of the collection.\n  // If the index of any view doesn't match, it will render.\n  _sortViews() {\n    const models = this._filteredSortedModels();\n\n    // check for any changes in sort order of views\n    const orderChanged = _.find(models, (item, index) => {\n      const view = this.children.findByModel(item);\n      return !view || view._index !== index;\n    });\n\n    if (orderChanged) {\n      this.resortView();\n    }\n  },\n\n  // Internal reference to what index a `emptyView` is.\n  _emptyViewIndex: -1,\n\n  // Internal method. Separated so that CompositeView can append to the childViewContainer\n  // if necessary\n  _appendReorderedChildren(children) {\n    this.$el.append(children);\n  },\n\n  // Internal method. Separated so that CompositeView can have more control over events\n  // being triggered, around the rendering process\n  _renderChildren() {\n    if (this._isRendered) {\n      this._destroyEmptyView();\n      this._destroyChildren({checkEmpty: false});\n    }\n\n    const models = this._filteredSortedModels();\n    if (this.isEmpty({processedModels: models})) {\n      this._showEmptyView();\n    } else {\n      this.triggerMethod('before:render:children', this);\n      this._startBuffering();\n      this._showCollection(models);\n      this._endBuffering();\n      this.triggerMethod('render:children', this);\n    }\n  },\n\n  // Internal method to loop through collection and show each child view.\n  _showCollection(models) {\n    _.each(models, (child, index) => {\n      const ChildView = this._getChildView(child);\n      this._addChild(child, ChildView, index);\n    });\n  },\n\n  // Allow the collection to be sorted by a custom view comparator\n  _filteredSortedModels(addedAt) {\n    if (!this.collection) { return []; }\n\n    const viewComparator = this.getViewComparator();\n    let models = this.collection.models;\n    addedAt = Math.min(Math.max(addedAt, 0), models.length - 1);\n\n    if (viewComparator) {\n      let addedModel;\n      // Preserve `at` location, even for a sorted view\n      if (addedAt) {\n        addedModel = models[addedAt];\n        models = models.slice(0, addedAt).concat(models.slice(addedAt + 1));\n      }\n      models = this._sortModelsBy(models, viewComparator);\n      if (addedModel) {\n        models.splice(addedAt, 0, addedModel);\n      }\n    }\n\n    // Filter after sorting in case the filter uses the index\n    models = this._filterModels(models);\n\n    return models;\n  },\n\n  getViewComparator() {\n    return this.viewComparator;\n  },\n\n  // Filter an array of models, if a filter exists\n  _filterModels(models) {\n    if (this.filter) {\n      models = _.filter(models, (model, index) => {\n        return this._shouldAddChild(model, index);\n      });\n    }\n    return models;\n  },\n\n  _sortModelsBy(models, comparator) {\n    if (typeof comparator === 'string') {\n      return _.sortBy(models, (model) => {\n        return model.get(comparator);\n      });\n    } else if (comparator.length === 1) {\n      return _.sortBy(models, _.bind(comparator, this));\n    } else {\n      return models.sort(_.bind(comparator, this));\n    }\n  },\n\n  // Internal method to show an empty view in place of a collection of child views,\n  // when the collection is empty\n  _showEmptyView() {\n    const EmptyView = this._getEmptyView();\n\n    if (EmptyView && !this._showingEmptyView) {\n      this._showingEmptyView = true;\n\n      const model = new Backbone.Model();\n      let emptyViewOptions =\n        this.emptyViewOptions || this.childViewOptions;\n      if (_.isFunction(emptyViewOptions)) {\n        emptyViewOptions = emptyViewOptions.call(this, model, this._emptyViewIndex);\n      }\n\n      const view = this.buildChildView(model, EmptyView, emptyViewOptions);\n\n      this.triggerMethod('before:render:empty', this, view);\n      this._addChildView(view, 0);\n      this.triggerMethod('render:empty', this, view);\n\n      view._parent = this;\n    }\n  },\n\n  // Internal method to destroy an existing emptyView instance if one exists. Called when\n  // a collection view has been rendered empty, and then a child is added to the collection.\n  _destroyEmptyView() {\n    if (this._showingEmptyView) {\n      this.triggerMethod('before:remove:empty', this);\n\n      this._destroyChildren();\n      delete this._showingEmptyView;\n\n      this.triggerMethod('remove:empty', this);\n    }\n  },\n\n  // Retrieve the empty view class\n  _getEmptyView() {\n    const emptyView = this.emptyView;\n\n    if (!emptyView) { return; }\n\n    return this._getView(emptyView);\n  },\n\n  // Retrieve the `childView` class\n  // The `childView` property can be either a view class or a function that\n  // returns a view class. If it is a function, it will receive the model that\n  // will be passed to the view instance (created from the returned view class)\n  _getChildView(child) {\n    let childView = this.childView;\n\n    if (!childView) {\n      throw new MarionetteError({\n        name: 'NoChildViewError',\n        message: 'A \"childView\" must be specified'\n      });\n    }\n\n    childView = this._getView(childView, child);\n\n    if (!childView) {\n      throw new MarionetteError({\n        name: 'InvalidChildViewError',\n        message: '\"childView\" must be a view class or a function that returns a view class'\n      });\n    }\n\n    return childView;\n  },\n\n  // First check if the `view` is a view class (the common case)\n  // Then check if it's a function (which we assume that returns a view class)\n  _getView(view, child) {\n    if (view.prototype instanceof Backbone.View || view === Backbone.View) {\n      return view;\n    } else if (_.isFunction(view)) {\n      return view.call(this, child);\n    }\n  },\n\n  // Internal method for building and adding a child view\n  _addChild(child, ChildView, index) {\n    const childViewOptions = this._getChildViewOptions(child, index);\n\n    const view = this.buildChildView(child, ChildView, childViewOptions);\n\n    this.addChildView(view, index);\n\n    return view;\n  },\n\n  _getChildViewOptions(child, index) {\n    if (_.isFunction(this.childViewOptions)) {\n      return this.childViewOptions(child, index);\n    }\n\n    return this.childViewOptions;\n  },\n\n  // Render the child's view and add it to the HTML for the collection view at a given index.\n  // This will also update the indices of later views in the collection in order to keep the\n  // children in sync with the collection.\n  addChildView(view, index) {\n    this.triggerMethod('before:add:child', this, view);\n\n    // increment indices of views after this one\n    this._updateIndices(view, true, index);\n\n    view._parent = this;\n\n    this._addChildView(view, index);\n\n    this.triggerMethod('add:child', this, view);\n\n    return view;\n  },\n\n  // Internal method. This decrements or increments the indices of views after the added/removed\n  // view to keep in sync with the collection.\n  _updateIndices(view, increment, index) {\n    if (!this.sort) {\n      return this;\n    }\n\n    if (increment) {\n      // assign the index to the view\n      view._index = index;\n    }\n\n    // update the indexes of views after this one\n    this.children.each((laterView) => {\n      if (laterView._index >= view._index) {\n        laterView._index += increment ? 1 : -1;\n      }\n    });\n\n    return this;\n  },\n\n  // Internal Method. Add the view to children and render it at the given index.\n  _addChildView(view, index) {\n    // Only trigger attach if already attached and not buffering,\n    // otherwise _endBuffering() or Region#show() handles this.\n    const shouldTriggerAttach = !this._isBuffering && this._isAttached;\n\n    monitorViewEvents(view);\n\n    // set up the child view event forwarding\n    this._proxyChildEvents(view);\n\n    // Store the child view itself so we can properly remove and/or destroy it later\n    this.children.add(view);\n\n    if (!view.supportsRenderLifecycle) {\n      triggerMethodOn(view, 'before:render', view);\n    }\n\n    // Render view\n    view.render();\n\n    if (!view.supportsRenderLifecycle) {\n      view._isRendered = true;\n      triggerMethodOn(view, 'render', view);\n    }\n\n    if (shouldTriggerAttach) {\n      triggerMethodOn(view, 'before:attach', view);\n    }\n\n    // Attach view\n    this.attachHtml(this, view, index);\n\n    if (shouldTriggerAttach) {\n      view._isAttached = true;\n      triggerMethodOn(view, 'attach', view);\n    }\n  },\n\n  // Build a `childView` for a model in the collection.\n  buildChildView(child, ChildViewClass, childViewOptions) {\n    const options = _.extend({model: child}, childViewOptions);\n    return new ChildViewClass(options);\n  },\n\n  // check if the collection is empty or optionally whether an array of pre-processed models is empty\n  isEmpty(options) {\n    let models;\n    if (_.result(options, 'processedModels')) {\n      models = options.processedModels;\n    } else {\n      models = this.collection ? this.collection.models : [];\n      models = this._filterModels(models);\n    }\n    return models.length === 0;\n  },\n\n  // If empty, show the empty view\n  _checkEmpty() {\n    if (this.isEmpty()) {\n      this._showEmptyView();\n    }\n\n    return this;\n  },\n\n  // You might need to override this if you've overridden attachHtml\n  attachBuffer(collectionView, buffer) {\n    collectionView.$el.append(buffer);\n  },\n\n  // Create a fragment buffer from the currently buffered children\n  _createBuffer() {\n    const elBuffer = document.createDocumentFragment();\n    _.each(this._bufferedChildren, (b) => {\n      elBuffer.appendChild(b.el);\n    });\n    return elBuffer;\n  },\n\n  // Append the HTML to the collection's `el`. Override this method to do something other\n  // than `.append`.\n  attachHtml(collectionView, childView, index) {\n    if (collectionView._isBuffering) {\n      // buffering happens on reset events and initial renders\n      // in order to reduce the number of inserts into the\n      // document, which are expensive.\n      collectionView._bufferedChildren.splice(index, 0, childView);\n    } else {\n      // If we've already rendered the main collection, append\n      // the new child into the correct order if we need to. Otherwise\n      // append to the end.\n      if (!collectionView._insertBefore(childView, index)) {\n        collectionView._insertAfter(childView);\n      }\n    }\n  },\n\n  // Internal method. Check whether we need to insert the view into the correct position.\n  _insertBefore(childView, index) {\n    let currentView;\n    const findPosition = this.sort && (index < this.children.length - 1);\n    if (findPosition) {\n      // Find the view after this one\n      currentView = this.children.find((view) => {\n        return view._index === index + 1;\n      });\n    }\n\n    if (currentView) {\n      currentView.$el.before(childView.el);\n      return true;\n    }\n\n    return false;\n  },\n\n  // Internal method. Append a view to the end of the $el\n  _insertAfter(childView) {\n    this.$el.append(childView.el);\n  },\n\n  // Internal method to set up the `children` object for storing all of the child views\n  _initChildViewStorage() {\n    this.children = new ChildViewContainer();\n  },\n\n  // called by ViewMixin destroy\n  _removeChildren() {\n    this._destroyChildren({checkEmpty: false});\n  },\n\n  // Destroy the child views that this collection view is holding on to, if any\n  _destroyChildren(options) {\n    const childViews = this.children.map(_.identity);\n\n    if (childViews.length) {\n      this.triggerMethod('before:destroy:children', this);\n      this._removeChildViews(childViews, options);\n      this.triggerMethod('destroy:children', this);\n    }\n\n    return childViews;\n  },\n\n  // Return true if the given child should be shown. Return false otherwise.\n  // The filter will be passed (child, index, collection), where\n  //  'child' is the given model\n  //  'index' is the index of that model in the collection\n  //  'collection' is the collection referenced by this CollectionView\n  _shouldAddChild(child, index) {\n    const filter = this.filter;\n    return !_.isFunction(filter) || filter.call(this, child, index, this.collection);\n  },\n\n  // Set up the child view event forwarding. Uses a \"childview:\" prefix in front of all forwarded events.\n  _proxyChildEvents(view) {\n    const prefix = _.result(this, 'childViewEventPrefix');\n\n    // Forward all child view events through the parent,\n    // prepending \"childview:\" to the event name\n    this.listenTo(view, 'all', (eventName, ...args) => {\n\n      const childEventName = prefix + ':' + eventName;\n\n      const childViewEvents = this.normalizeMethods(this._childViewEvents);\n\n      // call collectionView childViewEvent if defined\n      if (typeof childViewEvents !== 'undefined' && _.isFunction(childViewEvents[eventName])) {\n        childViewEvents[eventName].apply(this, args);\n      }\n\n      // use the parent view's proxyEvent handlers\n      const childViewTriggers = this._childViewTriggers;\n\n      // Call the event with the proxy name on the parent layout\n      if (childViewTriggers && _.isString(childViewTriggers[eventName])) {\n        this.triggerMethod(childViewTriggers[eventName], ...args);\n      }\n\n      this.triggerMethod(childEventName, ...args);\n    });\n  }\n});\n\n_.extend(CollectionView.prototype, ViewMixin);\n\nexport default CollectionView;\n","// Composite View\n// --------------\n\nimport _               from 'underscore';\nimport deprecate       from './utils/deprecate';\nimport MarionetteError from './error';\nimport CollectionView  from './collection-view';\nimport View            from './view';\n\nconst ClassOptions = [\n  'childViewContainer',\n  'template',\n  'templateContext'\n];\n\n// Used for rendering a branch-leaf, hierarchical structure.\n// Extends directly from CollectionView\n// @deprecated\nconst CompositeView = CollectionView.extend({\n\n  // Setting up the inheritance chain which allows changes to\n  // Marionette.CollectionView.prototype.constructor which allows overriding\n  // option to pass '{sort: false}' to prevent the CompositeView from\n  // maintaining the sorted order of the collection.\n  // This will fallback onto appending childView's to the end.\n  constructor(options) {\n    deprecate('CompositeView is deprecated. Convert to View at your earliest convenience');\n\n    this.mergeOptions(options, ClassOptions);\n\n    CollectionView.prototype.constructor.apply(this, arguments);\n  },\n\n  // Configured the initial events that the composite view\n  // binds to. Override this method to prevent the initial\n  // events, or to add your own initial events.\n  _initialEvents() {\n\n    // Bind only after composite view is rendered to avoid adding child views\n    // to nonexistent childViewContainer\n\n    if (this.collection) {\n      this.listenTo(this.collection, 'add', this._onCollectionAdd);\n      this.listenTo(this.collection, 'update', this._onCollectionUpdate);\n      this.listenTo(this.collection, 'reset', this.renderChildren);\n\n      if (this.sort) {\n        this.listenTo(this.collection, 'sort', this._sortViews);\n      }\n    }\n  },\n\n  // Retrieve the `childView` to be used when rendering each of\n  // the items in the collection. The default is to return\n  // `this.childView` or Marionette.CompositeView if no `childView`\n  // has been defined. As happens in CollectionView, `childView` can\n  // be a function (which should return a view class).\n  _getChildView(child) {\n    let childView = this.childView;\n\n    // for CompositeView, if `childView` is not specified, we'll get the same\n    // composite view class rendered for each child in the collection\n    // then check if the `childView` is a view class (the common case)\n    // finally check if it's a function (which we assume that returns a view class)\n    if (!childView) {\n      return this.constructor;\n    }\n\n    childView = this._getView(childView, child);\n\n    if (!childView) {\n      throw new MarionetteError({\n        name: 'InvalidChildViewError',\n        message: '\"childView\" must be a view class or a function that returns a view class'\n      });\n    }\n\n    return childView;\n  },\n\n  // Return the serialized model\n  serializeData() {\n    return this.serializeModel();\n  },\n\n  // Renders the model and the collection.\n  render() {\n    this._ensureViewIsIntact();\n    this._isRendering = true;\n    this.resetChildViewContainer();\n\n    this.triggerMethod('before:render', this);\n\n    this._renderTemplate();\n    this.bindUIElements();\n    this.renderChildren();\n\n    this._isRendering = false;\n    this._isRendered = true;\n    this.triggerMethod('render', this);\n    return this;\n  },\n\n  renderChildren() {\n    if (this._isRendered || this._isRendering) {\n      CollectionView.prototype._renderChildren.call(this);\n    }\n  },\n\n  // You might need to override this if you've overridden attachHtml\n  attachBuffer(compositeView, buffer) {\n    const $container = this.getChildViewContainer(compositeView);\n    $container.append(buffer);\n  },\n\n  // Internal method. Append a view to the end of the $el.\n  // Overidden from CollectionView to ensure view is appended to\n  // childViewContainer\n  _insertAfter(childView) {\n    const $container = this.getChildViewContainer(this, childView);\n    $container.append(childView.el);\n  },\n\n  // Internal method. Append reordered childView'.\n  // Overidden from CollectionView to ensure reordered views\n  // are appended to childViewContainer\n  _appendReorderedChildren(children) {\n    const $container = this.getChildViewContainer(this);\n    $container.append(children);\n  },\n\n  // Internal method to ensure an `$childViewContainer` exists, for the\n  // `attachHtml` method to use.\n  getChildViewContainer(containerView, childView) {\n    if (!!containerView.$childViewContainer) {\n      return containerView.$childViewContainer;\n    }\n\n    let container;\n    const childViewContainer = containerView.childViewContainer;\n    if (childViewContainer) {\n\n      const selector = _.result(containerView, 'childViewContainer');\n\n      if (selector.charAt(0) === '@' && containerView.ui) {\n        container = containerView.ui[selector.substr(4)];\n      } else {\n        container = containerView.$(selector);\n      }\n\n      if (container.length <= 0) {\n        throw new MarionetteError({\n          name: 'ChildViewContainerMissingError',\n          message: `The specified \"childViewContainer\" was not found: ${containerView.childViewContainer}`\n        });\n      }\n\n    } else {\n      container = containerView.$el;\n    }\n\n    containerView.$childViewContainer = container;\n    return container;\n  },\n\n  // Internal method to reset the `$childViewContainer` on render\n  resetChildViewContainer() {\n    if (this.$childViewContainer) {\n      this.$childViewContainer = undefined;\n    }\n  }\n});\n\n// To prevent duplication but allow the best View organization\n// Certain View methods are mixed directly into the deprecated CompositeView\nconst MixinFromView = _.pick(View.prototype, 'serializeModel', 'getTemplate', '_renderTemplate', 'mixinTemplateContext', 'attachElContent');\n_.extend(CompositeView.prototype, MixinFromView);\n\nexport default CompositeView;\n","// Behavior\n// --------\n\n// A Behavior is an isolated set of DOM /\n// user interactions that can be mixed into any View.\n// Behaviors allow you to blackbox View specific interactions\n// into portable logical chunks, keeping your views simple and your code DRY.\n\nimport _                  from 'underscore';\nimport getUniqueEventName from './utils/get-unique-event-name';\nimport MarionetteObject   from './object';\nimport DelegateEntityEventsMixin      from './mixins/delegate-entity-events';\nimport TriggersMixin      from './mixins/triggers';\nimport UIMixin            from './mixins/ui';\n\nconst ClassOptions = [\n  'collectionEvents',\n  'events',\n  'modelEvents',\n  'triggers',\n  'ui'\n];\n\nconst Behavior = MarionetteObject.extend({\n  cidPrefix: 'mnb',\n\n  constructor(options, view) {\n    // Setup reference to the view.\n    // this comes in handle when a behavior\n    // wants to directly talk up the chain\n    // to the view.\n    this.view = view;\n    this.defaults = _.clone(_.result(this, 'defaults', {}));\n    this._setOptions(this.defaults, options);\n    this.mergeOptions(this.options, ClassOptions);\n\n    // Construct an internal UI hash using\n    // the behaviors UI hash and then the view UI hash.\n    // This allows the user to use UI hash elements\n    // defined in the parent view as well as those\n    // defined in the given behavior.\n    // This order will help the reuse and share of a behavior\n    // between multiple views, while letting a view override a\n    // selector under an UI key.\n    this.ui = _.extend({}, _.result(this, 'ui'), _.result(view, 'ui'));\n\n    MarionetteObject.apply(this, arguments);\n  },\n\n  // proxy behavior $ method to the view\n  // this is useful for doing jquery DOM lookups\n  // scoped to behaviors view.\n  $() {\n    return this.view.$.apply(this.view, arguments);\n  },\n\n  // Stops the behavior from listening to events.\n  // Overrides Object#destroy to prevent additional events from being triggered.\n  destroy() {\n    this.stopListening();\n\n    return this;\n  },\n\n  proxyViewProperties() {\n    this.$el = this.view.$el;\n    this.el = this.view.el;\n\n    return this;\n  },\n\n  bindUIElements() {\n    this._bindUIElements();\n\n    return this;\n  },\n\n  unbindUIElements() {\n    this._unbindUIElements();\n\n    return this;\n  },\n\n  getUI(name) {\n    this.view._ensureViewIsIntact();\n    return this._getUI(name);\n  },\n\n  // Handle `modelEvents`, and `collectionEvents` configuration\n  delegateEntityEvents() {\n    this._delegateEntityEvents(this.view.model, this.view.collection);\n\n    return this;\n  },\n\n  undelegateEntityEvents() {\n    this._undelegateEntityEvents(this.view.model, this.view.collection);\n\n    return this;\n  },\n\n  getEvents() {\n    // Normalize behavior events hash to allow\n    // a user to use the @ui. syntax.\n    const behaviorEvents = this.normalizeUIKeys(_.result(this, 'events'));\n\n    // binds the handler to the behavior and builds a unique eventName\n    return _.reduce(behaviorEvents, function(events, behaviorHandler, key) {\n      if (!_.isFunction(behaviorHandler)) {\n        behaviorHandler = this[behaviorHandler];\n      }\n      if (!behaviorHandler) { return; }\n      key = getUniqueEventName(key);\n      events[key] = _.bind(behaviorHandler, this);\n      return events;\n    } , {}, this);\n  },\n\n  // Internal method to build all trigger handlers for a given behavior\n  getTriggers() {\n    if (!this.triggers) { return; }\n\n    // Normalize behavior triggers hash to allow\n    // a user to use the @ui. syntax.\n    const behaviorTriggers = this.normalizeUIKeys(_.result(this, 'triggers'));\n\n    return this._getViewTriggers(this.view, behaviorTriggers);\n  }\n\n});\n\n_.extend(Behavior.prototype, DelegateEntityEventsMixin, TriggersMixin, UIMixin);\n\nexport default Behavior;\n","// Application\n// -----------\nimport _                from 'underscore';\nimport MarionetteObject from './object';\nimport Region           from './region';\n\nconst ClassOptions = [\n  'region',\n  'regionClass'\n];\n\n// A container for a Marionette application.\nconst Application = MarionetteObject.extend({\n  cidPrefix: 'mna',\n\n  constructor(options) {\n    this._setOptions(options);\n\n    this.mergeOptions(options, ClassOptions);\n\n    this._initRegion();\n\n    MarionetteObject.prototype.constructor.apply(this, arguments);\n  },\n\n  regionClass: Region,\n\n  _initRegion(options) {\n    const region = this.region;\n    const RegionClass = this.regionClass;\n\n    // if the region is a string expect an el or selector\n    // and instantiate a region\n    if (_.isString(region)) {\n      this._region = new RegionClass({\n        el: region\n      });\n      return;\n    }\n\n    this._region = region;\n  },\n\n  getRegion() {\n    return this._region;\n  },\n\n  showView(view, ...args) {\n    const region = this.getRegion();\n    return region.show(view, ...args);\n  },\n\n  getView() {\n    return this.getRegion().currentView;\n  },\n\n  // kick off all of the application's processes.\n  start(options) {\n    this.triggerMethod('before:start', this, options);\n    this.triggerMethod('start', this, options);\n    return this;\n  }\n\n});\n\nexport default Application;\n","// App Router\n// ----------\n\n// Reduce the boilerplate code of handling route events\n// and then calling a single method on another object,\n// called a controller.\n// Have your routers configured to call the method on\n// your controller, directly.\n//\n// Configure an AppRouter with `appRoutes`.\n//\n// App routers can only take one `controller` object.\n// It is recommended that you divide your controller\n// objects in to smaller pieces of related functionality\n// and have multiple routers / controllers, instead of\n// just one giant router and controller.\n//\n// You can also add standard routes to an AppRouter.\n\nimport Backbone                from 'backbone';\nimport _                       from 'underscore';\nimport { triggerMethod }       from './common/trigger-method';\nimport MarionetteError         from './error';\nimport CommonMixin             from './mixins/common';\n\nconst ClassOptions = [\n  'appRoutes',\n  'controller'\n];\n\nconst AppRouter = Backbone.Router.extend({\n\n  constructor(options) {\n    this._setOptions(options);\n\n    this.mergeOptions(options, ClassOptions);\n\n    Backbone.Router.apply(this, arguments);\n\n    const appRoutes = this.appRoutes;\n    const controller = this._getController();\n    this.processAppRoutes(controller, appRoutes);\n    this.on('route', this._processOnRoute, this);\n  },\n\n  // Similar to route method on a Backbone Router but\n  // method is called on the controller\n  appRoute(route, methodName) {\n    const controller = this._getController();\n    this._addAppRoute(controller, route, methodName);\n    return this;\n  },\n\n  // process the route event and trigger the onRoute\n  // method call, if it exists\n  _processOnRoute(routeName, routeArgs) {\n    // make sure an onRoute before trying to call it\n    if (_.isFunction(this.onRoute)) {\n      // find the path that matches the current route\n      const routePath = _.invert(this.appRoutes)[routeName];\n      this.onRoute(routeName, routePath, routeArgs);\n    }\n  },\n\n  // Internal method to process the `appRoutes` for the\n  // router, and turn them in to routes that trigger the\n  // specified method on the specified `controller`.\n  processAppRoutes(controller, appRoutes) {\n    if (!appRoutes) { return this; }\n\n    const routeNames = _.keys(appRoutes).reverse(); // Backbone requires reverted order of routes\n\n    _.each(routeNames, route => {\n      this._addAppRoute(controller, route, appRoutes[route]);\n    });\n\n    return this;\n  },\n\n  _getController() {\n    return this.controller;\n  },\n\n  _addAppRoute(controller, route, methodName) {\n    const method = controller[methodName];\n\n    if (!method) {\n      throw new MarionetteError(`Method \"${methodName}\" was not found on the controller`);\n    }\n\n    this.route(route, methodName, _.bind(method, controller));\n  },\n\n  triggerMethod: triggerMethod\n});\n\n_.extend(AppRouter.prototype, CommonMixin);\n\nexport default AppRouter;\n","import Backbone           from 'backbone';\nimport {version}          from '../package.json';\n\nimport proxy              from './utils/proxy';\nimport extend             from './utils/extend';\nimport deprecate          from './utils/deprecate';\n\nimport isNodeAttached     from './common/is-node-attached';\nimport mergeOptions       from './common/merge-options';\nimport getOption          from './common/get-option';\nimport normalizeMethods   from './common/normalize-methods';\nimport monitorViewEvents  from './common/monitor-view-events';\n\nimport {\n  bindEvents,\n  unbindEvents\n} from './common/bind-events';\n\nimport {\n  bindRequests,\n  unbindRequests\n} from './common/bind-requests';\n\nimport {\n  triggerMethod,\n  triggerMethodOn\n} from './common/trigger-method';\n\n\nimport MarionetteObject   from './object';\nimport TemplateCache      from './template-cache';\nimport View               from './view';\nimport CollectionView     from './collection-view';\nimport CompositeView      from './composite-view';\nimport Behavior           from './behavior';\nimport Region             from './region';\nimport Application        from './application';\nimport AppRouter          from './app-router';\nimport MarionetteError    from './error';\n\nimport behaviorsLookup    from './config/behaviors-lookup';\nimport Renderer           from './config/renderer';\n\nimport {\n  FEATURES,\n  isEnabled,\n  setEnabled\n} from './config/features';\n\nconst previousMarionette = Backbone.Marionette;\nconst Marionette = Backbone.Marionette = {};\n\n// This allows you to run multiple instances of Marionette on the same\n// webapp. After loading the new version, call `noConflict()` to\n// get a reference to it. At the same time the old version will be\n// returned to Backbone.Marionette.\nMarionette.noConflict = function() {\n  Backbone.Marionette = previousMarionette;\n  return this;\n};\n\n// Utilities\nMarionette.bindEvents = proxy(bindEvents);\nMarionette.unbindEvents = proxy(unbindEvents);\nMarionette.bindRequests = proxy(bindRequests);\nMarionette.unbindRequests = proxy(unbindRequests);\nMarionette.mergeOptions = proxy(mergeOptions);\nMarionette.getOption = proxy(getOption);\nMarionette.normalizeMethods = proxy(normalizeMethods);\nMarionette.extend = extend;\nMarionette.isNodeAttached = isNodeAttached;\nMarionette.deprecate = deprecate;\nMarionette.triggerMethod = proxy(triggerMethod);\nMarionette.triggerMethodOn = triggerMethodOn;\nMarionette.isEnabled = isEnabled;\nMarionette.setEnabled = setEnabled;\nMarionette.monitorViewEvents = monitorViewEvents;\n\nMarionette.Behaviors = {};\nMarionette.Behaviors.behaviorsLookup = behaviorsLookup;\n\n// Classes\nMarionette.Application = Application;\nMarionette.AppRouter = AppRouter;\nMarionette.Renderer = Renderer;\nMarionette.TemplateCache = TemplateCache;\nMarionette.View = View;\nMarionette.CollectionView = CollectionView;\nMarionette.CompositeView = CompositeView;\nMarionette.Behavior = Behavior;\nMarionette.Region = Region;\nMarionette.Error = MarionetteError;\nMarionette.Object = MarionetteObject;\n\n// Configuration\nMarionette.DEV_MODE = false;\nMarionette.FEATURES = FEATURES;\nMarionette.VERSION = version;\n\nexport default Marionette;\n"],"sourceRoot":"/source/"}